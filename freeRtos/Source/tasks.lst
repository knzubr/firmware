   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 157               	prvIdleTask:
 158               		.stabd	46,0,0
   1:../../freeRtos/Source/tasks.c **** /*
   2:../../freeRtos/Source/tasks.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/tasks.c **** 
   4:../../freeRtos/Source/tasks.c ****     ***************************************************************************
   5:../../freeRtos/Source/tasks.c ****     *                                                                         *
   6:../../freeRtos/Source/tasks.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/tasks.c ****     *                                                                         *
   8:../../freeRtos/Source/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/tasks.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/tasks.c ****     *                                                                         *
  13:../../freeRtos/Source/tasks.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/tasks.c ****     *                                                                         *
  15:../../freeRtos/Source/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/tasks.c ****     *                                                                         *
  18:../../freeRtos/Source/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/tasks.c ****     *                                                                         *
  23:../../freeRtos/Source/tasks.c ****     ***************************************************************************
  24:../../freeRtos/Source/tasks.c **** 
  25:../../freeRtos/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/tasks.c **** 
  27:../../freeRtos/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/tasks.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/tasks.c **** 
  42:../../freeRtos/Source/tasks.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/tasks.c **** 
  44:../../freeRtos/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/tasks.c ****     contact details.
  46:../../freeRtos/Source/tasks.c **** 
  47:../../freeRtos/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/tasks.c ****     critical systems.
  49:../../freeRtos/Source/tasks.c **** 
  50:../../freeRtos/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/tasks.c ****     licensing and training services.
  52:../../freeRtos/Source/tasks.c **** */
  53:../../freeRtos/Source/tasks.c **** 
  54:../../freeRtos/Source/tasks.c **** 
  55:../../freeRtos/Source/tasks.c **** #include <stdio.h>
  56:../../freeRtos/Source/tasks.c **** #include <stdlib.h>
  57:../../freeRtos/Source/tasks.c **** #include <string.h>
  58:../../freeRtos/Source/tasks.c **** 
  59:../../freeRtos/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../../freeRtos/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../../freeRtos/Source/tasks.c **** task.h is included from an application file. */
  62:../../freeRtos/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../../freeRtos/Source/tasks.c **** 
  64:../../freeRtos/Source/tasks.c **** #include "FreeRTOS.h"
  65:../../freeRtos/Source/tasks.c **** #include "task.h"
  66:../../freeRtos/Source/tasks.c **** #include "StackMacros.h"
  67:../../freeRtos/Source/tasks.c **** 
  68:../../freeRtos/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:../../freeRtos/Source/tasks.c **** 
  70:../../freeRtos/Source/tasks.c **** /*
  71:../../freeRtos/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:../../freeRtos/Source/tasks.c ****  */
  73:../../freeRtos/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:../../freeRtos/Source/tasks.c **** 
  75:../../freeRtos/Source/tasks.c **** /*
  76:../../freeRtos/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:../../freeRtos/Source/tasks.c ****  * and stores the context of the task.
  78:../../freeRtos/Source/tasks.c ****  */
  79:../../freeRtos/Source/tasks.c **** typedef struct tskTaskControlBlock
  80:../../freeRtos/Source/tasks.c **** {
  81:../../freeRtos/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:../../freeRtos/Source/tasks.c **** 
  83:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:../../freeRtos/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:../../freeRtos/Source/tasks.c **** 	#endif	
  86:../../freeRtos/Source/tasks.c **** 	
  87:../../freeRtos/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:../../freeRtos/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:../../freeRtos/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:../../freeRtos/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:../../freeRtos/Source/tasks.c **** 
  93:../../freeRtos/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  94:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:../../freeRtos/Source/tasks.c **** 	#endif
  96:../../freeRtos/Source/tasks.c **** 
  97:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:../../freeRtos/Source/tasks.c **** 	#endif
 100:../../freeRtos/Source/tasks.c **** 
 101:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:../../freeRtos/Source/tasks.c **** 	#endif
 104:../../freeRtos/Source/tasks.c **** 
 105:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 106:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:../../freeRtos/Source/tasks.c **** 	#endif
 108:../../freeRtos/Source/tasks.c **** 
 109:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:../../freeRtos/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:../../freeRtos/Source/tasks.c **** 	#endif
 112:../../freeRtos/Source/tasks.c **** 
 113:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:../../freeRtos/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:../../freeRtos/Source/tasks.c **** 	#endif
 116:../../freeRtos/Source/tasks.c **** 
 117:../../freeRtos/Source/tasks.c **** } tskTCB;
 118:../../freeRtos/Source/tasks.c **** 
 119:../../freeRtos/Source/tasks.c **** 
 120:../../freeRtos/Source/tasks.c **** /*
 121:../../freeRtos/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:../../freeRtos/Source/tasks.c ****  * than file scope.
 123:../../freeRtos/Source/tasks.c ****  */
 124:../../freeRtos/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:../../freeRtos/Source/tasks.c **** 	#define static
 126:../../freeRtos/Source/tasks.c **** #endif
 127:../../freeRtos/Source/tasks.c **** 
 128:../../freeRtos/Source/tasks.c **** /*lint -e956 */
 129:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:../../freeRtos/Source/tasks.c **** 
 131:../../freeRtos/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 132:../../freeRtos/Source/tasks.c **** 
 133:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:../../freeRtos/Source/tasks.c **** 
 140:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 141:../../freeRtos/Source/tasks.c **** 
 142:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:../../freeRtos/Source/tasks.c **** 
 145:../../freeRtos/Source/tasks.c **** #endif
 146:../../freeRtos/Source/tasks.c **** 
 147:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:../../freeRtos/Source/tasks.c **** 
 149:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:../../freeRtos/Source/tasks.c **** 
 151:../../freeRtos/Source/tasks.c **** #endif
 152:../../freeRtos/Source/tasks.c **** 
 153:../../freeRtos/Source/tasks.c **** /* File private variables. --------------------------------*/
 154:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:../../freeRtos/Source/tasks.c **** 
 165:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:../../freeRtos/Source/tasks.c **** 
 167:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:../../freeRtos/Source/tasks.c **** 
 171:../../freeRtos/Source/tasks.c **** #endif
 172:../../freeRtos/Source/tasks.c **** 
 173:../../freeRtos/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:../../freeRtos/Source/tasks.c **** 
 175:../../freeRtos/Source/tasks.c **** /*
 176:../../freeRtos/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 177:../../freeRtos/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 178:../../freeRtos/Source/tasks.c ****  */
 179:../../freeRtos/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:../../freeRtos/Source/tasks.c **** 
 181:../../freeRtos/Source/tasks.c **** /*
 182:../../freeRtos/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 183:../../freeRtos/Source/tasks.c ****  */
 184:../../freeRtos/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:../../freeRtos/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:../../freeRtos/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:../../freeRtos/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:../../freeRtos/Source/tasks.c **** 
 189:../../freeRtos/Source/tasks.c **** /*
 190:../../freeRtos/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 191:../../freeRtos/Source/tasks.c ****  */
 192:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:../../freeRtos/Source/tasks.c **** 
 194:../../freeRtos/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:../../freeRtos/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:../../freeRtos/Source/tasks.c **** 
 202:../../freeRtos/Source/tasks.c **** #endif
 203:../../freeRtos/Source/tasks.c **** 
 204:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 205:../../freeRtos/Source/tasks.c **** 
 206:../../freeRtos/Source/tasks.c **** /*
 207:../../freeRtos/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:../../freeRtos/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 209:../../freeRtos/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 210:../../freeRtos/Source/tasks.c ****  * it if not using the facility.
 211:../../freeRtos/Source/tasks.c ****  */
 212:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:../../freeRtos/Source/tasks.c **** 
 214:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 215:../../freeRtos/Source/tasks.c **** 	{																								\
 216:../../freeRtos/Source/tasks.c **** 		if( xTracing )																				\
 217:../../freeRtos/Source/tasks.c **** 		{																							\
 218:../../freeRtos/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 219:../../freeRtos/Source/tasks.c **** 			{																						\
 220:../../freeRtos/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 221:../../freeRtos/Source/tasks.c **** 				{																					\
 222:../../freeRtos/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 223:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 224:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 225:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 226:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:../../freeRtos/Source/tasks.c **** 				}																					\
 228:../../freeRtos/Source/tasks.c **** 				else																				\
 229:../../freeRtos/Source/tasks.c **** 				{																					\
 230:../../freeRtos/Source/tasks.c **** 					xTracing = pdFALSE;																\
 231:../../freeRtos/Source/tasks.c **** 				}																					\
 232:../../freeRtos/Source/tasks.c **** 			}																						\
 233:../../freeRtos/Source/tasks.c **** 		}																							\
 234:../../freeRtos/Source/tasks.c **** 	}
 235:../../freeRtos/Source/tasks.c **** 
 236:../../freeRtos/Source/tasks.c **** #else
 237:../../freeRtos/Source/tasks.c **** 
 238:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 239:../../freeRtos/Source/tasks.c **** 
 240:../../freeRtos/Source/tasks.c **** #endif
 241:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/tasks.c **** 
 243:../../freeRtos/Source/tasks.c **** /*
 244:../../freeRtos/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:../../freeRtos/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:../../freeRtos/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 247:../../freeRtos/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 248:../../freeRtos/Source/tasks.c ****  * executing task has been rescheduled.
 249:../../freeRtos/Source/tasks.c ****  */
 250:../../freeRtos/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:../../freeRtos/Source/tasks.c **** {																												\
 252:../../freeRtos/Source/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:../../freeRtos/Source/tasks.c **** 	{																											\
 254:../../freeRtos/Source/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:../../freeRtos/Source/tasks.c **** 	}																											\
 256:../../freeRtos/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:../../freeRtos/Source/tasks.c **** }
 258:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 259:../../freeRtos/Source/tasks.c **** 
 260:../../freeRtos/Source/tasks.c **** /*
 261:../../freeRtos/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:../../freeRtos/Source/tasks.c ****  * any require waking.
 263:../../freeRtos/Source/tasks.c ****  *
 264:../../freeRtos/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:../../freeRtos/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 266:../../freeRtos/Source/tasks.c ****  * any further down the list.
 267:../../freeRtos/Source/tasks.c ****  */
 268:../../freeRtos/Source/tasks.c **** #define prvCheckDelayedTasks()																						\
 269:../../freeRtos/Source/tasks.c **** {																													\
 270:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;																								\
 271:../../freeRtos/Source/tasks.c **** 																													\
 272:../../freeRtos/Source/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:../../freeRtos/Source/tasks.c **** 	{																												\
 274:../../freeRtos/Source/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:../../freeRtos/Source/tasks.c **** 		{																											\
 276:../../freeRtos/Source/tasks.c **** 			break;																									\
 277:../../freeRtos/Source/tasks.c **** 		}																											\
 278:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:../../freeRtos/Source/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 280:../../freeRtos/Source/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:../../freeRtos/Source/tasks.c **** 		{																											\
 282:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:../../freeRtos/Source/tasks.c **** 		}																											\
 284:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:../../freeRtos/Source/tasks.c **** 	}																												\
 286:../../freeRtos/Source/tasks.c **** }
 287:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 288:../../freeRtos/Source/tasks.c **** 
 289:../../freeRtos/Source/tasks.c **** /*
 290:../../freeRtos/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:../../freeRtos/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 292:../../freeRtos/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 293:../../freeRtos/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:../../freeRtos/Source/tasks.c ****  */
 295:../../freeRtos/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:../../freeRtos/Source/tasks.c **** 
 297:../../freeRtos/Source/tasks.c **** 
 298:../../freeRtos/Source/tasks.c **** /* File private functions. --------------------------------*/
 299:../../freeRtos/Source/tasks.c **** 
 300:../../freeRtos/Source/tasks.c **** /*
 301:../../freeRtos/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:../../freeRtos/Source/tasks.c ****  * into the TCB structure.
 303:../../freeRtos/Source/tasks.c ****  */
 304:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:../../freeRtos/Source/tasks.c **** 
 306:../../freeRtos/Source/tasks.c **** /*
 307:../../freeRtos/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:../../freeRtos/Source/tasks.c ****  * automatically upon the creation of the first task.
 309:../../freeRtos/Source/tasks.c ****  */
 310:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:../../freeRtos/Source/tasks.c **** 
 312:../../freeRtos/Source/tasks.c **** /*
 313:../../freeRtos/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:../../freeRtos/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 315:../../freeRtos/Source/tasks.c ****  * creation of the first user task.
 316:../../freeRtos/Source/tasks.c ****  *
 317:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 319:../../freeRtos/Source/tasks.c ****  *
 320:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 321:../../freeRtos/Source/tasks.c ****  *
 322:../../freeRtos/Source/tasks.c ****  */
 323:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:../../freeRtos/Source/tasks.c **** 
 325:../../freeRtos/Source/tasks.c **** /*
 326:../../freeRtos/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:../../freeRtos/Source/tasks.c ****  * including the stack pointed to by the TCB.
 328:../../freeRtos/Source/tasks.c ****  *
 329:../../freeRtos/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 330:../../freeRtos/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:../../freeRtos/Source/tasks.c ****  */
 332:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:../../freeRtos/Source/tasks.c **** 
 334:../../freeRtos/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:../../freeRtos/Source/tasks.c **** 
 336:../../freeRtos/Source/tasks.c **** #endif
 337:../../freeRtos/Source/tasks.c **** 
 338:../../freeRtos/Source/tasks.c **** /*
 339:../../freeRtos/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:../../freeRtos/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:../../freeRtos/Source/tasks.c ****  * and its TCB deleted.
 342:../../freeRtos/Source/tasks.c ****  */
 343:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:../../freeRtos/Source/tasks.c **** 
 345:../../freeRtos/Source/tasks.c **** /*
 346:../../freeRtos/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:../../freeRtos/Source/tasks.c ****  * allocation was successful.
 348:../../freeRtos/Source/tasks.c ****  */
 349:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:../../freeRtos/Source/tasks.c **** 
 351:../../freeRtos/Source/tasks.c **** /*
 352:../../freeRtos/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:../../freeRtos/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:../../freeRtos/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:../../freeRtos/Source/tasks.c ****  * within just that list.
 356:../../freeRtos/Source/tasks.c ****  *
 357:../../freeRtos/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:../../freeRtos/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 359:../../freeRtos/Source/tasks.c ****  */
 360:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:../../freeRtos/Source/tasks.c **** 
 362:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:../../freeRtos/Source/tasks.c **** 
 364:../../freeRtos/Source/tasks.c **** #endif
 365:../../freeRtos/Source/tasks.c **** 
 366:../../freeRtos/Source/tasks.c **** /*
 367:../../freeRtos/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 368:../../freeRtos/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 369:../../freeRtos/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 370:../../freeRtos/Source/tasks.c ****  */
 371:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:../../freeRtos/Source/tasks.c **** 
 373:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:../../freeRtos/Source/tasks.c **** 
 375:../../freeRtos/Source/tasks.c **** #endif
 376:../../freeRtos/Source/tasks.c **** 
 377:../../freeRtos/Source/tasks.c **** 
 378:../../freeRtos/Source/tasks.c **** /*lint +e956 */
 379:../../freeRtos/Source/tasks.c **** 
 380:../../freeRtos/Source/tasks.c **** 
 381:../../freeRtos/Source/tasks.c **** 
 382:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 383:../../freeRtos/Source/tasks.c ****  * TASK CREATION API documented in task.h
 384:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 385:../../freeRtos/Source/tasks.c **** 
 386:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:../../freeRtos/Source/tasks.c **** {
 388:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xReturn;
 389:../../freeRtos/Source/tasks.c **** tskTCB * pxNewTCB;
 390:../../freeRtos/Source/tasks.c **** 
 391:../../freeRtos/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:../../freeRtos/Source/tasks.c **** 	checking that the allocation was successful. */
 393:../../freeRtos/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:../../freeRtos/Source/tasks.c **** 
 395:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 396:../../freeRtos/Source/tasks.c **** 	{
 397:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 398:../../freeRtos/Source/tasks.c **** 
 399:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:../../freeRtos/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 401:../../freeRtos/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 402:../../freeRtos/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:../../freeRtos/Source/tasks.c **** 			{
 404:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 405:../../freeRtos/Source/tasks.c **** 			}
 406:../../freeRtos/Source/tasks.c **** 			else
 407:../../freeRtos/Source/tasks.c **** 			{
 408:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 409:../../freeRtos/Source/tasks.c **** 			}
 410:../../freeRtos/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:../../freeRtos/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:../../freeRtos/Source/tasks.c **** 
 413:../../freeRtos/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 414:../../freeRtos/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:../../freeRtos/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:../../freeRtos/Source/tasks.c **** 		required by the port. */
 417:../../freeRtos/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 418:../../freeRtos/Source/tasks.c **** 		{
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:../../freeRtos/Source/tasks.c **** //			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long )
 421:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( uint16_t ) pxTopOfStack ) & ( ( uint16_t ) ~portBYTE_A
 422:../../freeRtos/Source/tasks.c **** 		}
 423:../../freeRtos/Source/tasks.c **** 		#else
 424:../../freeRtos/Source/tasks.c **** 		{
 425:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 426:../../freeRtos/Source/tasks.c **** 
 427:../../freeRtos/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 428:../../freeRtos/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 429:../../freeRtos/Source/tasks.c **** 			other extreme of the stack space. */
 430:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 431:../../freeRtos/Source/tasks.c **** 		}
 432:../../freeRtos/Source/tasks.c **** 		#endif
 433:../../freeRtos/Source/tasks.c **** 
 434:../../freeRtos/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 435:../../freeRtos/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 436:../../freeRtos/Source/tasks.c **** 
 437:../../freeRtos/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 438:../../freeRtos/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 439:../../freeRtos/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 440:../../freeRtos/Source/tasks.c **** 		the	top of stack variable is updated. */
 441:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 442:../../freeRtos/Source/tasks.c **** 		{
 443:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 444:../../freeRtos/Source/tasks.c **** 		}
 445:../../freeRtos/Source/tasks.c **** 		#else
 446:../../freeRtos/Source/tasks.c **** 		{
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 448:../../freeRtos/Source/tasks.c **** 		}
 449:../../freeRtos/Source/tasks.c **** 		#endif
 450:../../freeRtos/Source/tasks.c **** 
 451:../../freeRtos/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 452:../../freeRtos/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 454:../../freeRtos/Source/tasks.c **** 		{
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 457:../../freeRtos/Source/tasks.c **** 			{
 458:../../freeRtos/Source/tasks.c **** 				/* As this is the first task it must also be the current task. */
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 460:../../freeRtos/Source/tasks.c **** 
 461:../../freeRtos/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 462:../../freeRtos/Source/tasks.c **** 				initialisation required.  We will not recover if this call
 463:../../freeRtos/Source/tasks.c **** 				fails, but we will report the failure. */
 464:../../freeRtos/Source/tasks.c **** 				prvInitialiseTaskLists();
 465:../../freeRtos/Source/tasks.c **** 			}
 466:../../freeRtos/Source/tasks.c **** 			else
 467:../../freeRtos/Source/tasks.c **** 			{
 468:../../freeRtos/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 469:../../freeRtos/Source/tasks.c **** 				current task if it is the highest priority task to be created
 470:../../freeRtos/Source/tasks.c **** 				so far. */
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 472:../../freeRtos/Source/tasks.c **** 				{
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 474:../../freeRtos/Source/tasks.c **** 					{
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 476:../../freeRtos/Source/tasks.c **** 					}
 477:../../freeRtos/Source/tasks.c **** 				}
 478:../../freeRtos/Source/tasks.c **** 			}
 479:../../freeRtos/Source/tasks.c **** 
 480:../../freeRtos/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 481:../../freeRtos/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 483:../../freeRtos/Source/tasks.c **** 			{
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 485:../../freeRtos/Source/tasks.c **** 			}
 486:../../freeRtos/Source/tasks.c **** 
 487:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 488:../../freeRtos/Source/tasks.c **** 			{
 489:../../freeRtos/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 491:../../freeRtos/Source/tasks.c **** 			}
 492:../../freeRtos/Source/tasks.c **** 			#endif
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 494:../../freeRtos/Source/tasks.c **** 
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 496:../../freeRtos/Source/tasks.c **** 
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 498:../../freeRtos/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 499:../../freeRtos/Source/tasks.c **** 		}
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 501:../../freeRtos/Source/tasks.c **** 	}
 502:../../freeRtos/Source/tasks.c **** 	else
 503:../../freeRtos/Source/tasks.c **** 	{
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 505:../../freeRtos/Source/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 506:../../freeRtos/Source/tasks.c **** 	}
 507:../../freeRtos/Source/tasks.c **** 
 508:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 509:../../freeRtos/Source/tasks.c **** 	{
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 511:../../freeRtos/Source/tasks.c **** 		{
 512:../../freeRtos/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 513:../../freeRtos/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 514:../../freeRtos/Source/tasks.c **** 			required.*/
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 516:../../freeRtos/Source/tasks.c **** 		}
 517:../../freeRtos/Source/tasks.c **** 
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 519:../../freeRtos/Source/tasks.c **** 		{
 520:../../freeRtos/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 521:../../freeRtos/Source/tasks.c **** 			then it should run now. */
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 523:../../freeRtos/Source/tasks.c **** 			{
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 525:../../freeRtos/Source/tasks.c **** 			}
 526:../../freeRtos/Source/tasks.c **** 		}
 527:../../freeRtos/Source/tasks.c **** 	}
 528:../../freeRtos/Source/tasks.c **** 
 529:../../freeRtos/Source/tasks.c **** 	return xReturn;
 530:../../freeRtos/Source/tasks.c **** }
 531:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 532:../../freeRtos/Source/tasks.c **** 
 533:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 534:../../freeRtos/Source/tasks.c **** 
 535:../../freeRtos/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 536:../../freeRtos/Source/tasks.c **** 	{
 537:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 538:../../freeRtos/Source/tasks.c **** 
 539:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 540:../../freeRtos/Source/tasks.c **** 		{
 541:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 542:../../freeRtos/Source/tasks.c **** 			deleted. */
 543:../../freeRtos/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 544:../../freeRtos/Source/tasks.c **** 			{
 545:../../freeRtos/Source/tasks.c **** 				pxTaskToDelete = NULL;
 546:../../freeRtos/Source/tasks.c **** 			}
 547:../../freeRtos/Source/tasks.c **** 
 548:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 549:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 550:../../freeRtos/Source/tasks.c **** 
 551:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 552:../../freeRtos/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 553:../../freeRtos/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 554:../../freeRtos/Source/tasks.c **** 			scheduler for the TCB and stack. */
 555:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 556:../../freeRtos/Source/tasks.c **** 
 557:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 558:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 559:../../freeRtos/Source/tasks.c **** 			{
 560:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 561:../../freeRtos/Source/tasks.c **** 			}
 562:../../freeRtos/Source/tasks.c **** 
 563:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 564:../../freeRtos/Source/tasks.c **** 
 565:../../freeRtos/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 566:../../freeRtos/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 567:../../freeRtos/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 568:../../freeRtos/Source/tasks.c **** 			++uxTasksDeleted;
 569:../../freeRtos/Source/tasks.c **** 
 570:../../freeRtos/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 571:../../freeRtos/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 572:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 573:../../freeRtos/Source/tasks.c **** 
 574:../../freeRtos/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 575:../../freeRtos/Source/tasks.c **** 		}
 576:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 577:../../freeRtos/Source/tasks.c **** 
 578:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 579:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 580:../../freeRtos/Source/tasks.c **** 		{
 581:../../freeRtos/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 582:../../freeRtos/Source/tasks.c **** 			{
 583:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 584:../../freeRtos/Source/tasks.c **** 			}
 585:../../freeRtos/Source/tasks.c **** 		}
 586:../../freeRtos/Source/tasks.c **** 	}
 587:../../freeRtos/Source/tasks.c **** 
 588:../../freeRtos/Source/tasks.c **** #endif
 589:../../freeRtos/Source/tasks.c **** 
 590:../../freeRtos/Source/tasks.c **** 
 591:../../freeRtos/Source/tasks.c **** 
 592:../../freeRtos/Source/tasks.c **** 
 593:../../freeRtos/Source/tasks.c **** 
 594:../../freeRtos/Source/tasks.c **** 
 595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 596:../../freeRtos/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 597:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 598:../../freeRtos/Source/tasks.c **** 
 599:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 600:../../freeRtos/Source/tasks.c **** 
 601:../../freeRtos/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 602:../../freeRtos/Source/tasks.c **** 	{
 603:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 605:../../freeRtos/Source/tasks.c **** 
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 607:../../freeRtos/Source/tasks.c **** 		{
 608:../../freeRtos/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 610:../../freeRtos/Source/tasks.c **** 
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 612:../../freeRtos/Source/tasks.c **** 			{
 613:../../freeRtos/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 614:../../freeRtos/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 615:../../freeRtos/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 616:../../freeRtos/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 617:../../freeRtos/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 619:../../freeRtos/Source/tasks.c **** 				{
 620:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 621:../../freeRtos/Source/tasks.c **** 				}
 622:../../freeRtos/Source/tasks.c **** 			}
 623:../../freeRtos/Source/tasks.c **** 			else
 624:../../freeRtos/Source/tasks.c **** 			{
 625:../../freeRtos/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 626:../../freeRtos/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 627:../../freeRtos/Source/tasks.c **** 				tick time is less than the wake time. */
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 629:../../freeRtos/Source/tasks.c **** 				{
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 631:../../freeRtos/Source/tasks.c **** 				}
 632:../../freeRtos/Source/tasks.c **** 			}
 633:../../freeRtos/Source/tasks.c **** 
 634:../../freeRtos/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 636:../../freeRtos/Source/tasks.c **** 
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 638:../../freeRtos/Source/tasks.c **** 			{
 639:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 640:../../freeRtos/Source/tasks.c **** 
 641:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 642:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 643:../../freeRtos/Source/tasks.c **** 				both lists. */
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 645:../../freeRtos/Source/tasks.c **** 
 646:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 648:../../freeRtos/Source/tasks.c **** 
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 650:../../freeRtos/Source/tasks.c **** 				{
 651:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 652:../../freeRtos/Source/tasks.c **** 					overflow list. */
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 654:../../freeRtos/Source/tasks.c **** 				}
 655:../../freeRtos/Source/tasks.c **** 				else
 656:../../freeRtos/Source/tasks.c **** 				{
 657:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 658:../../freeRtos/Source/tasks.c **** 					current block list. */
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 660:../../freeRtos/Source/tasks.c **** 				}
 661:../../freeRtos/Source/tasks.c **** 			}
 662:../../freeRtos/Source/tasks.c **** 		}
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 664:../../freeRtos/Source/tasks.c **** 
 665:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 666:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 668:../../freeRtos/Source/tasks.c **** 		{
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 670:../../freeRtos/Source/tasks.c **** 		}
 671:../../freeRtos/Source/tasks.c **** 	}
 672:../../freeRtos/Source/tasks.c **** 
 673:../../freeRtos/Source/tasks.c **** #endif
 674:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 675:../../freeRtos/Source/tasks.c **** 
 676:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 677:../../freeRtos/Source/tasks.c **** 
 678:../../freeRtos/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 679:../../freeRtos/Source/tasks.c **** 	{
 680:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 681:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 682:../../freeRtos/Source/tasks.c **** 
 683:../../freeRtos/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 685:../../freeRtos/Source/tasks.c **** 		{
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 687:../../freeRtos/Source/tasks.c **** 			{
 688:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY();
 689:../../freeRtos/Source/tasks.c **** 
 690:../../freeRtos/Source/tasks.c **** 				/* A task that is removed from the event list while the
 691:../../freeRtos/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 692:../../freeRtos/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 693:../../freeRtos/Source/tasks.c **** 				is resumed.
 694:../../freeRtos/Source/tasks.c **** 
 695:../../freeRtos/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 696:../../freeRtos/Source/tasks.c **** 				executing task. */
 697:../../freeRtos/Source/tasks.c **** 
 698:../../freeRtos/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 699:../../freeRtos/Source/tasks.c **** 				not a problem. */
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 701:../../freeRtos/Source/tasks.c **** 
 702:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 703:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 704:../../freeRtos/Source/tasks.c **** 				both lists. */
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 706:../../freeRtos/Source/tasks.c **** 
 707:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 709:../../freeRtos/Source/tasks.c **** 
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 711:../../freeRtos/Source/tasks.c **** 				{
 712:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 713:../../freeRtos/Source/tasks.c **** 					overflow list. */
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 715:../../freeRtos/Source/tasks.c **** 				}
 716:../../freeRtos/Source/tasks.c **** 				else
 717:../../freeRtos/Source/tasks.c **** 				{
 718:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 719:../../freeRtos/Source/tasks.c **** 					current block list. */
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 721:../../freeRtos/Source/tasks.c **** 				}
 722:../../freeRtos/Source/tasks.c **** 			}
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 724:../../freeRtos/Source/tasks.c **** 		}
 725:../../freeRtos/Source/tasks.c **** 
 726:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 727:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 729:../../freeRtos/Source/tasks.c **** 		{
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 731:../../freeRtos/Source/tasks.c **** 		}
 732:../../freeRtos/Source/tasks.c **** 	}
 733:../../freeRtos/Source/tasks.c **** 
 734:../../freeRtos/Source/tasks.c **** #endif
 735:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 736:../../freeRtos/Source/tasks.c **** 
 737:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 738:../../freeRtos/Source/tasks.c **** 
 739:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 740:../../freeRtos/Source/tasks.c **** 	{
 741:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 742:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 743:../../freeRtos/Source/tasks.c **** 
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 745:../../freeRtos/Source/tasks.c **** 		{
 746:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 747:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 749:../../freeRtos/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 750:../../freeRtos/Source/tasks.c **** 		}
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 752:../../freeRtos/Source/tasks.c **** 
 753:../../freeRtos/Source/tasks.c **** 		return uxReturn;
 754:../../freeRtos/Source/tasks.c **** 	}
 755:../../freeRtos/Source/tasks.c **** 
 756:../../freeRtos/Source/tasks.c **** #endif
 757:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 758:../../freeRtos/Source/tasks.c **** 
 759:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 760:../../freeRtos/Source/tasks.c **** 
 761:../../freeRtos/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 762:../../freeRtos/Source/tasks.c **** 	{
 763:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 764:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 765:../../freeRtos/Source/tasks.c **** 
 766:../../freeRtos/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 767:../../freeRtos/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 768:../../freeRtos/Source/tasks.c **** 		{
 769:../../freeRtos/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 770:../../freeRtos/Source/tasks.c **** 		}
 771:../../freeRtos/Source/tasks.c **** 
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 773:../../freeRtos/Source/tasks.c **** 		{
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 775:../../freeRtos/Source/tasks.c **** 			{
 776:../../freeRtos/Source/tasks.c **** 				pxTask = NULL;
 777:../../freeRtos/Source/tasks.c **** 			}
 778:../../freeRtos/Source/tasks.c **** 
 779:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 780:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 782:../../freeRtos/Source/tasks.c **** 
 783:../../freeRtos/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 784:../../freeRtos/Source/tasks.c **** 
 785:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 786:../../freeRtos/Source/tasks.c **** 			{
 787:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 788:../../freeRtos/Source/tasks.c **** 			}
 789:../../freeRtos/Source/tasks.c **** 			#else
 790:../../freeRtos/Source/tasks.c **** 			{
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 792:../../freeRtos/Source/tasks.c **** 			}
 793:../../freeRtos/Source/tasks.c **** 			#endif
 794:../../freeRtos/Source/tasks.c **** 
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 796:../../freeRtos/Source/tasks.c **** 			{
 797:../../freeRtos/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 798:../../freeRtos/Source/tasks.c **** 				priority than the calling task. */
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 800:../../freeRtos/Source/tasks.c **** 				{
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 802:../../freeRtos/Source/tasks.c **** 					{
 803:../../freeRtos/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 804:../../freeRtos/Source/tasks.c **** 						were raising the priority of the currently running task
 805:../../freeRtos/Source/tasks.c **** 						there would be no need to switch as it must have already
 806:../../freeRtos/Source/tasks.c **** 						been the highest priority task. */
 807:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 808:../../freeRtos/Source/tasks.c **** 					}
 809:../../freeRtos/Source/tasks.c **** 				}
 810:../../freeRtos/Source/tasks.c **** 				else if( pxTask == NULL )
 811:../../freeRtos/Source/tasks.c **** 				{
 812:../../freeRtos/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 813:../../freeRtos/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 814:../../freeRtos/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 815:../../freeRtos/Source/tasks.c **** 				}
 816:../../freeRtos/Source/tasks.c **** 
 817:../../freeRtos/Source/tasks.c **** 
 818:../../freeRtos/Source/tasks.c **** 
 819:../../freeRtos/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 820:../../freeRtos/Source/tasks.c **** 				{
 821:../../freeRtos/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 822:../../freeRtos/Source/tasks.c **** 					currently using an inherited priority. */
 823:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 824:../../freeRtos/Source/tasks.c **** 					{
 825:../../freeRtos/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 826:../../freeRtos/Source/tasks.c **** 					}
 827:../../freeRtos/Source/tasks.c **** 
 828:../../freeRtos/Source/tasks.c **** 					/* The base priority gets set whatever. */
 829:../../freeRtos/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 830:../../freeRtos/Source/tasks.c **** 				}
 831:../../freeRtos/Source/tasks.c **** 				#else
 832:../../freeRtos/Source/tasks.c **** 				{
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 834:../../freeRtos/Source/tasks.c **** 				}
 835:../../freeRtos/Source/tasks.c **** 				#endif
 836:../../freeRtos/Source/tasks.c **** 
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 838:../../freeRtos/Source/tasks.c **** 
 839:../../freeRtos/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 840:../../freeRtos/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 841:../../freeRtos/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 842:../../freeRtos/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 844:../../freeRtos/Source/tasks.c **** 				{
 845:../../freeRtos/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 846:../../freeRtos/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 847:../../freeRtos/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 850:../../freeRtos/Source/tasks.c **** 				}
 851:../../freeRtos/Source/tasks.c **** 
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 853:../../freeRtos/Source/tasks.c **** 				{
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 855:../../freeRtos/Source/tasks.c **** 				}
 856:../../freeRtos/Source/tasks.c **** 			}
 857:../../freeRtos/Source/tasks.c **** 		}
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 859:../../freeRtos/Source/tasks.c **** 	}
 860:../../freeRtos/Source/tasks.c **** 
 861:../../freeRtos/Source/tasks.c **** #endif
 862:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 863:../../freeRtos/Source/tasks.c **** 
 864:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 865:../../freeRtos/Source/tasks.c **** 
 866:../../freeRtos/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 867:../../freeRtos/Source/tasks.c **** 	{
 868:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 869:../../freeRtos/Source/tasks.c **** 
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 871:../../freeRtos/Source/tasks.c **** 		{
 872:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 873:../../freeRtos/Source/tasks.c **** 			suspended. */
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 875:../../freeRtos/Source/tasks.c **** 			{
 876:../../freeRtos/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 877:../../freeRtos/Source/tasks.c **** 			}
 878:../../freeRtos/Source/tasks.c **** 
 879:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 881:../../freeRtos/Source/tasks.c **** 
 882:../../freeRtos/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 883:../../freeRtos/Source/tasks.c **** 
 884:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 886:../../freeRtos/Source/tasks.c **** 
 887:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 889:../../freeRtos/Source/tasks.c **** 			{
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 891:../../freeRtos/Source/tasks.c **** 			}
 892:../../freeRtos/Source/tasks.c **** 
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894:../../freeRtos/Source/tasks.c **** 		}
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 896:../../freeRtos/Source/tasks.c **** 
 897:../../freeRtos/Source/tasks.c **** 		/* We may have just suspended the current task. */
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 899:../../freeRtos/Source/tasks.c **** 		{
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 901:../../freeRtos/Source/tasks.c **** 		}
 902:../../freeRtos/Source/tasks.c **** 	}
 903:../../freeRtos/Source/tasks.c **** 
 904:../../freeRtos/Source/tasks.c **** #endif
 905:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 906:../../freeRtos/Source/tasks.c **** 
 907:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 908:../../freeRtos/Source/tasks.c **** 
 909:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 910:../../freeRtos/Source/tasks.c **** 	{
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 912:../../freeRtos/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 913:../../freeRtos/Source/tasks.c **** 
 914:../../freeRtos/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 915:../../freeRtos/Source/tasks.c **** 		suspended list? */
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 917:../../freeRtos/Source/tasks.c **** 		{
 918:../../freeRtos/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 920:../../freeRtos/Source/tasks.c **** 			{
 921:../../freeRtos/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 922:../../freeRtos/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 923:../../freeRtos/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 924:../../freeRtos/Source/tasks.c **** 				specified. */
 925:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 926:../../freeRtos/Source/tasks.c **** 				{
 927:../../freeRtos/Source/tasks.c **** 					xReturn = pdTRUE;
 928:../../freeRtos/Source/tasks.c **** 				}
 929:../../freeRtos/Source/tasks.c **** 			}
 930:../../freeRtos/Source/tasks.c **** 		}
 931:../../freeRtos/Source/tasks.c **** 
 932:../../freeRtos/Source/tasks.c **** 		return xReturn;
 933:../../freeRtos/Source/tasks.c **** 	}
 934:../../freeRtos/Source/tasks.c **** 
 935:../../freeRtos/Source/tasks.c **** #endif
 936:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 937:../../freeRtos/Source/tasks.c **** 
 938:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 939:../../freeRtos/Source/tasks.c **** 
 940:../../freeRtos/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 941:../../freeRtos/Source/tasks.c **** 	{
 942:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 943:../../freeRtos/Source/tasks.c **** 
 944:../../freeRtos/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 945:../../freeRtos/Source/tasks.c **** 		it in the ready list. */
 946:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 947:../../freeRtos/Source/tasks.c **** 
 948:../../freeRtos/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 949:../../freeRtos/Source/tasks.c **** 		currently executing task. */
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 951:../../freeRtos/Source/tasks.c **** 		{
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 953:../../freeRtos/Source/tasks.c **** 			{
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 955:../../freeRtos/Source/tasks.c **** 				{
 956:../../freeRtos/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 957:../../freeRtos/Source/tasks.c **** 
 958:../../freeRtos/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 959:../../freeRtos/Source/tasks.c **** 					lists even if the scheduler is suspended. */
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 962:../../freeRtos/Source/tasks.c **** 
 963:../../freeRtos/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 965:../../freeRtos/Source/tasks.c **** 					{
 966:../../freeRtos/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 967:../../freeRtos/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 969:../../freeRtos/Source/tasks.c **** 					}
 970:../../freeRtos/Source/tasks.c **** 				}
 971:../../freeRtos/Source/tasks.c **** 			}
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 973:../../freeRtos/Source/tasks.c **** 		}
 974:../../freeRtos/Source/tasks.c **** 	}
 975:../../freeRtos/Source/tasks.c **** 
 976:../../freeRtos/Source/tasks.c **** #endif
 977:../../freeRtos/Source/tasks.c **** 
 978:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 979:../../freeRtos/Source/tasks.c **** 
 980:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 981:../../freeRtos/Source/tasks.c **** 
 982:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 983:../../freeRtos/Source/tasks.c **** 	{
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 985:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 986:../../freeRtos/Source/tasks.c **** 
 987:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 988:../../freeRtos/Source/tasks.c **** 
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 990:../../freeRtos/Source/tasks.c **** 		{
 991:../../freeRtos/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
 992:../../freeRtos/Source/tasks.c **** 
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 994:../../freeRtos/Source/tasks.c **** 			{
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 998:../../freeRtos/Source/tasks.c **** 			}
 999:../../freeRtos/Source/tasks.c **** 			else
1000:../../freeRtos/Source/tasks.c **** 			{
1001:../../freeRtos/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1002:../../freeRtos/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1003:../../freeRtos/Source/tasks.c **** 				yield will be performed if necessary. */
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1005:../../freeRtos/Source/tasks.c **** 			}
1006:../../freeRtos/Source/tasks.c **** 		}
1007:../../freeRtos/Source/tasks.c **** 
1008:../../freeRtos/Source/tasks.c **** 		return xYieldRequired;
1009:../../freeRtos/Source/tasks.c **** 	}
1010:../../freeRtos/Source/tasks.c **** 
1011:../../freeRtos/Source/tasks.c **** #endif
1012:../../freeRtos/Source/tasks.c **** 
1013:../../freeRtos/Source/tasks.c **** 
1014:../../freeRtos/Source/tasks.c **** 
1015:../../freeRtos/Source/tasks.c **** 
1016:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1017:../../freeRtos/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1018:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1019:../../freeRtos/Source/tasks.c **** 
1020:../../freeRtos/Source/tasks.c **** 
1021:../../freeRtos/Source/tasks.c **** void vTaskStartScheduler( void )
1022:../../freeRtos/Source/tasks.c **** {
1023:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1024:../../freeRtos/Source/tasks.c **** 
1025:../../freeRtos/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1027:../../freeRtos/Source/tasks.c **** 
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
1029:../../freeRtos/Source/tasks.c **** 	{
1030:../../freeRtos/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1031:../../freeRtos/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1032:../../freeRtos/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1033:../../freeRtos/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1034:../../freeRtos/Source/tasks.c **** 		starts to run.
1035:../../freeRtos/Source/tasks.c **** 
1036:../../freeRtos/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1037:../../freeRtos/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1039:../../freeRtos/Source/tasks.c **** 
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
1042:../../freeRtos/Source/tasks.c **** 
1043:../../freeRtos/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1044:../../freeRtos/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1045:../../freeRtos/Source/tasks.c **** 		the run time counter time base. */
1046:../../freeRtos/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1047:../../freeRtos/Source/tasks.c **** 
1048:../../freeRtos/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1049:../../freeRtos/Source/tasks.c **** 		portable interface. */
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
1051:../../freeRtos/Source/tasks.c **** 		{
1052:../../freeRtos/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1053:../../freeRtos/Source/tasks.c **** 			function will not return. */
1054:../../freeRtos/Source/tasks.c **** 		}
1055:../../freeRtos/Source/tasks.c **** 		else
1056:../../freeRtos/Source/tasks.c **** 		{
1057:../../freeRtos/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1058:../../freeRtos/Source/tasks.c **** 		}
1059:../../freeRtos/Source/tasks.c **** 	}
1060:../../freeRtos/Source/tasks.c **** }
1061:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1062:../../freeRtos/Source/tasks.c **** 
1063:../../freeRtos/Source/tasks.c **** void vTaskEndScheduler( void )
1064:../../freeRtos/Source/tasks.c **** {
1065:../../freeRtos/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1066:../../freeRtos/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1067:../../freeRtos/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
1071:../../freeRtos/Source/tasks.c **** }
1072:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1073:../../freeRtos/Source/tasks.c **** 
1074:../../freeRtos/Source/tasks.c **** void vTaskSuspendAll( void )
1075:../../freeRtos/Source/tasks.c **** {
1076:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1077:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
1079:../../freeRtos/Source/tasks.c **** }
1080:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1081:../../freeRtos/Source/tasks.c **** 
1082:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1083:../../freeRtos/Source/tasks.c **** {
1084:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1086:../../freeRtos/Source/tasks.c **** 
1087:../../freeRtos/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1088:../../freeRtos/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1089:../../freeRtos/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1090:../../freeRtos/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1091:../../freeRtos/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1093:../../freeRtos/Source/tasks.c **** 	{
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
1095:../../freeRtos/Source/tasks.c **** 
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1097:../../freeRtos/Source/tasks.c **** 		{
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1099:../../freeRtos/Source/tasks.c **** 			{
1100:../../freeRtos/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1101:../../freeRtos/Source/tasks.c **** 
1102:../../freeRtos/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1103:../../freeRtos/Source/tasks.c **** 				appropriate ready list. */
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1105:../../freeRtos/Source/tasks.c **** 				{
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1109:../../freeRtos/Source/tasks.c **** 
1110:../../freeRtos/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1111:../../freeRtos/Source/tasks.c **** 					the current task then we should yield. */
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1113:../../freeRtos/Source/tasks.c **** 					{
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1115:../../freeRtos/Source/tasks.c **** 					}
1116:../../freeRtos/Source/tasks.c **** 				}
1117:../../freeRtos/Source/tasks.c **** 
1118:../../freeRtos/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1119:../../freeRtos/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1120:../../freeRtos/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1122:../../freeRtos/Source/tasks.c **** 				{
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1124:../../freeRtos/Source/tasks.c **** 					{
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
1127:../../freeRtos/Source/tasks.c **** 					}
1128:../../freeRtos/Source/tasks.c **** 
1129:../../freeRtos/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1130:../../freeRtos/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1131:../../freeRtos/Source/tasks.c **** 					the task actually running. */
1132:../../freeRtos/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1133:../../freeRtos/Source/tasks.c **** 					{
1134:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1135:../../freeRtos/Source/tasks.c **** 					}
1136:../../freeRtos/Source/tasks.c **** 					#endif
1137:../../freeRtos/Source/tasks.c **** 				}
1138:../../freeRtos/Source/tasks.c **** 
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1140:../../freeRtos/Source/tasks.c **** 				{
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
1144:../../freeRtos/Source/tasks.c **** 				}
1145:../../freeRtos/Source/tasks.c **** 			}
1146:../../freeRtos/Source/tasks.c **** 		}
1147:../../freeRtos/Source/tasks.c **** 	}
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1149:../../freeRtos/Source/tasks.c **** 
1150:../../freeRtos/Source/tasks.c **** 	return xAlreadyYielded;
1151:../../freeRtos/Source/tasks.c **** }
1152:../../freeRtos/Source/tasks.c **** 
1153:../../freeRtos/Source/tasks.c **** 
1154:../../freeRtos/Source/tasks.c **** 
1155:../../freeRtos/Source/tasks.c **** 
1156:../../freeRtos/Source/tasks.c **** 
1157:../../freeRtos/Source/tasks.c **** 
1158:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1159:../../freeRtos/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1160:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1161:../../freeRtos/Source/tasks.c **** 
1162:../../freeRtos/Source/tasks.c **** 
1163:../../freeRtos/Source/tasks.c **** 
1164:../../freeRtos/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1165:../../freeRtos/Source/tasks.c **** {
1166:../../freeRtos/Source/tasks.c **** portTickType xTicks;
1167:../../freeRtos/Source/tasks.c **** 
1168:../../freeRtos/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1170:../../freeRtos/Source/tasks.c **** 	{
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
1172:../../freeRtos/Source/tasks.c **** 	}
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1174:../../freeRtos/Source/tasks.c **** 
1175:../../freeRtos/Source/tasks.c **** 	return xTicks;
1176:../../freeRtos/Source/tasks.c **** }
1177:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1178:../../freeRtos/Source/tasks.c **** 
1179:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1180:../../freeRtos/Source/tasks.c **** {
1181:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1182:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1184:../../freeRtos/Source/tasks.c **** }
1185:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1186:../../freeRtos/Source/tasks.c **** 
1187:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1188:../../freeRtos/Source/tasks.c **** 
1189:../../freeRtos/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1190:../../freeRtos/Source/tasks.c **** 	{
1191:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1192:../../freeRtos/Source/tasks.c **** 
1193:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1194:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1195:../../freeRtos/Source/tasks.c **** 
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1197:../../freeRtos/Source/tasks.c **** 		{
1198:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1199:../../freeRtos/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1200:../../freeRtos/Source/tasks.c **** 
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1203:../../freeRtos/Source/tasks.c **** 
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1205:../../freeRtos/Source/tasks.c **** 
1206:../../freeRtos/Source/tasks.c **** 			do
1207:../../freeRtos/Source/tasks.c **** 			{
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1209:../../freeRtos/Source/tasks.c **** 
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1211:../../freeRtos/Source/tasks.c **** 				{
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1213:../../freeRtos/Source/tasks.c **** 				}
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1215:../../freeRtos/Source/tasks.c **** 
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1217:../../freeRtos/Source/tasks.c **** 			{
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1219:../../freeRtos/Source/tasks.c **** 			}
1220:../../freeRtos/Source/tasks.c **** 
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1222:../../freeRtos/Source/tasks.c **** 			{
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1224:../../freeRtos/Source/tasks.c **** 			}
1225:../../freeRtos/Source/tasks.c **** 
1226:../../freeRtos/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1227:../../freeRtos/Source/tasks.c **** 			{
1228:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1229:../../freeRtos/Source/tasks.c **** 				{
1230:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1231:../../freeRtos/Source/tasks.c **** 				}
1232:../../freeRtos/Source/tasks.c **** 			}
1233:../../freeRtos/Source/tasks.c **** 			#endif
1234:../../freeRtos/Source/tasks.c **** 
1235:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1236:../../freeRtos/Source/tasks.c **** 			{
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1238:../../freeRtos/Source/tasks.c **** 				{
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1240:../../freeRtos/Source/tasks.c **** 				}
1241:../../freeRtos/Source/tasks.c **** 			}
1242:../../freeRtos/Source/tasks.c **** 			#endif
1243:../../freeRtos/Source/tasks.c **** 		}
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1245:../../freeRtos/Source/tasks.c **** 	}
1246:../../freeRtos/Source/tasks.c **** 
1247:../../freeRtos/Source/tasks.c **** #endif
1248:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1249:../../freeRtos/Source/tasks.c **** 
1250:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1251:../../freeRtos/Source/tasks.c **** 
1252:../../freeRtos/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1253:../../freeRtos/Source/tasks.c **** 	{
1254:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1255:../../freeRtos/Source/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1256:../../freeRtos/Source/tasks.c **** 
1257:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1258:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1259:../../freeRtos/Source/tasks.c **** 
1260:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1261:../../freeRtos/Source/tasks.c **** 		{
1262:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1263:../../freeRtos/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1264:../../freeRtos/Source/tasks.c **** 			buffer. */
1265:../../freeRtos/Source/tasks.c **** 
1266:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1267:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1268:../../freeRtos/Source/tasks.c **** 
1269:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1270:../../freeRtos/Source/tasks.c **** 
1271:../../freeRtos/Source/tasks.c **** 			do
1272:../../freeRtos/Source/tasks.c **** 			{
1273:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1274:../../freeRtos/Source/tasks.c **** 
1275:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1276:../../freeRtos/Source/tasks.c **** 				{
1277:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1278:../../freeRtos/Source/tasks.c **** 				}
1279:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1280:../../freeRtos/Source/tasks.c **** 
1281:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1282:../../freeRtos/Source/tasks.c **** 			{
1283:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1284:../../freeRtos/Source/tasks.c **** 			}
1285:../../freeRtos/Source/tasks.c **** 
1286:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1287:../../freeRtos/Source/tasks.c **** 			{
1288:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1289:../../freeRtos/Source/tasks.c **** 			}
1290:../../freeRtos/Source/tasks.c **** 
1291:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1292:../../freeRtos/Source/tasks.c **** 			{
1293:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1294:../../freeRtos/Source/tasks.c **** 				{
1295:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1296:../../freeRtos/Source/tasks.c **** 				}
1297:../../freeRtos/Source/tasks.c **** 			}
1298:../../freeRtos/Source/tasks.c **** 			#endif
1299:../../freeRtos/Source/tasks.c **** 
1300:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1301:../../freeRtos/Source/tasks.c **** 			{
1302:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1303:../../freeRtos/Source/tasks.c **** 				{
1304:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1305:../../freeRtos/Source/tasks.c **** 				}
1306:../../freeRtos/Source/tasks.c **** 			}
1307:../../freeRtos/Source/tasks.c **** 			#endif
1308:../../freeRtos/Source/tasks.c **** 		}
1309:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1310:../../freeRtos/Source/tasks.c **** 	}
1311:../../freeRtos/Source/tasks.c **** 
1312:../../freeRtos/Source/tasks.c **** #endif
1313:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1314:../../freeRtos/Source/tasks.c **** 
1315:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1316:../../freeRtos/Source/tasks.c **** 
1317:../../freeRtos/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1318:../../freeRtos/Source/tasks.c **** 	{
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1320:../../freeRtos/Source/tasks.c **** 		{
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
1325:../../freeRtos/Source/tasks.c **** 		}
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1327:../../freeRtos/Source/tasks.c **** 	}
1328:../../freeRtos/Source/tasks.c **** 
1329:../../freeRtos/Source/tasks.c **** #endif
1330:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1331:../../freeRtos/Source/tasks.c **** 
1332:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1333:../../freeRtos/Source/tasks.c **** 
1334:../../freeRtos/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1335:../../freeRtos/Source/tasks.c **** 	{
1336:../../freeRtos/Source/tasks.c **** 	unsigned long ulBufferLength;
1337:../../freeRtos/Source/tasks.c **** 
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1341:../../freeRtos/Source/tasks.c **** 
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1343:../../freeRtos/Source/tasks.c **** 
1344:../../freeRtos/Source/tasks.c **** 		return ulBufferLength;
1345:../../freeRtos/Source/tasks.c **** 	}
1346:../../freeRtos/Source/tasks.c **** 
1347:../../freeRtos/Source/tasks.c **** #endif
1348:../../freeRtos/Source/tasks.c **** 
1349:../../freeRtos/Source/tasks.c **** 
1350:../../freeRtos/Source/tasks.c **** 
1351:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1352:../../freeRtos/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1353:../../freeRtos/Source/tasks.c ****  * documented in task.h
1354:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1355:../../freeRtos/Source/tasks.c **** 
1356:../../freeRtos/Source/tasks.c **** 
1357:../../freeRtos/Source/tasks.c **** void vTaskIncrementTick( void )
1358:../../freeRtos/Source/tasks.c **** {
1359:../../freeRtos/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1360:../../freeRtos/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1361:../../freeRtos/Source/tasks.c **** 	tasks to be unblocked. */
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1363:../../freeRtos/Source/tasks.c **** 	{
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
1366:../../freeRtos/Source/tasks.c **** 		{
1367:../../freeRtos/Source/tasks.c **** 			xList *pxTemp;
1368:../../freeRtos/Source/tasks.c **** 
1369:../../freeRtos/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1370:../../freeRtos/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1371:../../freeRtos/Source/tasks.c **** 			an error! */
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
1376:../../freeRtos/Source/tasks.c **** 		}
1377:../../freeRtos/Source/tasks.c **** 
1378:../../freeRtos/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
1380:../../freeRtos/Source/tasks.c **** 	}
1381:../../freeRtos/Source/tasks.c **** 	else
1382:../../freeRtos/Source/tasks.c **** 	{
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
1384:../../freeRtos/Source/tasks.c **** 
1385:../../freeRtos/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1386:../../freeRtos/Source/tasks.c **** 		scheduler is locked. */
1387:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1388:../../freeRtos/Source/tasks.c **** 		{
1389:../../freeRtos/Source/tasks.c **** 			extern void vApplicationTickHook( void );
1390:../../freeRtos/Source/tasks.c **** 
1391:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1392:../../freeRtos/Source/tasks.c **** 		}
1393:../../freeRtos/Source/tasks.c **** 		#endif
1394:../../freeRtos/Source/tasks.c **** 	}
1395:../../freeRtos/Source/tasks.c **** 
1396:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1397:../../freeRtos/Source/tasks.c **** 	{
1398:../../freeRtos/Source/tasks.c **** 		extern void vApplicationTickHook( void );
1399:../../freeRtos/Source/tasks.c **** 
1400:../../freeRtos/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1401:../../freeRtos/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1402:../../freeRtos/Source/tasks.c **** 		if( uxMissedTicks == 0 )
1403:../../freeRtos/Source/tasks.c **** 		{
1404:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1405:../../freeRtos/Source/tasks.c **** 		}
1406:../../freeRtos/Source/tasks.c **** 	}
1407:../../freeRtos/Source/tasks.c **** 	#endif
1408:../../freeRtos/Source/tasks.c **** 
1409:../../freeRtos/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1410:../../freeRtos/Source/tasks.c **** }
1411:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1412:../../freeRtos/Source/tasks.c **** 
1413:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1414:../../freeRtos/Source/tasks.c **** 
1415:../../freeRtos/Source/tasks.c **** 	void vTaskCleanUpResources( void )
1416:../../freeRtos/Source/tasks.c **** 	{
1417:../../freeRtos/Source/tasks.c **** 	unsigned short usQueue;
1418:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxTCB;
1419:../../freeRtos/Source/tasks.c **** 
1420:../../freeRtos/Source/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1421:../../freeRtos/Source/tasks.c **** 
1422:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1423:../../freeRtos/Source/tasks.c **** 		do
1424:../../freeRtos/Source/tasks.c **** 		{
1425:../../freeRtos/Source/tasks.c **** 			usQueue--;
1426:../../freeRtos/Source/tasks.c **** 
1427:../../freeRtos/Source/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1428:../../freeRtos/Source/tasks.c **** 			{
1429:../../freeRtos/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1430:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1431:../../freeRtos/Source/tasks.c **** 
1432:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1433:../../freeRtos/Source/tasks.c **** 			}
1434:../../freeRtos/Source/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1435:../../freeRtos/Source/tasks.c **** 
1436:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1437:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1438:../../freeRtos/Source/tasks.c **** 		{
1439:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1440:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1441:../../freeRtos/Source/tasks.c **** 
1442:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1443:../../freeRtos/Source/tasks.c **** 		}
1444:../../freeRtos/Source/tasks.c **** 
1445:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1446:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1447:../../freeRtos/Source/tasks.c **** 		{
1448:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1449:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1450:../../freeRtos/Source/tasks.c **** 
1451:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1452:../../freeRtos/Source/tasks.c **** 		}
1453:../../freeRtos/Source/tasks.c **** 
1454:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1455:../../freeRtos/Source/tasks.c **** 		{
1456:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1457:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1458:../../freeRtos/Source/tasks.c **** 
1459:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1460:../../freeRtos/Source/tasks.c **** 		}
1461:../../freeRtos/Source/tasks.c **** 	}
1462:../../freeRtos/Source/tasks.c **** 
1463:../../freeRtos/Source/tasks.c **** #endif
1464:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1465:../../freeRtos/Source/tasks.c **** 
1466:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1467:../../freeRtos/Source/tasks.c **** 
1468:../../freeRtos/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1469:../../freeRtos/Source/tasks.c **** 	{
1470:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1471:../../freeRtos/Source/tasks.c **** 
1472:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1473:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1474:../../freeRtos/Source/tasks.c **** 		{
1475:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1476:../../freeRtos/Source/tasks.c **** 		}
1477:../../freeRtos/Source/tasks.c **** 		else
1478:../../freeRtos/Source/tasks.c **** 		{
1479:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1480:../../freeRtos/Source/tasks.c **** 		}
1481:../../freeRtos/Source/tasks.c **** 
1482:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1483:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1484:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1485:../../freeRtos/Source/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1486:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1487:../../freeRtos/Source/tasks.c **** 	}
1488:../../freeRtos/Source/tasks.c **** 
1489:../../freeRtos/Source/tasks.c **** #endif
1490:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1491:../../freeRtos/Source/tasks.c **** 
1492:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1493:../../freeRtos/Source/tasks.c **** 
1494:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1495:../../freeRtos/Source/tasks.c **** 	{
1496:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1497:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1498:../../freeRtos/Source/tasks.c **** 
1499:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1500:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1501:../../freeRtos/Source/tasks.c **** 		{
1502:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1503:../../freeRtos/Source/tasks.c **** 		}
1504:../../freeRtos/Source/tasks.c **** 		else
1505:../../freeRtos/Source/tasks.c **** 		{
1506:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1507:../../freeRtos/Source/tasks.c **** 		}
1508:../../freeRtos/Source/tasks.c **** 
1509:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1510:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1511:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1512:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1513:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1514:../../freeRtos/Source/tasks.c **** 
1515:../../freeRtos/Source/tasks.c **** 		return xReturn;
1516:../../freeRtos/Source/tasks.c **** 	}
1517:../../freeRtos/Source/tasks.c **** 
1518:../../freeRtos/Source/tasks.c **** #endif
1519:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1520:../../freeRtos/Source/tasks.c **** 
1521:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1522:../../freeRtos/Source/tasks.c **** 
1523:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1524:../../freeRtos/Source/tasks.c **** 	{
1525:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1526:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn;
1527:../../freeRtos/Source/tasks.c **** 
1528:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1529:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1530:../../freeRtos/Source/tasks.c **** 		{
1531:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1532:../../freeRtos/Source/tasks.c **** 		}
1533:../../freeRtos/Source/tasks.c **** 		else
1534:../../freeRtos/Source/tasks.c **** 		{
1535:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1536:../../freeRtos/Source/tasks.c **** 		}
1537:../../freeRtos/Source/tasks.c **** 
1538:../../freeRtos/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1539:../../freeRtos/Source/tasks.c **** 		{
1540:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1541:../../freeRtos/Source/tasks.c **** 		}
1542:../../freeRtos/Source/tasks.c **** 		else
1543:../../freeRtos/Source/tasks.c **** 		{
1544:../../freeRtos/Source/tasks.c **** 			xReturn = pdFAIL;
1545:../../freeRtos/Source/tasks.c **** 		}
1546:../../freeRtos/Source/tasks.c **** 
1547:../../freeRtos/Source/tasks.c **** 		return xReturn;
1548:../../freeRtos/Source/tasks.c **** 	}
1549:../../freeRtos/Source/tasks.c **** 
1550:../../freeRtos/Source/tasks.c **** #endif
1551:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1552:../../freeRtos/Source/tasks.c **** 
1553:../../freeRtos/Source/tasks.c **** void vTaskSwitchContext( void )
1554:../../freeRtos/Source/tasks.c **** {
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1556:../../freeRtos/Source/tasks.c **** 	{
1557:../../freeRtos/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1558:../../freeRtos/Source/tasks.c **** 		switch. */
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
1560:../../freeRtos/Source/tasks.c **** 		return;
1561:../../freeRtos/Source/tasks.c **** 	}
1562:../../freeRtos/Source/tasks.c **** 
1563:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_OUT();
1564:../../freeRtos/Source/tasks.c **** 
1565:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1566:../../freeRtos/Source/tasks.c **** 	{
1567:../../freeRtos/Source/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1568:../../freeRtos/Source/tasks.c **** 
1569:../../freeRtos/Source/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1570:../../freeRtos/Source/tasks.c **** 			time so far.  The time the task started running was stored in
1571:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1572:../../freeRtos/Source/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1573:../../freeRtos/Source/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1574:../../freeRtos/Source/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1575:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1576:../../freeRtos/Source/tasks.c **** 	}
1577:../../freeRtos/Source/tasks.c **** 	#endif
1578:../../freeRtos/Source/tasks.c **** 
1579:../../freeRtos/Source/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1580:../../freeRtos/Source/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1581:../../freeRtos/Source/tasks.c **** 
1582:../../freeRtos/Source/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1584:../../freeRtos/Source/tasks.c **** 	{
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
1586:../../freeRtos/Source/tasks.c **** 	}
1587:../../freeRtos/Source/tasks.c **** 
1588:../../freeRtos/Source/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1589:../../freeRtos/Source/tasks.c **** 	same priority get an equal share of the processor time. */
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1591:../../freeRtos/Source/tasks.c **** 
1592:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_IN();
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
1594:../../freeRtos/Source/tasks.c **** }
1595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1596:../../freeRtos/Source/tasks.c **** 
1597:../../freeRtos/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1598:../../freeRtos/Source/tasks.c **** {
1599:../../freeRtos/Source/tasks.c **** portTickType xTimeToWake;
1600:../../freeRtos/Source/tasks.c **** 
1601:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1602:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1603:../../freeRtos/Source/tasks.c **** 
1604:../../freeRtos/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1605:../../freeRtos/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1606:../../freeRtos/Source/tasks.c **** 	is the first to be woken by the event. */
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1608:../../freeRtos/Source/tasks.c **** 
1609:../../freeRtos/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1610:../../freeRtos/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1611:../../freeRtos/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1613:../../freeRtos/Source/tasks.c **** 
1614:../../freeRtos/Source/tasks.c **** 
1615:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1616:../../freeRtos/Source/tasks.c **** 	{
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1618:../../freeRtos/Source/tasks.c **** 		{
1619:../../freeRtos/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1620:../../freeRtos/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1621:../../freeRtos/Source/tasks.c **** 			indefinitely. */
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1623:../../freeRtos/Source/tasks.c **** 		}
1624:../../freeRtos/Source/tasks.c **** 		else
1625:../../freeRtos/Source/tasks.c **** 		{
1626:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1627:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1629:../../freeRtos/Source/tasks.c **** 
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1631:../../freeRtos/Source/tasks.c **** 
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1633:../../freeRtos/Source/tasks.c **** 			{
1634:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1636:../../freeRtos/Source/tasks.c **** 			}
1637:../../freeRtos/Source/tasks.c **** 			else
1638:../../freeRtos/Source/tasks.c **** 			{
1639:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1641:../../freeRtos/Source/tasks.c **** 			}
1642:../../freeRtos/Source/tasks.c **** 		}
1643:../../freeRtos/Source/tasks.c **** 	}
1644:../../freeRtos/Source/tasks.c **** 	#else
1645:../../freeRtos/Source/tasks.c **** 	{
1646:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1647:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1648:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1649:../../freeRtos/Source/tasks.c **** 
1650:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1651:../../freeRtos/Source/tasks.c **** 
1652:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1653:../../freeRtos/Source/tasks.c **** 			{
1654:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1655:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1656:../../freeRtos/Source/tasks.c **** 			}
1657:../../freeRtos/Source/tasks.c **** 			else
1658:../../freeRtos/Source/tasks.c **** 			{
1659:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1660:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1661:../../freeRtos/Source/tasks.c **** 			}
1662:../../freeRtos/Source/tasks.c **** 	}
1663:../../freeRtos/Source/tasks.c **** 	#endif
1664:../../freeRtos/Source/tasks.c **** }
1665:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1666:../../freeRtos/Source/tasks.c **** 
1667:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1668:../../freeRtos/Source/tasks.c **** {
1669:../../freeRtos/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1670:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1671:../../freeRtos/Source/tasks.c **** 
1672:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1673:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1674:../../freeRtos/Source/tasks.c **** 
1675:../../freeRtos/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1676:../../freeRtos/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1677:../../freeRtos/Source/tasks.c **** 	it to the ready list.
1678:../../freeRtos/Source/tasks.c **** 
1679:../../freeRtos/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1680:../../freeRtos/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1681:../../freeRtos/Source/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1684:../../freeRtos/Source/tasks.c **** 
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1686:../../freeRtos/Source/tasks.c **** 	{
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1689:../../freeRtos/Source/tasks.c **** 	}
1690:../../freeRtos/Source/tasks.c **** 	else
1691:../../freeRtos/Source/tasks.c **** 	{
1692:../../freeRtos/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1693:../../freeRtos/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1695:../../freeRtos/Source/tasks.c **** 	}
1696:../../freeRtos/Source/tasks.c **** 
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1698:../../freeRtos/Source/tasks.c **** 	{
1699:../../freeRtos/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1700:../../freeRtos/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1701:../../freeRtos/Source/tasks.c **** 		the calling task to know if it should force a context
1702:../../freeRtos/Source/tasks.c **** 		switch now. */
1703:../../freeRtos/Source/tasks.c **** 		xReturn = pdTRUE;
1704:../../freeRtos/Source/tasks.c **** 	}
1705:../../freeRtos/Source/tasks.c **** 	else
1706:../../freeRtos/Source/tasks.c **** 	{
1707:../../freeRtos/Source/tasks.c **** 		xReturn = pdFALSE;
1708:../../freeRtos/Source/tasks.c **** 	}
1709:../../freeRtos/Source/tasks.c **** 
1710:../../freeRtos/Source/tasks.c **** 	return xReturn;
1711:../../freeRtos/Source/tasks.c **** }
1712:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1713:../../freeRtos/Source/tasks.c **** 
1714:../../freeRtos/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1715:../../freeRtos/Source/tasks.c **** {
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1718:../../freeRtos/Source/tasks.c **** }
1719:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1720:../../freeRtos/Source/tasks.c **** 
1721:../../freeRtos/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1722:../../freeRtos/Source/tasks.c **** {
1723:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1724:../../freeRtos/Source/tasks.c **** 
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1726:../../freeRtos/Source/tasks.c **** 	{
1727:../../freeRtos/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1728:../../freeRtos/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1729:../../freeRtos/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1730:../../freeRtos/Source/tasks.c **** 			therefore never time out. */
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1732:../../freeRtos/Source/tasks.c **** 			{
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
1734:../../freeRtos/Source/tasks.c **** 			}
1735:../../freeRtos/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1736:../../freeRtos/Source/tasks.c **** 		#endif
1737:../../freeRtos/Source/tasks.c **** 
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1739:../../freeRtos/Source/tasks.c **** 		{
1740:../../freeRtos/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1741:../../freeRtos/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1742:../../freeRtos/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1743:../../freeRtos/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1744:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1745:../../freeRtos/Source/tasks.c **** 		}
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1747:../../freeRtos/Source/tasks.c **** 		{
1748:../../freeRtos/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1750:../../freeRtos/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1751:../../freeRtos/Source/tasks.c **** 			xReturn = pdFALSE;
1752:../../freeRtos/Source/tasks.c **** 		}
1753:../../freeRtos/Source/tasks.c **** 		else
1754:../../freeRtos/Source/tasks.c **** 		{
1755:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1756:../../freeRtos/Source/tasks.c **** 		}
1757:../../freeRtos/Source/tasks.c **** 	}
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1759:../../freeRtos/Source/tasks.c **** 
1760:../../freeRtos/Source/tasks.c **** 	return xReturn;
1761:../../freeRtos/Source/tasks.c **** }
1762:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1763:../../freeRtos/Source/tasks.c **** 
1764:../../freeRtos/Source/tasks.c **** void vTaskMissedYield( void )
1765:../../freeRtos/Source/tasks.c **** {
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
1767:../../freeRtos/Source/tasks.c **** }
1768:../../freeRtos/Source/tasks.c **** 
1769:../../freeRtos/Source/tasks.c **** /*
1770:../../freeRtos/Source/tasks.c ****  * -----------------------------------------------------------
1771:../../freeRtos/Source/tasks.c ****  * The Idle task.
1772:../../freeRtos/Source/tasks.c ****  * ----------------------------------------------------------
1773:../../freeRtos/Source/tasks.c ****  *
1774:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1775:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1776:../../freeRtos/Source/tasks.c ****  *
1777:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1778:../../freeRtos/Source/tasks.c ****  *
1779:../../freeRtos/Source/tasks.c ****  */
1780:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1781:../../freeRtos/Source/tasks.c **** {
 160               	.LM0:
 161               	.LFBB1:
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166               	.L2:
1782:../../freeRtos/Source/tasks.c **** 	/* Stop warnings. */
1783:../../freeRtos/Source/tasks.c **** 	( void ) pvParameters;
1784:../../freeRtos/Source/tasks.c **** 
1785:../../freeRtos/Source/tasks.c **** 	for( ;; )
1786:../../freeRtos/Source/tasks.c **** 	{
1787:../../freeRtos/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1788:../../freeRtos/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1789:../../freeRtos/Source/tasks.c **** 
1790:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1791:../../freeRtos/Source/tasks.c **** 		{
1792:../../freeRtos/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1793:../../freeRtos/Source/tasks.c **** 			see if any other task has become available.  If we are using
1794:../../freeRtos/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1795:../../freeRtos/Source/tasks.c **** 			will automatically get the processor anyway. */
1796:../../freeRtos/Source/tasks.c **** 			taskYIELD();
 168               	.LM1:
 169 0000 0E94 0000 		call vPortYield
 170 0004 00C0      		rjmp .L2
 172               	.Lscope1:
 174               		.stabd	78,0,0
 175               		.section	.rodata.str1.1,"aMS",@progbits,1
 176               	.LC0:
 177 0000 2573 0909 		.string	"%s\t\t%c\t%u\t%u\t%u\r\n"
 177      2563 0925 
 177      7509 2575 
 177      0925 750D 
 177      0A00 
 178               		.text
 184               	prvListTaskWithinSingleList:
 185               		.stabd	46,0,0
1797:../../freeRtos/Source/tasks.c **** 		}
1798:../../freeRtos/Source/tasks.c **** 		#endif
1799:../../freeRtos/Source/tasks.c **** 
1800:../../freeRtos/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1801:../../freeRtos/Source/tasks.c **** 		{
1802:../../freeRtos/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1803:../../freeRtos/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1804:../../freeRtos/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1805:../../freeRtos/Source/tasks.c **** 			timeslice.
1806:../../freeRtos/Source/tasks.c **** 
1807:../../freeRtos/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1808:../../freeRtos/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1809:../../freeRtos/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1810:../../freeRtos/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1811:../../freeRtos/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1812:../../freeRtos/Source/tasks.c **** 			{
1813:../../freeRtos/Source/tasks.c **** 				taskYIELD();
1814:../../freeRtos/Source/tasks.c **** 			}
1815:../../freeRtos/Source/tasks.c **** 		}
1816:../../freeRtos/Source/tasks.c **** 		#endif
1817:../../freeRtos/Source/tasks.c **** 
1818:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1819:../../freeRtos/Source/tasks.c **** 		{
1820:../../freeRtos/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1821:../../freeRtos/Source/tasks.c **** 
1822:../../freeRtos/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1823:../../freeRtos/Source/tasks.c **** 			allows the application designer to add background functionality
1824:../../freeRtos/Source/tasks.c **** 			without the overhead of a separate task.
1825:../../freeRtos/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1826:../../freeRtos/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1827:../../freeRtos/Source/tasks.c **** 			vApplicationIdleHook();
1828:../../freeRtos/Source/tasks.c **** 		}
1829:../../freeRtos/Source/tasks.c **** 		#endif
1830:../../freeRtos/Source/tasks.c **** 	}
1831:../../freeRtos/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1832:../../freeRtos/Source/tasks.c **** 
1833:../../freeRtos/Source/tasks.c **** 
1834:../../freeRtos/Source/tasks.c **** 
1835:../../freeRtos/Source/tasks.c **** 
1836:../../freeRtos/Source/tasks.c **** 
1837:../../freeRtos/Source/tasks.c **** 
1838:../../freeRtos/Source/tasks.c **** 
1839:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1840:../../freeRtos/Source/tasks.c ****  * File private functions documented at the top of the file.
1841:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1842:../../freeRtos/Source/tasks.c **** 
1843:../../freeRtos/Source/tasks.c **** 
1844:../../freeRtos/Source/tasks.c **** 
1845:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1846:../../freeRtos/Source/tasks.c **** {
1847:../../freeRtos/Source/tasks.c **** 	/* Store the function name in the TCB. */
1848:../../freeRtos/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1849:../../freeRtos/Source/tasks.c **** 	{
1850:../../freeRtos/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1852:../../freeRtos/Source/tasks.c **** 	}
1853:../../freeRtos/Source/tasks.c **** 	#endif
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1855:../../freeRtos/Source/tasks.c **** 
1856:../../freeRtos/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1857:../../freeRtos/Source/tasks.c **** 	remove the privilege bit if one is present. */
1858:../../freeRtos/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1859:../../freeRtos/Source/tasks.c **** 	{
1860:../../freeRtos/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
1861:../../freeRtos/Source/tasks.c **** 	}
1862:../../freeRtos/Source/tasks.c **** 
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1864:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1865:../../freeRtos/Source/tasks.c **** 	{
1866:../../freeRtos/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1867:../../freeRtos/Source/tasks.c **** 	}
1868:../../freeRtos/Source/tasks.c **** 	#endif
1869:../../freeRtos/Source/tasks.c **** 
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1872:../../freeRtos/Source/tasks.c **** 
1873:../../freeRtos/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1874:../../freeRtos/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1876:../../freeRtos/Source/tasks.c **** 
1877:../../freeRtos/Source/tasks.c **** 	/* Event lists are always in priority order. */
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1880:../../freeRtos/Source/tasks.c **** 
1881:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1882:../../freeRtos/Source/tasks.c **** 	{
1883:../../freeRtos/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1884:../../freeRtos/Source/tasks.c **** 	}
1885:../../freeRtos/Source/tasks.c **** 	#endif
1886:../../freeRtos/Source/tasks.c **** 
1887:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1888:../../freeRtos/Source/tasks.c **** 	{
1889:../../freeRtos/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1890:../../freeRtos/Source/tasks.c **** 	}
1891:../../freeRtos/Source/tasks.c **** 	#endif
1892:../../freeRtos/Source/tasks.c **** 
1893:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1894:../../freeRtos/Source/tasks.c **** 	{
1895:../../freeRtos/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1896:../../freeRtos/Source/tasks.c **** 	}
1897:../../freeRtos/Source/tasks.c **** 	#endif
1898:../../freeRtos/Source/tasks.c **** 
1899:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1900:../../freeRtos/Source/tasks.c **** 	{
1901:../../freeRtos/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1902:../../freeRtos/Source/tasks.c **** 	}
1903:../../freeRtos/Source/tasks.c **** 	#else
1904:../../freeRtos/Source/tasks.c **** 	{
1905:../../freeRtos/Source/tasks.c **** 		( void ) xRegions;
1906:../../freeRtos/Source/tasks.c **** 		( void ) usStackDepth;
1907:../../freeRtos/Source/tasks.c **** 	}
1908:../../freeRtos/Source/tasks.c **** 	#endif
1909:../../freeRtos/Source/tasks.c **** }
1910:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1911:../../freeRtos/Source/tasks.c **** 
1912:../../freeRtos/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1913:../../freeRtos/Source/tasks.c **** 
1914:../../freeRtos/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1915:../../freeRtos/Source/tasks.c **** 	{
1916:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
1917:../../freeRtos/Source/tasks.c **** 	
1918:../../freeRtos/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1919:../../freeRtos/Source/tasks.c **** 		{
1920:../../freeRtos/Source/tasks.c **** 			xTaskToModify = NULL;
1921:../../freeRtos/Source/tasks.c **** 		}
1922:../../freeRtos/Source/tasks.c **** 
1923:../../freeRtos/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1924:../../freeRtos/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1925:../../freeRtos/Source/tasks.c **** 
1926:../../freeRtos/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1927:../../freeRtos/Source/tasks.c **** 	}
1928:../../freeRtos/Source/tasks.c **** 	/*-----------------------------------------------------------*/
1929:../../freeRtos/Source/tasks.c **** #endif
1930:../../freeRtos/Source/tasks.c **** 
1931:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void )
1932:../../freeRtos/Source/tasks.c **** {
1933:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
1934:../../freeRtos/Source/tasks.c **** 
1935:../../freeRtos/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1936:../../freeRtos/Source/tasks.c **** 	{
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1938:../../freeRtos/Source/tasks.c **** 	}
1939:../../freeRtos/Source/tasks.c **** 
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1943:../../freeRtos/Source/tasks.c **** 
1944:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1945:../../freeRtos/Source/tasks.c **** 	{
1946:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1947:../../freeRtos/Source/tasks.c **** 	}
1948:../../freeRtos/Source/tasks.c **** 	#endif
1949:../../freeRtos/Source/tasks.c **** 
1950:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1951:../../freeRtos/Source/tasks.c **** 	{
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1953:../../freeRtos/Source/tasks.c **** 	}
1954:../../freeRtos/Source/tasks.c **** 	#endif
1955:../../freeRtos/Source/tasks.c **** 
1956:../../freeRtos/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1957:../../freeRtos/Source/tasks.c **** 	using list2. */
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1960:../../freeRtos/Source/tasks.c **** }
1961:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1962:../../freeRtos/Source/tasks.c **** 
1963:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1964:../../freeRtos/Source/tasks.c **** {
1965:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1966:../../freeRtos/Source/tasks.c **** 	{
1967:../../freeRtos/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1968:../../freeRtos/Source/tasks.c **** 
1969:../../freeRtos/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
1970:../../freeRtos/Source/tasks.c **** 		too often in the idle task. */
1971:../../freeRtos/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
1972:../../freeRtos/Source/tasks.c **** 		{
1973:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
1974:../../freeRtos/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
1975:../../freeRtos/Source/tasks.c **** 			xTaskResumeAll();
1976:../../freeRtos/Source/tasks.c **** 
1977:../../freeRtos/Source/tasks.c **** 			if( !xListIsEmpty )
1978:../../freeRtos/Source/tasks.c **** 			{
1979:../../freeRtos/Source/tasks.c **** 				tskTCB *pxTCB;
1980:../../freeRtos/Source/tasks.c **** 
1981:../../freeRtos/Source/tasks.c **** 				portENTER_CRITICAL();
1982:../../freeRtos/Source/tasks.c **** 				{
1983:../../freeRtos/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
1984:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1985:../../freeRtos/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
1986:../../freeRtos/Source/tasks.c **** 					--uxTasksDeleted;
1987:../../freeRtos/Source/tasks.c **** 				}
1988:../../freeRtos/Source/tasks.c **** 				portEXIT_CRITICAL();
1989:../../freeRtos/Source/tasks.c **** 
1990:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1991:../../freeRtos/Source/tasks.c **** 			}
1992:../../freeRtos/Source/tasks.c **** 		}
1993:../../freeRtos/Source/tasks.c **** 	}
1994:../../freeRtos/Source/tasks.c **** 	#endif
1995:../../freeRtos/Source/tasks.c **** }
1996:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1997:../../freeRtos/Source/tasks.c **** 
1998:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
1999:../../freeRtos/Source/tasks.c **** {
2000:../../freeRtos/Source/tasks.c **** tskTCB *pxNewTCB;
2001:../../freeRtos/Source/tasks.c **** 
2002:../../freeRtos/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2003:../../freeRtos/Source/tasks.c **** 	the implementation of the port malloc function. */
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2005:../../freeRtos/Source/tasks.c **** 
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
2007:../../freeRtos/Source/tasks.c **** 	{
2008:../../freeRtos/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2009:../../freeRtos/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2010:../../freeRtos/Source/tasks.c **** 		be deleted later if required. */
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2012:../../freeRtos/Source/tasks.c **** 
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2014:../../freeRtos/Source/tasks.c **** 		{
2015:../../freeRtos/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
2017:../../freeRtos/Source/tasks.c **** 			pxNewTCB = NULL;
2018:../../freeRtos/Source/tasks.c **** 		}
2019:../../freeRtos/Source/tasks.c **** 		else
2020:../../freeRtos/Source/tasks.c **** 		{
2021:../../freeRtos/Source/tasks.c **** 			/* Just to help debugging. */
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2023:../../freeRtos/Source/tasks.c **** 		}
2024:../../freeRtos/Source/tasks.c **** 	}
2025:../../freeRtos/Source/tasks.c **** 
2026:../../freeRtos/Source/tasks.c **** 	return pxNewTCB;
2027:../../freeRtos/Source/tasks.c **** }
2028:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2029:../../freeRtos/Source/tasks.c **** 
2030:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2031:../../freeRtos/Source/tasks.c **** 
2032:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2033:../../freeRtos/Source/tasks.c **** 	{
 187               	.LM2:
 188               	.LFBB2:
 189 0006 2F92      		push r2
 190 0008 3F92      		push r3
 191 000a 4F92      		push r4
 192 000c 5F92      		push r5
 193 000e 6F92      		push r6
 194 0010 7F92      		push r7
 195 0012 8F92      		push r8
 196 0014 9F92      		push r9
 197 0016 AF92      		push r10
 198 0018 BF92      		push r11
 199 001a CF92      		push r12
 200 001c DF92      		push r13
 201 001e EF92      		push r14
 202 0020 FF92      		push r15
 203 0022 0F93      		push r16
 204 0024 1F93      		push r17
 205 0026 CF93      		push r28
 206 0028 DF93      		push r29
 207 002a 1F92      		push __zero_reg__
 208 002c CDB7      		in r28,__SP_L__
 209 002e DEB7      		in r29,__SP_H__
 210               	/* prologue: function */
 211               	/* frame size = 1 */
 212               	/* stack size = 19 */
 213               	.L__stack_usage = 19
 214 0030 5C01      		movw r10,r24
 215 0032 1B01      		movw r2,r22
 216               	.LBB8:
2034:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2035:../../freeRtos/Source/tasks.c **** 	unsigned short usStackRemaining;
2036:../../freeRtos/Source/tasks.c **** 
2037:../../freeRtos/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2038:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 218               	.LM3:
 219 0034 DB01      		movw r26,r22
 220 0036 1196      		adiw r26,1
 221 0038 ED91      		ld r30,X+
 222 003a FC91      		ld r31,X
 223 003c 1297      		sbiw r26,1+1
 224 003e 8281      		ldd r24,Z+2
 225 0040 9381      		ldd r25,Z+3
 226 0042 1296      		adiw r26,1+1
 227 0044 9C93      		st X,r25
 228 0046 8E93      		st -X,r24
 229 0048 1197      		sbiw r26,1
 230 004a 3B01      		movw r6,r22
 231 004c B3E0      		ldi r27,3
 232 004e 6B0E      		add r6,r27
 233 0050 711C      		adc r7,__zero_reg__
 234 0052 8615      		cp r24,r6
 235 0054 9705      		cpc r25,r7
 236 0056 01F4      		brne .L4
 238               	.LM4:
 239 0058 F301      		movw r30,r6
 240 005a 8281      		ldd r24,Z+2
 241 005c 9381      		ldd r25,Z+3
 242 005e DB01      		movw r26,r22
 243 0060 1296      		adiw r26,1+1
 244 0062 9C93      		st X,r25
 245 0064 8E93      		st -X,r24
 246 0066 1197      		sbiw r26,1
 247               	.L4:
 249               	.LM5:
 250 0068 D101      		movw r26,r2
 251 006a 1196      		adiw r26,1
 252 006c ED91      		ld r30,X+
 253 006e FC91      		ld r31,X
 254 0070 1297      		sbiw r26,1+1
 255 0072 8680      		ldd r8,Z+6
 256 0074 9780      		ldd r9,Z+7
 257               	.LBE8:
2039:../../freeRtos/Source/tasks.c **** 		do
2040:../../freeRtos/Source/tasks.c **** 		{
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2042:../../freeRtos/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2043:../../freeRtos/Source/tasks.c **** 			{
2044:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2045:../../freeRtos/Source/tasks.c **** 			}
2046:../../freeRtos/Source/tasks.c **** 			#else
2047:../../freeRtos/Source/tasks.c **** 			{
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2049:../../freeRtos/Source/tasks.c **** 			}
2050:../../freeRtos/Source/tasks.c **** 			#endif			
2051:../../freeRtos/Source/tasks.c **** 			
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 259               	.LM6:
 260 0076 442E      		mov r4,r20
 261 0078 5524      		clr r5
 262 007a 47FC      		sbrc r4,7
 263 007c 5094      		com r5
 264 007e 80E0      		ldi r24,lo8(.LC0)
 265 0080 C82E      		mov r12,r24
 266 0082 80E0      		ldi r24,hi8(.LC0)
 267 0084 D82E      		mov r13,r24
 268 0086 90E0      		ldi r25,lo8(pcStatusString)
 269 0088 E92E      		mov r14,r25
 270 008a 90E0      		ldi r25,hi8(pcStatusString)
 271 008c F92E      		mov r15,r25
 272               	.L9:
 273               	.LBB9:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 275               	.LM7:
 276 008e D101      		movw r26,r2
 277 0090 1196      		adiw r26,1
 278 0092 ED91      		ld r30,X+
 279 0094 FC91      		ld r31,X
 280 0096 1297      		sbiw r26,1+1
 281 0098 8281      		ldd r24,Z+2
 282 009a 9381      		ldd r25,Z+3
 283 009c 1296      		adiw r26,1+1
 284 009e 9C93      		st X,r25
 285 00a0 8E93      		st -X,r24
 286 00a2 1197      		sbiw r26,1
 287 00a4 8615      		cp r24,r6
 288 00a6 9705      		cpc r25,r7
 289 00a8 01F4      		brne .L5
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 291               	.LM8:
 292 00aa F301      		movw r30,r6
 293 00ac 8281      		ldd r24,Z+2
 294 00ae 9381      		ldd r25,Z+3
 295 00b0 1296      		adiw r26,1+1
 296 00b2 9C93      		st X,r25
 297 00b4 8E93      		st -X,r24
 298 00b6 1197      		sbiw r26,1
 299               	.L5:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 301               	.LM9:
 302 00b8 D101      		movw r26,r2
 303 00ba 1196      		adiw r26,1
 304 00bc ED91      		ld r30,X+
 305 00be FC91      		ld r31,X
 306 00c0 1297      		sbiw r26,1+1
 307 00c2 0681      		ldd r16,Z+6
 308 00c4 1781      		ldd r17,Z+7
 309               	.LBE9:
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 311               	.LM10:
 312 00c6 F801      		movw r30,r16
 313 00c8 2789      		ldd r18,Z+23
 314 00ca 308D      		ldd r19,Z+24
 315 00cc F901      		movw r30,r18
 316               	.L6:
 317 00ce CF01      		movw r24,r30
 318 00d0 821B      		sub r24,r18
 319 00d2 930B      		sbc r25,r19
 320               	.LBB10:
 321               	.LBB11:
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2054:../../freeRtos/Source/tasks.c **** 
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2056:../../freeRtos/Source/tasks.c **** 	}
2057:../../freeRtos/Source/tasks.c **** 
2058:../../freeRtos/Source/tasks.c **** #endif
2059:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:../../freeRtos/Source/tasks.c **** 
2061:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2062:../../freeRtos/Source/tasks.c **** 
2063:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2064:../../freeRtos/Source/tasks.c **** 	{
2065:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2066:../../freeRtos/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2067:../../freeRtos/Source/tasks.c **** 
2068:../../freeRtos/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2069:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2070:../../freeRtos/Source/tasks.c **** 		do
2071:../../freeRtos/Source/tasks.c **** 		{
2072:../../freeRtos/Source/tasks.c **** 			/* Get next TCB in from the list. */
2073:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2074:../../freeRtos/Source/tasks.c **** 
2075:../../freeRtos/Source/tasks.c **** 			/* Divide by zero check. */
2076:../../freeRtos/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2077:../../freeRtos/Source/tasks.c **** 			{
2078:../../freeRtos/Source/tasks.c **** 				/* Has the task run at all? */
2079:../../freeRtos/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2080:../../freeRtos/Source/tasks.c **** 				{
2081:../../freeRtos/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2082:../../freeRtos/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2083:../../freeRtos/Source/tasks.c **** 				}
2084:../../freeRtos/Source/tasks.c **** 				else
2085:../../freeRtos/Source/tasks.c **** 				{
2086:../../freeRtos/Source/tasks.c **** 					/* What percentage of the total run time as the task used?
2087:../../freeRtos/Source/tasks.c **** 					This will always be rounded down to the nearest integer. */
2088:../../freeRtos/Source/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2089:../../freeRtos/Source/tasks.c **** 
2090:../../freeRtos/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2091:../../freeRtos/Source/tasks.c **** 					{
2092:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2093:../../freeRtos/Source/tasks.c **** 					}
2094:../../freeRtos/Source/tasks.c **** 					else
2095:../../freeRtos/Source/tasks.c **** 					{
2096:../../freeRtos/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2097:../../freeRtos/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2098:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2099:../../freeRtos/Source/tasks.c **** 					}
2100:../../freeRtos/Source/tasks.c **** 				}
2101:../../freeRtos/Source/tasks.c **** 
2102:../../freeRtos/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2103:../../freeRtos/Source/tasks.c **** 			}
2104:../../freeRtos/Source/tasks.c **** 
2105:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2106:../../freeRtos/Source/tasks.c **** 	}
2107:../../freeRtos/Source/tasks.c **** 
2108:../../freeRtos/Source/tasks.c **** #endif
2109:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2110:../../freeRtos/Source/tasks.c **** 
2111:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2112:../../freeRtos/Source/tasks.c **** 
2113:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2114:../../freeRtos/Source/tasks.c **** 	{
2115:../../freeRtos/Source/tasks.c **** 	register unsigned short usCount = 0;
2116:../../freeRtos/Source/tasks.c **** 
2117:../../freeRtos/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 323               	.LM11:
 324 00d4 5191      		ld r21,Z+
 325 00d6 553A      		cpi r21,lo8(-91)
 326 00d8 01F0      		breq .L6
 327               	.LBE11:
 328               	.LBE10:
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 330               	.LM12:
 331 00da D801      		movw r26,r16
 332 00dc 9396      		adiw r26,35
 333 00de 3C91      		ld r19,X
 334 00e0 9397      		sbiw r26,35
 335 00e2 5696      		adiw r26,22
 336 00e4 2C91      		ld r18,X
 337 00e6 1F92      		push __zero_reg__
 338 00e8 3F93      		push r19
 339 00ea 9F93      		push r25
 340 00ec 8F93      		push r24
 341 00ee 1F92      		push __zero_reg__
 342 00f0 2F93      		push r18
 343 00f2 5F92      		push r5
 344 00f4 4F93      		push r20
 345 00f6 C801      		movw r24,r16
 346 00f8 4996      		adiw r24,25
 347 00fa 9F93      		push r25
 348 00fc 8F93      		push r24
 349 00fe DF92      		push r13
 350 0100 CF92      		push r12
 351 0102 FF92      		push r15
 352 0104 EF92      		push r14
 353 0106 4983      		std Y+1,r20
 354 0108 0E94 0000 		call sprintf
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 356               	.LM13:
 357 010c 60E0      		ldi r22,lo8(pcStatusString)
 358 010e 70E0      		ldi r23,hi8(pcStatusString)
 359 0110 C501      		movw r24,r10
 360 0112 0E94 0000 		call strcat
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 362               	.LM14:
 363 0116 0FB6      		in __tmp_reg__,__SREG__
 364 0118 F894      		cli
 365 011a DEBF      		out __SP_H__,r29
 366 011c 0FBE      		out __SREG__,__tmp_reg__
 367 011e CDBF      		out __SP_L__,r28
 368 0120 4981      		ldd r20,Y+1
 369 0122 0815      		cp r16,r8
 370 0124 1905      		cpc r17,r9
 371 0126 01F0      		breq .+2
 372 0128 00C0      		rjmp .L9
 373               	/* epilogue start */
2056:../../freeRtos/Source/tasks.c **** 	}
 375               	.LM15:
 376 012a 0F90      		pop __tmp_reg__
 377 012c DF91      		pop r29
 378 012e CF91      		pop r28
 379 0130 1F91      		pop r17
 380 0132 0F91      		pop r16
 381 0134 FF90      		pop r15
 382 0136 EF90      		pop r14
 383 0138 DF90      		pop r13
 384 013a CF90      		pop r12
 385 013c BF90      		pop r11
 386 013e AF90      		pop r10
 387 0140 9F90      		pop r9
 388 0142 8F90      		pop r8
 389 0144 7F90      		pop r7
 390 0146 6F90      		pop r6
 391 0148 5F90      		pop r5
 392 014a 4F90      		pop r4
 393 014c 3F90      		pop r3
 394 014e 2F90      		pop r2
 395 0150 0895      		ret
 402               	.Lscope2:
 404               		.stabd	78,0,0
 414               	.global	xTaskGenericCreate
 416               	xTaskGenericCreate:
 417               		.stabd	46,0,0
 387:../../freeRtos/Source/tasks.c **** {
 419               	.LM16:
 420               	.LFBB3:
 421 0152 4F92      		push r4
 422 0154 5F92      		push r5
 423 0156 6F92      		push r6
 424 0158 7F92      		push r7
 425 015a 8F92      		push r8
 426 015c 9F92      		push r9
 427 015e AF92      		push r10
 428 0160 BF92      		push r11
 429 0162 CF92      		push r12
 430 0164 DF92      		push r13
 431 0166 EF92      		push r14
 432 0168 FF92      		push r15
 433 016a 0F93      		push r16
 434 016c 1F93      		push r17
 435 016e CF93      		push r28
 436 0170 DF93      		push r29
 437               	/* prologue: function */
 438               	/* frame size = 0 */
 439               	/* stack size = 16 */
 440               	.L__stack_usage = 16
 441 0172 2C01      		movw r4,r24
 442 0174 3B01      		movw r6,r22
 443 0176 5A01      		movw r10,r20
 444 0178 4901      		movw r8,r18
 445               	.LBB19:
 446               	.LBB20:
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 448               	.LM17:
 449 017a 84E2      		ldi r24,lo8(36)
 450 017c 90E0      		ldi r25,0
 451 017e 0E94 0000 		call pvPortMalloc
 452 0182 EC01      		movw r28,r24
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 454               	.LM18:
 455 0184 0097      		sbiw r24,0
 456 0186 01F4      		brne .+2
 457 0188 00C0      		rjmp .L13
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 459               	.LM19:
 460 018a C114      		cp r12,__zero_reg__
 461 018c D104      		cpc r13,__zero_reg__
 462 018e 01F4      		brne .L23
 463 0190 C501      		movw r24,r10
 464 0192 0E94 0000 		call pvPortMalloc
 465 0196 00C0      		rjmp .L14
 466               	.L23:
 467 0198 C601      		movw r24,r12
 468               	.L14:
 469 019a 988F      		std Y+24,r25
 470 019c 8F8B      		std Y+23,r24
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 472               	.LM20:
 473 019e 0097      		sbiw r24,0
 474 01a0 01F4      		brne .L15
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
 476               	.LM21:
 477 01a2 CE01      		movw r24,r28
 478 01a4 0E94 0000 		call vPortFree
 479 01a8 00C0      		rjmp .L13
 480               	.L15:
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 482               	.LM22:
 483 01aa A501      		movw r20,r10
 484 01ac 65EA      		ldi r22,lo8(-91)
 485 01ae 70E0      		ldi r23,0
 486 01b0 0E94 0000 		call memset
 487               	.LBE20:
 488               	.LBE19:
 489               	.LBB21:
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 491               	.LM23:
 492 01b4 21E0      		ldi r18,1
 493 01b6 A21A      		sub r10,r18
 494 01b8 B108      		sbc r11,__zero_reg__
 495 01ba CF88      		ldd r12,Y+23
 496 01bc D88C      		ldd r13,Y+24
 497 01be CA0C      		add r12,r10
 498 01c0 DB1C      		adc r13,r11
 499               	.LBB22:
 500               	.LBB23:
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 502               	.LM24:
 503 01c2 4AE0      		ldi r20,lo8(10)
 504 01c4 50E0      		ldi r21,0
 505 01c6 B301      		movw r22,r6
 506 01c8 CE01      		movw r24,r28
 507 01ca 4996      		adiw r24,25
 508 01cc 0E94 0000 		call strncpy
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 510               	.LM25:
 511 01d0 1AA2      		std Y+34,__zero_reg__
 512 01d2 102F      		mov r17,r16
 513 01d4 0330      		cpi r16,lo8(3)
 514 01d6 00F0      		brlo .L16
 515 01d8 12E0      		ldi r17,lo8(2)
 516               	.L16:
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 518               	.LM26:
 519 01da 1E8B      		std Y+22,r17
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 521               	.LM27:
 522 01dc 5E01      		movw r10,r28
 523 01de 82E0      		ldi r24,2
 524 01e0 A80E      		add r10,r24
 525 01e2 B11C      		adc r11,__zero_reg__
 526 01e4 C501      		movw r24,r10
 527 01e6 0E94 0000 		call vListInitialiseItem
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 529               	.LM28:
 530 01ea CE01      		movw r24,r28
 531 01ec 0C96      		adiw r24,12
 532 01ee 0E94 0000 		call vListInitialiseItem
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 534               	.LM29:
 535 01f2 D987      		std Y+9,r29
 536 01f4 C887      		std Y+8,r28
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 538               	.LM30:
 539 01f6 83E0      		ldi r24,lo8(3)
 540 01f8 90E0      		ldi r25,0
 541 01fa 811B      		sub r24,r17
 542 01fc 9109      		sbc r25,__zero_reg__
 543 01fe 9D87      		std Y+13,r25
 544 0200 8C87      		std Y+12,r24
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 546               	.LM31:
 547 0202 DB8B      		std Y+19,r29
 548 0204 CA8B      		std Y+18,r28
 549               	.LBE23:
 550               	.LBE22:
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 552               	.LM32:
 553 0206 A401      		movw r20,r8
 554 0208 B201      		movw r22,r4
 555 020a C601      		movw r24,r12
 556 020c 0E94 0000 		call pxPortInitialiseStack
 557 0210 9983      		std Y+1,r25
 558 0212 8883      		st Y,r24
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 560               	.LM33:
 561               	/* #APP */
 562               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 563 0214 0FB6      		in		__tmp_reg__, __SREG__
 564               	 ;  0 "" 2
 565               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 566 0216 F894      		cli
 567               	 ;  0 "" 2
 568               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 569 0218 0F92      		push	__tmp_reg__
 570               	 ;  0 "" 2
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 572               	.LM34:
 573               	/* #NOAPP */
 574 021a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 575 021e 8F5F      		subi r24,lo8(-(1))
 576 0220 8093 0000 		sts uxCurrentNumberOfTasks,r24
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 578               	.LM35:
 579 0224 8091 0000 		lds r24,uxCurrentNumberOfTasks
 580 0228 8130      		cpi r24,lo8(1)
 581 022a 01F4      		brne .L17
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 583               	.LM36:
 584 022c D093 0000 		sts pxCurrentTCB+1,r29
 585 0230 C093 0000 		sts pxCurrentTCB,r28
 586               	.LBB24:
 587               	.LBB25:
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 589               	.LM37:
 590 0234 80E0      		ldi r24,lo8(pxReadyTasksLists)
 591 0236 90E0      		ldi r25,hi8(pxReadyTasksLists)
 592 0238 0E94 0000 		call vListInitialise
 593 023c 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 594 023e 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 595 0240 0E94 0000 		call vListInitialise
 596 0244 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 597 0246 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 598 0248 0E94 0000 		call vListInitialise
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 600               	.LM38:
 601 024c 80E0      		ldi r24,lo8(xDelayedTaskList1)
 602 024e 90E0      		ldi r25,hi8(xDelayedTaskList1)
 603 0250 0E94 0000 		call vListInitialise
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 605               	.LM39:
 606 0254 80E0      		ldi r24,lo8(xDelayedTaskList2)
 607 0256 90E0      		ldi r25,hi8(xDelayedTaskList2)
 608 0258 0E94 0000 		call vListInitialise
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 610               	.LM40:
 611 025c 80E0      		ldi r24,lo8(xPendingReadyList)
 612 025e 90E0      		ldi r25,hi8(xPendingReadyList)
 613 0260 0E94 0000 		call vListInitialise
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 615               	.LM41:
 616 0264 80E0      		ldi r24,lo8(xSuspendedTaskList)
 617 0266 90E0      		ldi r25,hi8(xSuspendedTaskList)
 618 0268 0E94 0000 		call vListInitialise
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 620               	.LM42:
 621 026c 80E0      		ldi r24,lo8(xDelayedTaskList1)
 622 026e 90E0      		ldi r25,hi8(xDelayedTaskList1)
 623 0270 9093 0000 		sts pxDelayedTaskList+1,r25
 624 0274 8093 0000 		sts pxDelayedTaskList,r24
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 626               	.LM43:
 627 0278 80E0      		ldi r24,lo8(xDelayedTaskList2)
 628 027a 90E0      		ldi r25,hi8(xDelayedTaskList2)
 629 027c 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 630 0280 8093 0000 		sts pxOverflowDelayedTaskList,r24
 631 0284 00C0      		rjmp .L18
 632               	.L17:
 633               	.LBE25:
 634               	.LBE24:
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 636               	.LM44:
 637 0286 8091 0000 		lds r24,xSchedulerRunning
 638 028a 8111      		cpse r24,__zero_reg__
 639 028c 00C0      		rjmp .L18
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 641               	.LM45:
 642 028e E091 0000 		lds r30,pxCurrentTCB
 643 0292 F091 0000 		lds r31,pxCurrentTCB+1
 644 0296 8689      		ldd r24,Z+22
 645 0298 0817      		cp r16,r24
 646 029a 00F0      		brlo .L18
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 648               	.LM46:
 649 029c D093 0000 		sts pxCurrentTCB+1,r29
 650 02a0 C093 0000 		sts pxCurrentTCB,r28
 651               	.L18:
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 653               	.LM47:
 654 02a4 8E89      		ldd r24,Y+22
 655 02a6 9091 0000 		lds r25,uxTopUsedPriority
 656 02aa 9817      		cp r25,r24
 657 02ac 00F4      		brsh .L19
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 659               	.LM48:
 660 02ae 8093 0000 		sts uxTopUsedPriority,r24
 661               	.L19:
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 663               	.LM49:
 664 02b2 9091 0000 		lds r25,uxTaskNumber
 665 02b6 9BA3      		std Y+35,r25
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 667               	.LM50:
 668 02b8 9F5F      		subi r25,lo8(-(1))
 669 02ba 9093 0000 		sts uxTaskNumber,r25
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 671               	.LM51:
 672 02be 9091 0000 		lds r25,uxTopReadyPriority
 673 02c2 9817      		cp r25,r24
 674 02c4 00F4      		brsh .L20
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 676               	.LM52:
 677 02c6 8093 0000 		sts uxTopReadyPriority,r24
 678               	.L20:
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 680               	.LM53:
 681 02ca E9E0      		ldi r30,lo8(9)
 682 02cc 8E9F      		mul r24,r30
 683 02ce C001      		movw r24,r0
 684 02d0 1124      		clr __zero_reg__
 685 02d2 B501      		movw r22,r10
 686 02d4 8050      		subi r24,lo8(-(pxReadyTasksLists))
 687 02d6 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 688 02d8 0E94 0000 		call vListInsertEnd
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 690               	.LM54:
 691               	/* #APP */
 692               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 693 02dc 0F90      		pop		__tmp_reg__
 694               	 ;  0 "" 2
 695               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 696 02de 0FBE      		out		__SREG__, __tmp_reg__
 697               	 ;  0 "" 2
 698               	/* #NOAPP */
 699               	.LBE21:
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 701               	.LM55:
 702 02e0 E114      		cp r14,__zero_reg__
 703 02e2 F104      		cpc r15,__zero_reg__
 704 02e4 01F0      		breq .L21
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 706               	.LM56:
 707 02e6 F701      		movw r30,r14
 708 02e8 D183      		std Z+1,r29
 709 02ea C083      		st Z,r28
 710               	.L21:
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 712               	.LM57:
 713 02ec 8091 0000 		lds r24,xSchedulerRunning
 714 02f0 8823      		tst r24
 715 02f2 01F0      		breq .L25
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 717               	.LM58:
 718 02f4 E091 0000 		lds r30,pxCurrentTCB
 719 02f8 F091 0000 		lds r31,pxCurrentTCB+1
 720 02fc 8689      		ldd r24,Z+22
 721 02fe 8017      		cp r24,r16
 722 0300 00F4      		brsh .L25
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 724               	.LM59:
 725 0302 0E94 0000 		call vPortYield
 726               	.L25:
 727               	.LBB26:
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 729               	.LM60:
 730 0306 81E0      		ldi r24,lo8(1)
 731 0308 00C0      		rjmp .L32
 732               	.L13:
 733               	.LBE26:
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 735               	.LM61:
 736 030a 8FEF      		ldi r24,lo8(-1)
 737               	.L32:
 738               	/* epilogue start */
 530:../../freeRtos/Source/tasks.c **** }
 740               	.LM62:
 741 030c DF91      		pop r29
 742 030e CF91      		pop r28
 743 0310 1F91      		pop r17
 744 0312 0F91      		pop r16
 745 0314 FF90      		pop r15
 746 0316 EF90      		pop r14
 747 0318 DF90      		pop r13
 748 031a CF90      		pop r12
 749 031c BF90      		pop r11
 750 031e AF90      		pop r10
 751 0320 9F90      		pop r9
 752 0322 8F90      		pop r8
 753 0324 7F90      		pop r7
 754 0326 6F90      		pop r6
 755 0328 5F90      		pop r5
 756 032a 4F90      		pop r4
 757 032c 0895      		ret
 769               	.Lscope3:
 771               		.stabd	78,0,0
 774               	.global	uxTaskPriorityGet
 776               	uxTaskPriorityGet:
 777               		.stabd	46,0,0
 740:../../freeRtos/Source/tasks.c **** 	{
 779               	.LM63:
 780               	.LFBB4:
 781               	/* prologue: function */
 782               	/* frame size = 0 */
 783               	/* stack size = 0 */
 784               	.L__stack_usage = 0
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 786               	.LM64:
 787               	/* #APP */
 788               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 789 032e 0FB6      		in		__tmp_reg__, __SREG__
 790               	 ;  0 "" 2
 791               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 792 0330 F894      		cli
 793               	 ;  0 "" 2
 794               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 795 0332 0F92      		push	__tmp_reg__
 796               	 ;  0 "" 2
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 798               	.LM65:
 799               	/* #NOAPP */
 800 0334 0097      		sbiw r24,0
 801 0336 01F4      		brne .L34
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 803               	.LM66:
 804 0338 8091 0000 		lds r24,pxCurrentTCB
 805 033c 9091 0000 		lds r25,pxCurrentTCB+1
 806               	.L34:
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 808               	.LM67:
 809               	/* #APP */
 810               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 811 0340 0F90      		pop		__tmp_reg__
 812               	 ;  0 "" 2
 813               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 814 0342 0FBE      		out		__SREG__, __tmp_reg__
 815               	 ;  0 "" 2
 754:../../freeRtos/Source/tasks.c **** 	}
 817               	.LM68:
 818               	/* #NOAPP */
 819 0344 FC01      		movw r30,r24
 820 0346 8689      		ldd r24,Z+22
 821 0348 0895      		ret
 823               	.Lscope4:
 825               		.stabd	78,0,0
 829               	.global	vTaskPrioritySet
 831               	vTaskPrioritySet:
 832               		.stabd	46,0,0
 762:../../freeRtos/Source/tasks.c **** 	{
 834               	.LM69:
 835               	.LFBB5:
 836 034a FF92      		push r15
 837 034c 0F93      		push r16
 838 034e 1F93      		push r17
 839 0350 CF93      		push r28
 840 0352 DF93      		push r29
 841               	/* prologue: function */
 842               	/* frame size = 0 */
 843               	/* stack size = 5 */
 844               	.L__stack_usage = 5
 845 0354 EC01      		movw r28,r24
 846 0356 6330      		cpi r22,lo8(3)
 847 0358 00F0      		brlo .L36
 848 035a 62E0      		ldi r22,lo8(2)
 849               	.L36:
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 851               	.LM70:
 852               	/* #APP */
 853               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 854 035c 0FB6      		in		__tmp_reg__, __SREG__
 855               	 ;  0 "" 2
 856               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 857 035e F894      		cli
 858               	 ;  0 "" 2
 859               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 860 0360 0F92      		push	__tmp_reg__
 861               	 ;  0 "" 2
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 863               	.LM71:
 864               	/* #NOAPP */
 865 0362 8091 0000 		lds r24,pxCurrentTCB
 866 0366 9091 0000 		lds r25,pxCurrentTCB+1
 867 036a C817      		cp r28,r24
 868 036c D907      		cpc r29,r25
 869 036e 01F0      		breq .L37
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 871               	.LM72:
 872 0370 2097      		sbiw r28,0
 873 0372 01F4      		brne .L48
 874               	.L37:
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 876               	.LM73:
 877 0374 C091 0000 		lds r28,pxCurrentTCB
 878 0378 D091 0000 		lds r29,pxCurrentTCB+1
 879 037c 20E0      		ldi r18,0
 880 037e 30E0      		ldi r19,0
 881 0380 00C0      		rjmp .L38
 882               	.L48:
 883 0382 9E01      		movw r18,r28
 884               	.L38:
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 886               	.LM74:
 887 0384 8E89      		ldd r24,Y+22
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 889               	.LM75:
 890 0386 8617      		cp r24,r22
 891 0388 01F0      		breq .L40
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 893               	.LM76:
 894 038a FF24      		clr r15
 895 038c F394      		inc r15
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 897               	.LM77:
 898 038e 8617      		cp r24,r22
 899 0390 00F4      		brsh .L41
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 901               	.LM78:
 902 0392 232B      		or r18,r19
 903 0394 01F4      		brne .L43
 904 0396 00C0      		rjmp .L52
 905               	.L41:
 810:../../freeRtos/Source/tasks.c **** 				else if( pxTask == NULL )
 907               	.LM79:
 908 0398 232B      		or r18,r19
 909 039a 01F0      		breq .L43
 910               	.L52:
 911 039c F12C      		mov r15,__zero_reg__
 912               	.L43:
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 914               	.LM80:
 915 039e 6E8B      		std Y+22,r22
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 917               	.LM81:
 918 03a0 23E0      		ldi r18,lo8(3)
 919 03a2 30E0      		ldi r19,0
 920 03a4 261B      		sub r18,r22
 921 03a6 3109      		sbc r19,__zero_reg__
 922 03a8 3D87      		std Y+13,r19
 923 03aa 2C87      		std Y+12,r18
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 925               	.LM82:
 926 03ac 29E0      		ldi r18,lo8(9)
 927 03ae 829F      		mul r24,r18
 928 03b0 C001      		movw r24,r0
 929 03b2 1124      		clr __zero_reg__
 930 03b4 8050      		subi r24,lo8(-(pxReadyTasksLists))
 931 03b6 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 932 03b8 2A85      		ldd r18,Y+10
 933 03ba 3B85      		ldd r19,Y+11
 934 03bc 2817      		cp r18,r24
 935 03be 3907      		cpc r19,r25
 936 03c0 01F4      		brne .L45
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 938               	.LM83:
 939 03c2 8E01      		movw r16,r28
 940 03c4 0E5F      		subi r16,-2
 941 03c6 1F4F      		sbci r17,-1
 942 03c8 C801      		movw r24,r16
 943 03ca 0E94 0000 		call vListRemove
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 945               	.LM84:
 946 03ce 8E89      		ldd r24,Y+22
 947 03d0 9091 0000 		lds r25,uxTopReadyPriority
 948 03d4 9817      		cp r25,r24
 949 03d6 00F4      		brsh .L46
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 951               	.LM85:
 952 03d8 8093 0000 		sts uxTopReadyPriority,r24
 953               	.L46:
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 955               	.LM86:
 956 03dc 29E0      		ldi r18,lo8(9)
 957 03de 829F      		mul r24,r18
 958 03e0 C001      		movw r24,r0
 959 03e2 1124      		clr __zero_reg__
 960 03e4 B801      		movw r22,r16
 961 03e6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 962 03e8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 963 03ea 0E94 0000 		call vListInsertEnd
 964               	.L45:
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 966               	.LM87:
 967 03ee 81E0      		ldi r24,lo8(1)
 968 03f0 F812      		cpse r15,r24
 969 03f2 00C0      		rjmp .L40
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 971               	.LM88:
 972 03f4 0E94 0000 		call vPortYield
 973               	.L40:
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 975               	.LM89:
 976               	/* #APP */
 977               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 978 03f8 0F90      		pop		__tmp_reg__
 979               	 ;  0 "" 2
 980               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 981 03fa 0FBE      		out		__SREG__, __tmp_reg__
 982               	 ;  0 "" 2
 983               	/* epilogue start */
 859:../../freeRtos/Source/tasks.c **** 	}
 985               	.LM90:
 986               	/* #NOAPP */
 987 03fc DF91      		pop r29
 988 03fe CF91      		pop r28
 989 0400 1F91      		pop r17
 990 0402 0F91      		pop r16
 991 0404 FF90      		pop r15
 992 0406 0895      		ret
 998               	.Lscope5:
 1000               		.stabd	78,0,0
 1003               	.global	vTaskSuspend
 1005               	vTaskSuspend:
 1006               		.stabd	46,0,0
 867:../../freeRtos/Source/tasks.c **** 	{
 1008               	.LM91:
 1009               	.LFBB6:
 1010 0408 EF92      		push r14
 1011 040a FF92      		push r15
 1012 040c 0F93      		push r16
 1013 040e 1F93      		push r17
 1014 0410 CF93      		push r28
 1015 0412 DF93      		push r29
 1016               	/* prologue: function */
 1017               	/* frame size = 0 */
 1018               	/* stack size = 6 */
 1019               	.L__stack_usage = 6
 1020 0414 EC01      		movw r28,r24
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1022               	.LM92:
 1023               	/* #APP */
 1024               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1025 0416 0FB6      		in		__tmp_reg__, __SREG__
 1026               	 ;  0 "" 2
 1027               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1028 0418 F894      		cli
 1029               	 ;  0 "" 2
 1030               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1031 041a 0F92      		push	__tmp_reg__
 1032               	 ;  0 "" 2
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1034               	.LM93:
 1035               	/* #NOAPP */
 1036 041c 8091 0000 		lds r24,pxCurrentTCB
 1037 0420 9091 0000 		lds r25,pxCurrentTCB+1
 1038 0424 C817      		cp r28,r24
 1039 0426 D907      		cpc r29,r25
 1040 0428 01F0      		breq .L54
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1042               	.LM94:
 1043 042a 2097      		sbiw r28,0
 1044 042c 01F4      		brne .L58
 1045               	.L54:
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1047               	.LM95:
 1048 042e 0091 0000 		lds r16,pxCurrentTCB
 1049 0432 1091 0000 		lds r17,pxCurrentTCB+1
 1050 0436 C0E0      		ldi r28,0
 1051 0438 D0E0      		ldi r29,0
 1052 043a 00C0      		rjmp .L55
 1053               	.L58:
 1054 043c 8E01      		movw r16,r28
 1055               	.L55:
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1057               	.LM96:
 1058 043e 7801      		movw r14,r16
 1059 0440 82E0      		ldi r24,2
 1060 0442 E80E      		add r14,r24
 1061 0444 F11C      		adc r15,__zero_reg__
 1062 0446 C701      		movw r24,r14
 1063 0448 0E94 0000 		call vListRemove
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 1065               	.LM97:
 1066 044c F801      		movw r30,r16
 1067 044e 8489      		ldd r24,Z+20
 1068 0450 9589      		ldd r25,Z+21
 1069 0452 892B      		or r24,r25
 1070 0454 01F0      		breq .L56
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1072               	.LM98:
 1073 0456 C801      		movw r24,r16
 1074 0458 0C96      		adiw r24,12
 1075 045a 0E94 0000 		call vListRemove
 1076               	.L56:
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1078               	.LM99:
 1079 045e B701      		movw r22,r14
 1080 0460 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1081 0462 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1082 0464 0E94 0000 		call vListInsertEnd
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1084               	.LM100:
 1085               	/* #APP */
 1086               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1087 0468 0F90      		pop		__tmp_reg__
 1088               	 ;  0 "" 2
 1089               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1090 046a 0FBE      		out		__SREG__, __tmp_reg__
 1091               	 ;  0 "" 2
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1093               	.LM101:
 1094               	/* #NOAPP */
 1095 046c CD2B      		or r28,r29
 1096 046e 01F4      		brne .L53
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1098               	.LM102:
 1099 0470 0E94 0000 		call vPortYield
 1100               	.L53:
 1101               	/* epilogue start */
 902:../../freeRtos/Source/tasks.c **** 	}
 1103               	.LM103:
 1104 0474 DF91      		pop r29
 1105 0476 CF91      		pop r28
 1106 0478 1F91      		pop r17
 1107 047a 0F91      		pop r16
 1108 047c FF90      		pop r15
 1109 047e EF90      		pop r14
 1110 0480 0895      		ret
 1112               	.Lscope6:
 1114               		.stabd	78,0,0
 1117               	.global	xTaskIsTaskSuspended
 1119               	xTaskIsTaskSuspended:
 1120               		.stabd	46,0,0
 910:../../freeRtos/Source/tasks.c **** 	{
 1122               	.LM104:
 1123               	.LFBB7:
 1124               	/* prologue: function */
 1125               	/* frame size = 0 */
 1126               	/* stack size = 0 */
 1127               	.L__stack_usage = 0
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1129               	.LM105:
 1130 0482 FC01      		movw r30,r24
 1131 0484 2285      		ldd r18,Z+10
 1132 0486 3385      		ldd r19,Z+11
 1133 0488 2050      		subi r18,lo8(xSuspendedTaskList)
 1134 048a 3040      		sbci r19,hi8(xSuspendedTaskList)
 1135 048c 01F4      		brne .L66
 1136               	.LBB29:
 1137               	.LBB30:
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1139               	.LM106:
 1140 048e FC01      		movw r30,r24
 1141 0490 2489      		ldd r18,Z+20
 1142 0492 3589      		ldd r19,Z+21
 1143 0494 F0E0      		ldi r31,hi8(xPendingReadyList)
 1144 0496 2030      		cpi r18,lo8(xPendingReadyList)
 1145 0498 3F07      		cpc r19,r31
 1146 049a 01F0      		breq .L66
 925:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1148               	.LM107:
 1149 049c 81E0      		ldi r24,lo8(1)
 1150 049e 232B      		or r18,r19
 1151 04a0 01F0      		breq .L63
 1152               	.L66:
 1153               	.LBE30:
 1154               	.LBE29:
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1156               	.LM108:
 1157 04a2 80E0      		ldi r24,0
 1158               	.L63:
 933:../../freeRtos/Source/tasks.c **** 	}
 1160               	.LM109:
 1161 04a4 0895      		ret
 1166               	.Lscope7:
 1168               		.stabd	78,0,0
 1171               	.global	vTaskResume
 1173               	vTaskResume:
 1174               		.stabd	46,0,0
 941:../../freeRtos/Source/tasks.c **** 	{
 1176               	.LM110:
 1177               	.LFBB8:
 1178 04a6 0F93      		push r16
 1179 04a8 1F93      		push r17
 1180 04aa CF93      		push r28
 1181 04ac DF93      		push r29
 1182               	/* prologue: function */
 1183               	/* frame size = 0 */
 1184               	/* stack size = 4 */
 1185               	.L__stack_usage = 4
 1186 04ae EC01      		movw r28,r24
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1188               	.LM111:
 1189 04b0 0097      		sbiw r24,0
 1190 04b2 01F0      		breq .L71
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1192               	.LM112:
 1193 04b4 8091 0000 		lds r24,pxCurrentTCB
 1194 04b8 9091 0000 		lds r25,pxCurrentTCB+1
 1195 04bc C817      		cp r28,r24
 1196 04be D907      		cpc r29,r25
 1197 04c0 01F0      		breq .L71
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 1199               	.LM113:
 1200               	/* #APP */
 1201               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1202 04c2 0FB6      		in		__tmp_reg__, __SREG__
 1203               	 ;  0 "" 2
 1204               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1205 04c4 F894      		cli
 1206               	 ;  0 "" 2
 1207               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1208 04c6 0F92      		push	__tmp_reg__
 1209               	 ;  0 "" 2
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1211               	.LM114:
 1212               	/* #NOAPP */
 1213 04c8 CE01      		movw r24,r28
 1214 04ca 0E94 0000 		call xTaskIsTaskSuspended
 1215 04ce 8130      		cpi r24,lo8(1)
 1216 04d0 01F4      		brne .L74
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1218               	.LM115:
 1219 04d2 8E01      		movw r16,r28
 1220 04d4 0E5F      		subi r16,-2
 1221 04d6 1F4F      		sbci r17,-1
 1222 04d8 C801      		movw r24,r16
 1223 04da 0E94 0000 		call vListRemove
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1225               	.LM116:
 1226 04de 8E89      		ldd r24,Y+22
 1227 04e0 9091 0000 		lds r25,uxTopReadyPriority
 1228 04e4 9817      		cp r25,r24
 1229 04e6 00F4      		brsh .L75
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1231               	.LM117:
 1232 04e8 8093 0000 		sts uxTopReadyPriority,r24
 1233               	.L75:
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1235               	.LM118:
 1236 04ec 29E0      		ldi r18,lo8(9)
 1237 04ee 829F      		mul r24,r18
 1238 04f0 C001      		movw r24,r0
 1239 04f2 1124      		clr __zero_reg__
 1240 04f4 B801      		movw r22,r16
 1241 04f6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1242 04f8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1243 04fa 0E94 0000 		call vListInsertEnd
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1245               	.LM119:
 1246 04fe E091 0000 		lds r30,pxCurrentTCB
 1247 0502 F091 0000 		lds r31,pxCurrentTCB+1
 1248 0506 9E89      		ldd r25,Y+22
 1249 0508 8689      		ldd r24,Z+22
 1250 050a 9817      		cp r25,r24
 1251 050c 00F0      		brlo .L74
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1253               	.LM120:
 1254 050e 0E94 0000 		call vPortYield
 1255               	.L74:
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 1257               	.LM121:
 1258               	/* #APP */
 1259               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1260 0512 0F90      		pop		__tmp_reg__
 1261               	 ;  0 "" 2
 1262               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1263 0514 0FBE      		out		__SREG__, __tmp_reg__
 1264               	 ;  0 "" 2
 1265               	/* #NOAPP */
 1266               	.L71:
 1267               	/* epilogue start */
 974:../../freeRtos/Source/tasks.c **** 	}
 1269               	.LM122:
 1270 0516 DF91      		pop r29
 1271 0518 CF91      		pop r28
 1272 051a 1F91      		pop r17
 1273 051c 0F91      		pop r16
 1274 051e 0895      		ret
 1276               	.Lscope8:
 1278               		.stabd	78,0,0
 1281               	.global	xTaskResumeFromISR
 1283               	xTaskResumeFromISR:
 1284               		.stabd	46,0,0
 983:../../freeRtos/Source/tasks.c **** 	{
 1286               	.LM123:
 1287               	.LFBB9:
 1288 0520 FF92      		push r15
 1289 0522 0F93      		push r16
 1290 0524 1F93      		push r17
 1291 0526 CF93      		push r28
 1292 0528 DF93      		push r29
 1293               	/* prologue: function */
 1294               	/* frame size = 0 */
 1295               	/* stack size = 5 */
 1296               	.L__stack_usage = 5
 1297 052a EC01      		movw r28,r24
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1299               	.LM124:
 1300 052c 0E94 0000 		call xTaskIsTaskSuspended
 1301 0530 8130      		cpi r24,lo8(1)
 1302 0532 01F4      		brne .L85
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1304               	.LM125:
 1305 0534 8091 0000 		lds r24,uxSchedulerSuspended
 1306 0538 8111      		cpse r24,__zero_reg__
 1307 053a 00C0      		rjmp .L82
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1309               	.LM126:
 1310 053c E091 0000 		lds r30,pxCurrentTCB
 1311 0540 F091 0000 		lds r31,pxCurrentTCB+1
 1312 0544 FF24      		clr r15
 1313 0546 F394      		inc r15
 1314 0548 9E89      		ldd r25,Y+22
 1315 054a 8689      		ldd r24,Z+22
 1316 054c 9817      		cp r25,r24
 1317 054e 00F4      		brsh .L83
 1318 0550 F12C      		mov r15,__zero_reg__
 1319               	.L83:
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1321               	.LM127:
 1322 0552 8E01      		movw r16,r28
 1323 0554 0E5F      		subi r16,-2
 1324 0556 1F4F      		sbci r17,-1
 1325 0558 C801      		movw r24,r16
 1326 055a 0E94 0000 		call vListRemove
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1328               	.LM128:
 1329 055e 2E89      		ldd r18,Y+22
 1330 0560 8091 0000 		lds r24,uxTopReadyPriority
 1331 0564 8217      		cp r24,r18
 1332 0566 00F4      		brsh .L84
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1334               	.LM129:
 1335 0568 2093 0000 		sts uxTopReadyPriority,r18
 1336               	.L84:
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1338               	.LM130:
 1339 056c 39E0      		ldi r19,lo8(9)
 1340 056e 239F      		mul r18,r19
 1341 0570 C001      		movw r24,r0
 1342 0572 1124      		clr __zero_reg__
 1343 0574 B801      		movw r22,r16
 1344 0576 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1345 0578 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1346 057a 0E94 0000 		call vListInsertEnd
 1347 057e 00C0      		rjmp .L81
 1348               	.L82:
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1350               	.LM131:
 1351 0580 BE01      		movw r22,r28
 1352 0582 645F      		subi r22,-12
 1353 0584 7F4F      		sbci r23,-1
 1354 0586 80E0      		ldi r24,lo8(xPendingReadyList)
 1355 0588 90E0      		ldi r25,hi8(xPendingReadyList)
 1356 058a 0E94 0000 		call vListInsertEnd
 1357               	.L85:
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1359               	.LM132:
 1360 058e F12C      		mov r15,__zero_reg__
 1361               	.L81:
1009:../../freeRtos/Source/tasks.c **** 	}
 1363               	.LM133:
 1364 0590 8F2D      		mov r24,r15
 1365               	/* epilogue start */
 1366 0592 DF91      		pop r29
 1367 0594 CF91      		pop r28
 1368 0596 1F91      		pop r17
 1369 0598 0F91      		pop r16
 1370 059a FF90      		pop r15
 1371 059c 0895      		ret
 1376               	.Lscope9:
 1378               		.stabd	78,0,0
 1379               		.section	.rodata.str1.1
 1380               	.LC1:
 1381 0012 4944 4C45 		.string	"IDLE"
 1381      00
 1382               		.text
 1384               	.global	vTaskStartScheduler
 1386               	vTaskStartScheduler:
 1387               		.stabd	46,0,0
1022:../../freeRtos/Source/tasks.c **** {
 1389               	.LM134:
 1390               	.LFBB10:
 1391 059e AF92      		push r10
 1392 05a0 BF92      		push r11
 1393 05a2 CF92      		push r12
 1394 05a4 DF92      		push r13
 1395 05a6 EF92      		push r14
 1396 05a8 FF92      		push r15
 1397 05aa 0F93      		push r16
 1398               	/* prologue: function */
 1399               	/* frame size = 0 */
 1400               	/* stack size = 7 */
 1401               	.L__stack_usage = 7
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 1403               	.LM135:
 1404 05ac A12C      		mov r10,__zero_reg__
 1405 05ae B12C      		mov r11,__zero_reg__
 1406 05b0 C12C      		mov r12,__zero_reg__
 1407 05b2 D12C      		mov r13,__zero_reg__
 1408 05b4 E12C      		mov r14,__zero_reg__
 1409 05b6 F12C      		mov r15,__zero_reg__
 1410 05b8 00E0      		ldi r16,0
 1411 05ba 20E0      		ldi r18,0
 1412 05bc 30E0      		ldi r19,0
 1413 05be 44E6      		ldi r20,lo8(100)
 1414 05c0 50E0      		ldi r21,0
 1415 05c2 60E0      		ldi r22,lo8(.LC1)
 1416 05c4 70E0      		ldi r23,hi8(.LC1)
 1417 05c6 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1418 05c8 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1419 05ca 0E94 0000 		call xTaskGenericCreate
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 1421               	.LM136:
 1422 05ce 8130      		cpi r24,lo8(1)
 1423 05d0 01F4      		brne .L86
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1425               	.LM137:
 1426               	/* #APP */
 1427               	 ;  1038 "../../freeRtos/Source/tasks.c" 1
 1428 05d2 F894      		cli
 1429               	 ;  0 "" 2
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1431               	.LM138:
 1432               	/* #NOAPP */
 1433 05d4 8093 0000 		sts xSchedulerRunning,r24
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
 1435               	.LM139:
 1436 05d8 1092 0000 		sts xTickCount+1,__zero_reg__
 1437 05dc 1092 0000 		sts xTickCount,__zero_reg__
 1438               	/* epilogue start */
1060:../../freeRtos/Source/tasks.c **** }
 1440               	.LM140:
 1441 05e0 0F91      		pop r16
 1442 05e2 FF90      		pop r15
 1443 05e4 EF90      		pop r14
 1444 05e6 DF90      		pop r13
 1445 05e8 CF90      		pop r12
 1446 05ea BF90      		pop r11
 1447 05ec AF90      		pop r10
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
 1449               	.LM141:
 1450 05ee 0C94 0000 		jmp xPortStartScheduler
 1451               	.L86:
 1452               	/* epilogue start */
1060:../../freeRtos/Source/tasks.c **** }
 1454               	.LM142:
 1455 05f2 0F91      		pop r16
 1456 05f4 FF90      		pop r15
 1457 05f6 EF90      		pop r14
 1458 05f8 DF90      		pop r13
 1459 05fa CF90      		pop r12
 1460 05fc BF90      		pop r11
 1461 05fe AF90      		pop r10
 1462 0600 0895      		ret
 1464               	.Lscope10:
 1466               		.stabd	78,0,0
 1468               	.global	vTaskEndScheduler
 1470               	vTaskEndScheduler:
 1471               		.stabd	46,0,0
1064:../../freeRtos/Source/tasks.c **** {
 1473               	.LM143:
 1474               	.LFBB11:
 1475               	/* prologue: function */
 1476               	/* frame size = 0 */
 1477               	/* stack size = 0 */
 1478               	.L__stack_usage = 0
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1480               	.LM144:
 1481               	/* #APP */
 1482               	 ;  1068 "../../freeRtos/Source/tasks.c" 1
 1483 0602 F894      		cli
 1484               	 ;  0 "" 2
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1486               	.LM145:
 1487               	/* #NOAPP */
 1488 0604 1092 0000 		sts xSchedulerRunning,__zero_reg__
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
 1490               	.LM146:
 1491 0608 0C94 0000 		jmp vPortEndScheduler
 1493               	.Lscope11:
 1495               		.stabd	78,0,0
 1497               	.global	vTaskSuspendAll
 1499               	vTaskSuspendAll:
 1500               		.stabd	46,0,0
1075:../../freeRtos/Source/tasks.c **** {
 1502               	.LM147:
 1503               	.LFBB12:
 1504               	/* prologue: function */
 1505               	/* frame size = 0 */
 1506               	/* stack size = 0 */
 1507               	.L__stack_usage = 0
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
 1509               	.LM148:
 1510 060c 8091 0000 		lds r24,uxSchedulerSuspended
 1511 0610 8F5F      		subi r24,lo8(-(1))
 1512 0612 8093 0000 		sts uxSchedulerSuspended,r24
 1513 0616 0895      		ret
 1515               	.Lscope12:
 1517               		.stabd	78,0,0
 1519               	.global	xTaskGetTickCount
 1521               	xTaskGetTickCount:
 1522               		.stabd	46,0,0
1165:../../freeRtos/Source/tasks.c **** {
 1524               	.LM149:
 1525               	.LFBB13:
 1526               	/* prologue: function */
 1527               	/* frame size = 0 */
 1528               	/* stack size = 0 */
 1529               	.L__stack_usage = 0
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 1531               	.LM150:
 1532               	/* #APP */
 1533               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1534 0618 0FB6      		in		__tmp_reg__, __SREG__
 1535               	 ;  0 "" 2
 1536               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1537 061a F894      		cli
 1538               	 ;  0 "" 2
 1539               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1540 061c 0F92      		push	__tmp_reg__
 1541               	 ;  0 "" 2
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
 1543               	.LM151:
 1544               	/* #NOAPP */
 1545 061e 8091 0000 		lds r24,xTickCount
 1546 0622 9091 0000 		lds r25,xTickCount+1
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 1548               	.LM152:
 1549               	/* #APP */
 1550               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1551 0626 0F90      		pop		__tmp_reg__
 1552               	 ;  0 "" 2
 1553               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1554 0628 0FBE      		out		__SREG__, __tmp_reg__
 1555               	 ;  0 "" 2
1176:../../freeRtos/Source/tasks.c **** }
 1557               	.LM153:
 1558               	/* #NOAPP */
 1559 062a 0895      		ret
 1564               	.Lscope13:
 1566               		.stabd	78,0,0
 1568               	.global	uxTaskGetNumberOfTasks
 1570               	uxTaskGetNumberOfTasks:
 1571               		.stabd	46,0,0
1180:../../freeRtos/Source/tasks.c **** {
 1573               	.LM154:
 1574               	.LFBB14:
 1575               	/* prologue: function */
 1576               	/* frame size = 0 */
 1577               	/* stack size = 0 */
 1578               	.L__stack_usage = 0
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1580               	.LM155:
 1581 062c 8091 0000 		lds r24,uxCurrentNumberOfTasks
1184:../../freeRtos/Source/tasks.c **** }
 1583               	.LM156:
 1584 0630 0895      		ret
 1586               	.Lscope14:
 1588               		.stabd	78,0,0
 1592               	.global	vTaskStartTrace
 1594               	vTaskStartTrace:
 1595               		.stabd	46,0,0
1318:../../freeRtos/Source/tasks.c **** 	{
 1597               	.LM157:
 1598               	.LFBB15:
 1599               	/* prologue: function */
 1600               	/* frame size = 0 */
 1601               	/* stack size = 0 */
 1602               	.L__stack_usage = 0
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1604               	.LM158:
 1605               	/* #APP */
 1606               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1607 0632 0FB6      		in		__tmp_reg__, __SREG__
 1608               	 ;  0 "" 2
 1609               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1610 0634 F894      		cli
 1611               	 ;  0 "" 2
 1612               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1613 0636 0F92      		push	__tmp_reg__
 1614               	 ;  0 "" 2
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1616               	.LM159:
 1617               	/* #NOAPP */
 1618 0638 9093 0000 		sts pcTraceBuffer+1,r25
 1619 063c 8093 0000 		sts pcTraceBuffer,r24
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 1621               	.LM160:
 1622 0640 9093 0000 		sts pcTraceBufferStart+1,r25
 1623 0644 8093 0000 		sts pcTraceBufferStart,r24
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1625               	.LM161:
 1626 0648 4850      		subi r20,8
 1627 064a 5109      		sbc r21,__zero_reg__
 1628 064c 480F      		add r20,r24
 1629 064e 591F      		adc r21,r25
 1630 0650 5093 0000 		sts pcTraceBufferEnd+1,r21
 1631 0654 4093 0000 		sts pcTraceBufferEnd,r20
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
 1633               	.LM162:
 1634 0658 81E0      		ldi r24,lo8(1)
 1635 065a 8093 0000 		sts xTracing,r24
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1637               	.LM163:
 1638               	/* #APP */
 1639               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 1640 065e 0F90      		pop		__tmp_reg__
 1641               	 ;  0 "" 2
 1642               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 1643 0660 0FBE      		out		__SREG__, __tmp_reg__
 1644               	 ;  0 "" 2
 1645               	/* #NOAPP */
 1646 0662 0895      		ret
 1648               	.Lscope15:
 1650               		.stabd	78,0,0
 1652               	.global	ulTaskEndTrace
 1654               	ulTaskEndTrace:
 1655               		.stabd	46,0,0
1335:../../freeRtos/Source/tasks.c **** 	{
 1657               	.LM164:
 1658               	.LFBB16:
 1659               	/* prologue: function */
 1660               	/* frame size = 0 */
 1661               	/* stack size = 0 */
 1662               	.L__stack_usage = 0
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1664               	.LM165:
 1665               	/* #APP */
 1666               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1667 0664 0FB6      		in		__tmp_reg__, __SREG__
 1668               	 ;  0 "" 2
 1669               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1670 0666 F894      		cli
 1671               	 ;  0 "" 2
 1672               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1673 0668 0F92      		push	__tmp_reg__
 1674               	 ;  0 "" 2
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
 1676               	.LM166:
 1677               	/* #NOAPP */
 1678 066a 1092 0000 		sts xTracing,__zero_reg__
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1680               	.LM167:
 1681               	/* #APP */
 1682               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 1683 066e 0F90      		pop		__tmp_reg__
 1684               	 ;  0 "" 2
 1685               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 1686 0670 0FBE      		out		__SREG__, __tmp_reg__
 1687               	 ;  0 "" 2
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 1689               	.LM168:
 1690               	/* #NOAPP */
 1691 0672 6091 0000 		lds r22,pcTraceBuffer
 1692 0676 7091 0000 		lds r23,pcTraceBuffer+1
 1693 067a 8091 0000 		lds r24,pcTraceBufferStart
 1694 067e 9091 0000 		lds r25,pcTraceBufferStart+1
 1695 0682 681B      		sub r22,r24
 1696 0684 790B      		sbc r23,r25
 1697 0686 8827      		clr r24
 1698 0688 77FD      		sbrc r23,7
 1699 068a 8095      		com r24
 1700 068c 982F      		mov r25,r24
1345:../../freeRtos/Source/tasks.c **** 	}
 1702               	.LM169:
 1703 068e 0895      		ret
 1705               	.Lscope16:
 1707               		.stabd	78,0,0
 1709               	.global	vTaskIncrementTick
 1711               	vTaskIncrementTick:
 1712               		.stabd	46,0,0
1358:../../freeRtos/Source/tasks.c **** {
 1714               	.LM170:
 1715               	.LFBB17:
 1716 0690 FF92      		push r15
 1717 0692 0F93      		push r16
 1718 0694 1F93      		push r17
 1719 0696 CF93      		push r28
 1720 0698 DF93      		push r29
 1721               	/* prologue: function */
 1722               	/* frame size = 0 */
 1723               	/* stack size = 5 */
 1724               	.L__stack_usage = 5
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1726               	.LM171:
 1727 069a 8091 0000 		lds r24,uxSchedulerSuspended
 1728 069e 8111      		cpse r24,__zero_reg__
 1729 06a0 00C0      		rjmp .L95
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
 1731               	.LM172:
 1732 06a2 8091 0000 		lds r24,xTickCount
 1733 06a6 9091 0000 		lds r25,xTickCount+1
 1734 06aa 0196      		adiw r24,1
 1735 06ac 9093 0000 		sts xTickCount+1,r25
 1736 06b0 8093 0000 		sts xTickCount,r24
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 1738               	.LM173:
 1739 06b4 8091 0000 		lds r24,xTickCount
 1740 06b8 9091 0000 		lds r25,xTickCount+1
 1741 06bc 892B      		or r24,r25
 1742 06be 01F4      		brne .L96
 1743               	.LBB31:
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1745               	.LM174:
 1746 06c0 8091 0000 		lds r24,pxDelayedTaskList
 1747 06c4 9091 0000 		lds r25,pxDelayedTaskList+1
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1749               	.LM175:
 1750 06c8 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1751 06cc 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1752 06d0 3093 0000 		sts pxDelayedTaskList+1,r19
 1753 06d4 2093 0000 		sts pxDelayedTaskList,r18
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1755               	.LM176:
 1756 06d8 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1757 06dc 8093 0000 		sts pxOverflowDelayedTaskList,r24
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
 1759               	.LM177:
 1760 06e0 8091 0000 		lds r24,xNumOfOverflows
 1761 06e4 8F5F      		subi r24,lo8(-(1))
 1762 06e6 8093 0000 		sts xNumOfOverflows,r24
 1763               	.L96:
 1764               	.LBE31:
 1765               	.LBB32:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1767               	.LM178:
 1768 06ea 29E0      		ldi r18,lo8(9)
 1769 06ec F22E      		mov r15,r18
 1770               	.L97:
 1771 06ee E091 0000 		lds r30,pxDelayedTaskList
 1772 06f2 F091 0000 		lds r31,pxDelayedTaskList+1
 1773 06f6 8081      		ld r24,Z
 1774 06f8 8823      		tst r24
 1775 06fa 01F0      		breq .L98
 1776 06fc E091 0000 		lds r30,pxDelayedTaskList
 1777 0700 F091 0000 		lds r31,pxDelayedTaskList+1
 1778 0704 0580      		ldd __tmp_reg__,Z+5
 1779 0706 F681      		ldd r31,Z+6
 1780 0708 E02D      		mov r30,__tmp_reg__
 1781 070a C681      		ldd r28,Z+6
 1782 070c D781      		ldd r29,Z+7
 1783 070e 2097      		sbiw r28,0
 1784 0710 01F0      		breq .L98
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1786               	.LM179:
 1787 0712 2091 0000 		lds r18,xTickCount
 1788 0716 3091 0000 		lds r19,xTickCount+1
 1789 071a 8A81      		ldd r24,Y+2
 1790 071c 9B81      		ldd r25,Y+3
 1791 071e 2817      		cp r18,r24
 1792 0720 3907      		cpc r19,r25
 1793 0722 00F0      		brlo .L98
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1795               	.LM180:
 1796 0724 8E01      		movw r16,r28
 1797 0726 0E5F      		subi r16,-2
 1798 0728 1F4F      		sbci r17,-1
 1799 072a C801      		movw r24,r16
 1800 072c 0E94 0000 		call vListRemove
 1801 0730 8C89      		ldd r24,Y+20
 1802 0732 9D89      		ldd r25,Y+21
 1803 0734 892B      		or r24,r25
 1804 0736 01F0      		breq .L99
 1805 0738 CE01      		movw r24,r28
 1806 073a 0C96      		adiw r24,12
 1807 073c 0E94 0000 		call vListRemove
 1808               	.L99:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1810               	.LM181:
 1811 0740 8E89      		ldd r24,Y+22
 1812 0742 9091 0000 		lds r25,uxTopReadyPriority
 1813 0746 9817      		cp r25,r24
 1814 0748 00F4      		brsh .L100
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1816               	.LM182:
 1817 074a 8093 0000 		sts uxTopReadyPriority,r24
 1818               	.L100:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 1820               	.LM183:
 1821 074e F89E      		mul r15,r24
 1822 0750 C001      		movw r24,r0
 1823 0752 1124      		clr __zero_reg__
 1824 0754 B801      		movw r22,r16
 1825 0756 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1826 0758 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1827 075a 0E94 0000 		call vListInsertEnd
 1828 075e 00C0      		rjmp .L97
 1829               	.L95:
 1830               	.LBE32:
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
 1832               	.LM184:
 1833 0760 8091 0000 		lds r24,uxMissedTicks
 1834 0764 8F5F      		subi r24,lo8(-(1))
 1835 0766 8093 0000 		sts uxMissedTicks,r24
 1836               	.LBB33:
1391:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
 1838               	.LM185:
 1839 076a 0E94 0000 		call vApplicationTickHook
 1840               	.L98:
 1841               	.LBE33:
 1842               	.LBB34:
1402:../../freeRtos/Source/tasks.c **** 		if( uxMissedTicks == 0 )
 1844               	.LM186:
 1845 076e 8091 0000 		lds r24,uxMissedTicks
 1846 0772 8111      		cpse r24,__zero_reg__
 1847 0774 00C0      		rjmp .L94
 1848               	/* epilogue start */
 1849               	.LBE34:
1410:../../freeRtos/Source/tasks.c **** }
 1851               	.LM187:
 1852 0776 DF91      		pop r29
 1853 0778 CF91      		pop r28
 1854 077a 1F91      		pop r17
 1855 077c 0F91      		pop r16
 1856 077e FF90      		pop r15
 1857               	.LBB35:
1404:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
 1859               	.LM188:
 1860 0780 0C94 0000 		jmp vApplicationTickHook
 1861               	.L94:
 1862               	/* epilogue start */
 1863               	.LBE35:
1410:../../freeRtos/Source/tasks.c **** }
 1865               	.LM189:
 1866 0784 DF91      		pop r29
 1867 0786 CF91      		pop r28
 1868 0788 1F91      		pop r17
 1869 078a 0F91      		pop r16
 1870 078c FF90      		pop r15
 1871 078e 0895      		ret
 1879               	.Lscope17:
 1881               		.stabd	78,0,0
 1883               	.global	xTaskResumeAll
 1885               	xTaskResumeAll:
 1886               		.stabd	46,0,0
1083:../../freeRtos/Source/tasks.c **** {
 1888               	.LM190:
 1889               	.LFBB18:
 1890 0790 EF92      		push r14
 1891 0792 FF92      		push r15
 1892 0794 0F93      		push r16
 1893 0796 1F93      		push r17
 1894 0798 CF93      		push r28
 1895 079a DF93      		push r29
 1896               	/* prologue: function */
 1897               	/* frame size = 0 */
 1898               	/* stack size = 6 */
 1899               	.L__stack_usage = 6
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 1901               	.LM191:
 1902               	/* #APP */
 1903               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 1904 079c 0FB6      		in		__tmp_reg__, __SREG__
 1905               	 ;  0 "" 2
 1906               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 1907 079e F894      		cli
 1908               	 ;  0 "" 2
 1909               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 1910 07a0 0F92      		push	__tmp_reg__
 1911               	 ;  0 "" 2
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
 1913               	.LM192:
 1914               	/* #NOAPP */
 1915 07a2 8091 0000 		lds r24,uxSchedulerSuspended
 1916 07a6 8150      		subi r24,lo8(-(-1))
 1917 07a8 8093 0000 		sts uxSchedulerSuspended,r24
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1919               	.LM193:
 1920 07ac 8091 0000 		lds r24,uxSchedulerSuspended
 1921 07b0 8823      		tst r24
 1922 07b2 01F0      		breq .L110
 1923               	.L112:
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1925               	.LM194:
 1926 07b4 80E0      		ldi r24,0
 1927 07b6 00C0      		rjmp .L111
 1928               	.L110:
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 1930               	.LM195:
 1931 07b8 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1932 07bc 8823      		tst r24
 1933 07be 01F0      		breq .L112
 1934 07c0 F12C      		mov r15,__zero_reg__
 1935               	.LBB36:
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1937               	.LM196:
 1938 07c2 39E0      		ldi r19,lo8(9)
 1939 07c4 E32E      		mov r14,r19
 1940               	.L113:
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1942               	.LM197:
 1943 07c6 8091 0000 		lds r24,xPendingReadyList
 1944 07ca 8111      		cpse r24,__zero_reg__
 1945 07cc 00C0      		rjmp .L116
 1946               	.L120:
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1948               	.LM198:
 1949 07ce 8091 0000 		lds r24,uxMissedTicks
 1950 07d2 8111      		cpse r24,__zero_reg__
 1951 07d4 00C0      		rjmp .L123
 1952 07d6 00C0      		rjmp .L118
 1953               	.L116:
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1955               	.LM199:
 1956 07d8 E091 0000 		lds r30,xPendingReadyList+5
 1957 07dc F091 0000 		lds r31,xPendingReadyList+5+1
 1958 07e0 C681      		ldd r28,Z+6
 1959 07e2 D781      		ldd r29,Z+7
 1960 07e4 2097      		sbiw r28,0
 1961 07e6 01F0      		breq .L120
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1963               	.LM200:
 1964 07e8 CE01      		movw r24,r28
 1965 07ea 0C96      		adiw r24,12
 1966 07ec 0E94 0000 		call vListRemove
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1968               	.LM201:
 1969 07f0 8E01      		movw r16,r28
 1970 07f2 0E5F      		subi r16,-2
 1971 07f4 1F4F      		sbci r17,-1
 1972 07f6 C801      		movw r24,r16
 1973 07f8 0E94 0000 		call vListRemove
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1975               	.LM202:
 1976 07fc 8E89      		ldd r24,Y+22
 1977 07fe 9091 0000 		lds r25,uxTopReadyPriority
 1978 0802 9817      		cp r25,r24
 1979 0804 00F4      		brsh .L114
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1981               	.LM203:
 1982 0806 8093 0000 		sts uxTopReadyPriority,r24
 1983               	.L114:
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1985               	.LM204:
 1986 080a E89E      		mul r14,r24
 1987 080c C001      		movw r24,r0
 1988 080e 1124      		clr __zero_reg__
 1989 0810 B801      		movw r22,r16
 1990 0812 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1991 0814 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1992 0816 0E94 0000 		call vListInsertEnd
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1994               	.LM205:
 1995 081a E091 0000 		lds r30,pxCurrentTCB
 1996 081e F091 0000 		lds r31,pxCurrentTCB+1
 1997 0822 9E89      		ldd r25,Y+22
 1998 0824 8689      		ldd r24,Z+22
 1999 0826 9817      		cp r25,r24
 2000 0828 00F0      		brlo .L113
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 2002               	.LM206:
 2003 082a FF24      		clr r15
 2004 082c F394      		inc r15
 2005 082e 00C0      		rjmp .L113
 2006               	.L118:
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2008               	.LM207:
 2009 0830 81E0      		ldi r24,lo8(1)
 2010 0832 F812      		cpse r15,r24
 2011 0834 00C0      		rjmp .L132
 2012 0836 00C0      		rjmp .L121
 2013               	.L123:
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 2015               	.LM208:
 2016 0838 8091 0000 		lds r24,uxMissedTicks
 2017 083c 8823      		tst r24
 2018 083e 01F0      		breq .L118
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
 2020               	.LM209:
 2021 0840 0E94 0000 		call vTaskIncrementTick
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
 2023               	.LM210:
 2024 0844 8091 0000 		lds r24,uxMissedTicks
 2025 0848 8150      		subi r24,lo8(-(-1))
 2026 084a 8093 0000 		sts uxMissedTicks,r24
 2027 084e 00C0      		rjmp .L123
 2028               	.L132:
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2030               	.LM211:
 2031 0850 8091 0000 		lds r24,xMissedYield
 2032 0854 8130      		cpi r24,lo8(1)
 2033 0856 01F0      		breq .+2
 2034 0858 00C0      		rjmp .L112
 2035               	.L121:
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
 2037               	.LM212:
 2038 085a 1092 0000 		sts xMissedYield,__zero_reg__
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2040               	.LM213:
 2041 085e 0E94 0000 		call vPortYield
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 2043               	.LM214:
 2044 0862 81E0      		ldi r24,lo8(1)
 2045               	.L111:
 2046               	.LBE36:
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 2048               	.LM215:
 2049               	/* #APP */
 2050               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2051 0864 0F90      		pop		__tmp_reg__
 2052               	 ;  0 "" 2
 2053               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2054 0866 0FBE      		out		__SREG__, __tmp_reg__
 2055               	 ;  0 "" 2
 2056               	/* epilogue start */
1151:../../freeRtos/Source/tasks.c **** }
 2058               	.LM216:
 2059               	/* #NOAPP */
 2060 0868 DF91      		pop r29
 2061 086a CF91      		pop r28
 2062 086c 1F91      		pop r17
 2063 086e 0F91      		pop r16
 2064 0870 FF90      		pop r15
 2065 0872 EF90      		pop r14
 2066 0874 0895      		ret
 2075               	.Lscope18:
 2077               		.stabd	78,0,0
 2081               	.global	vTaskDelayUntil
 2083               	vTaskDelayUntil:
 2084               		.stabd	46,0,0
 602:../../freeRtos/Source/tasks.c **** 	{
 2086               	.LM217:
 2087               	.LFBB19:
 2088 0876 0F93      		push r16
 2089 0878 1F93      		push r17
 2090 087a CF93      		push r28
 2091 087c DF93      		push r29
 2092               	/* prologue: function */
 2093               	/* frame size = 0 */
 2094               	/* stack size = 4 */
 2095               	.L__stack_usage = 4
 2096 087e 8C01      		movw r16,r24
 2097 0880 EB01      		movw r28,r22
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2099               	.LM218:
 2100 0882 0E94 0000 		call vTaskSuspendAll
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 2102               	.LM219:
 2103 0886 F801      		movw r30,r16
 2104 0888 2081      		ld r18,Z
 2105 088a 3181      		ldd r19,Z+1
 2106 088c C20F      		add r28,r18
 2107 088e D31F      		adc r29,r19
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 2109               	.LM220:
 2110 0890 8091 0000 		lds r24,xTickCount
 2111 0894 9091 0000 		lds r25,xTickCount+1
 2112 0898 8217      		cp r24,r18
 2113 089a 9307      		cpc r25,r19
 2114 089c 00F4      		brsh .L134
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 2116               	.LM221:
 2117 089e C217      		cp r28,r18
 2118 08a0 D307      		cpc r29,r19
 2119 08a2 00F4      		brsh .L141
 2120 08a4 00C0      		rjmp .L149
 2121               	.L134:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2123               	.LM222:
 2124 08a6 C217      		cp r28,r18
 2125 08a8 D307      		cpc r29,r19
 2126 08aa 00F0      		brlo .L142
 2127               	.L149:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2129               	.LM223:
 2130 08ac 8091 0000 		lds r24,xTickCount
 2131 08b0 9091 0000 		lds r25,xTickCount+1
 2132 08b4 21E0      		ldi r18,lo8(1)
 2133 08b6 8C17      		cp r24,r28
 2134 08b8 9D07      		cpc r25,r29
 2135 08ba 00F0      		brlo .L135
 2136               	.L141:
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 2138               	.LM224:
 2139 08bc 20E0      		ldi r18,0
 2140 08be 00C0      		rjmp .L135
 2141               	.L142:
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 2143               	.LM225:
 2144 08c0 21E0      		ldi r18,lo8(1)
 2145               	.L135:
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 2147               	.LM226:
 2148 08c2 F801      		movw r30,r16
 2149 08c4 D183      		std Z+1,r29
 2150 08c6 C083      		st Z,r28
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 2152               	.LM227:
 2153 08c8 2223      		tst r18
 2154 08ca 01F0      		breq .L138
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2156               	.LM228:
 2157 08cc 8091 0000 		lds r24,pxCurrentTCB
 2158 08d0 9091 0000 		lds r25,pxCurrentTCB+1
 2159 08d4 0296      		adiw r24,2
 2160 08d6 0E94 0000 		call vListRemove
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2162               	.LM229:
 2163 08da E091 0000 		lds r30,pxCurrentTCB
 2164 08de F091 0000 		lds r31,pxCurrentTCB+1
 2165 08e2 D383      		std Z+3,r29
 2166 08e4 C283      		std Z+2,r28
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2168               	.LM230:
 2169 08e6 8091 0000 		lds r24,xTickCount
 2170 08ea 9091 0000 		lds r25,xTickCount+1
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2172               	.LM231:
 2173 08ee 6091 0000 		lds r22,pxCurrentTCB
 2174 08f2 7091 0000 		lds r23,pxCurrentTCB+1
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2176               	.LM232:
 2177 08f6 C817      		cp r28,r24
 2178 08f8 D907      		cpc r29,r25
 2179 08fa 00F4      		brsh .L139
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2181               	.LM233:
 2182 08fc 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2183 0900 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2184 0904 00C0      		rjmp .L147
 2185               	.L139:
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2187               	.LM234:
 2188 0906 8091 0000 		lds r24,pxDelayedTaskList
 2189 090a 9091 0000 		lds r25,pxDelayedTaskList+1
 2190               	.L147:
 2191 090e 6E5F      		subi r22,-2
 2192 0910 7F4F      		sbci r23,-1
 2193 0912 0E94 0000 		call vListInsert
 2194               	.L138:
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 2196               	.LM235:
 2197 0916 0E94 0000 		call xTaskResumeAll
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2199               	.LM236:
 2200 091a 8111      		cpse r24,__zero_reg__
 2201 091c 00C0      		rjmp .L133
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2203               	.LM237:
 2204 091e 0E94 0000 		call vPortYield
 2205               	.L133:
 2206               	/* epilogue start */
 671:../../freeRtos/Source/tasks.c **** 	}
 2208               	.LM238:
 2209 0922 DF91      		pop r29
 2210 0924 CF91      		pop r28
 2211 0926 1F91      		pop r17
 2212 0928 0F91      		pop r16
 2213 092a 0895      		ret
 2219               	.Lscope19:
 2221               		.stabd	78,0,0
 2224               	.global	vTaskDelay
 2226               	vTaskDelay:
 2227               		.stabd	46,0,0
 679:../../freeRtos/Source/tasks.c **** 	{
 2229               	.LM239:
 2230               	.LFBB20:
 2231 092c 0F93      		push r16
 2232 092e 1F93      		push r17
 2233 0930 CF93      		push r28
 2234 0932 DF93      		push r29
 2235               	/* prologue: function */
 2236               	/* frame size = 0 */
 2237               	/* stack size = 4 */
 2238               	.L__stack_usage = 4
 2239 0934 8C01      		movw r16,r24
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 2241               	.LM240:
 2242 0936 0097      		sbiw r24,0
 2243 0938 01F4      		brne .L151
 2244               	.L155:
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2246               	.LM241:
 2247 093a 0E94 0000 		call vPortYield
 2248 093e 00C0      		rjmp .L150
 2249               	.L151:
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 2251               	.LM242:
 2252 0940 0E94 0000 		call vTaskSuspendAll
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 2254               	.LM243:
 2255 0944 C091 0000 		lds r28,xTickCount
 2256 0948 D091 0000 		lds r29,xTickCount+1
 2257 094c C00F      		add r28,r16
 2258 094e D11F      		adc r29,r17
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2260               	.LM244:
 2261 0950 8091 0000 		lds r24,pxCurrentTCB
 2262 0954 9091 0000 		lds r25,pxCurrentTCB+1
 2263 0958 0296      		adiw r24,2
 2264 095a 0E94 0000 		call vListRemove
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2266               	.LM245:
 2267 095e E091 0000 		lds r30,pxCurrentTCB
 2268 0962 F091 0000 		lds r31,pxCurrentTCB+1
 2269 0966 D383      		std Z+3,r29
 2270 0968 C283      		std Z+2,r28
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2272               	.LM246:
 2273 096a 8091 0000 		lds r24,xTickCount
 2274 096e 9091 0000 		lds r25,xTickCount+1
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2276               	.LM247:
 2277 0972 6091 0000 		lds r22,pxCurrentTCB
 2278 0976 7091 0000 		lds r23,pxCurrentTCB+1
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2280               	.LM248:
 2281 097a C817      		cp r28,r24
 2282 097c D907      		cpc r29,r25
 2283 097e 00F4      		brsh .L153
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2285               	.LM249:
 2286 0980 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2287 0984 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2288 0988 00C0      		rjmp .L159
 2289               	.L153:
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2291               	.LM250:
 2292 098a 8091 0000 		lds r24,pxDelayedTaskList
 2293 098e 9091 0000 		lds r25,pxDelayedTaskList+1
 2294               	.L159:
 2295 0992 6E5F      		subi r22,-2
 2296 0994 7F4F      		sbci r23,-1
 2297 0996 0E94 0000 		call vListInsert
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 2299               	.LM251:
 2300 099a 0E94 0000 		call xTaskResumeAll
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2302               	.LM252:
 2303 099e 8823      		tst r24
 2304 09a0 01F0      		breq .L155
 2305               	.L150:
 2306               	/* epilogue start */
 732:../../freeRtos/Source/tasks.c **** 	}
 2308               	.LM253:
 2309 09a2 DF91      		pop r29
 2310 09a4 CF91      		pop r28
 2311 09a6 1F91      		pop r17
 2312 09a8 0F91      		pop r16
 2313 09aa 0895      		ret
 2318               	.Lscope20:
 2320               		.stabd	78,0,0
 2321               		.section	.rodata.str1.1
 2322               	.LC2:
 2323 0017 0D0A 00   		.string	"\r\n"
 2324               		.text
 2327               	.global	vTaskList
 2329               	vTaskList:
 2330               		.stabd	46,0,0
1190:../../freeRtos/Source/tasks.c **** 	{
 2332               	.LM254:
 2333               	.LFBB21:
 2334 09ac 0F93      		push r16
 2335 09ae 1F93      		push r17
 2336 09b0 CF93      		push r28
 2337 09b2 DF93      		push r29
 2338               	/* prologue: function */
 2339               	/* frame size = 0 */
 2340               	/* stack size = 4 */
 2341               	.L__stack_usage = 4
 2342 09b4 EC01      		movw r28,r24
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2344               	.LM255:
 2345 09b6 0E94 0000 		call vTaskSuspendAll
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 2347               	.LM256:
 2348 09ba 1882      		st Y,__zero_reg__
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 2350               	.LM257:
 2351 09bc 60E0      		ldi r22,lo8(.LC2)
 2352 09be 70E0      		ldi r23,hi8(.LC2)
 2353 09c0 CE01      		movw r24,r28
 2354 09c2 0E94 0000 		call strcat
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
 2356               	.LM258:
 2357 09c6 1091 0000 		lds r17,uxTopUsedPriority
 2358 09ca 1F5F      		subi r17,lo8(-(1))
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 2360               	.LM259:
 2361 09cc 09E0      		ldi r16,lo8(9)
 2362               	.L163:
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
 2364               	.LM260:
 2365 09ce 1150      		subi r17,lo8(-(-1))
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 2367               	.LM261:
 2368 09d0 019F      		mul r16,r17
 2369 09d2 B001      		movw r22,r0
 2370 09d4 1124      		clr __zero_reg__
 2371 09d6 6050      		subi r22,lo8(-(pxReadyTasksLists))
 2372 09d8 7040      		sbci r23,hi8(-(pxReadyTasksLists))
 2373 09da FB01      		movw r30,r22
 2374 09dc 8081      		ld r24,Z
 2375 09de 8823      		tst r24
 2376 09e0 01F0      		breq .L161
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 2378               	.LM262:
 2379 09e2 42E5      		ldi r20,lo8(82)
 2380 09e4 CE01      		movw r24,r28
 2381 09e6 0E94 0000 		call prvListTaskWithinSingleList
 2382               	.L161:
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 2384               	.LM263:
 2385 09ea 1111      		cpse r17,__zero_reg__
 2386 09ec 00C0      		rjmp .L163
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 2388               	.LM264:
 2389 09ee E091 0000 		lds r30,pxDelayedTaskList
 2390 09f2 F091 0000 		lds r31,pxDelayedTaskList+1
 2391 09f6 8081      		ld r24,Z
 2392 09f8 8823      		tst r24
 2393 09fa 01F0      		breq .L164
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 2395               	.LM265:
 2396 09fc 6091 0000 		lds r22,pxDelayedTaskList
 2397 0a00 7091 0000 		lds r23,pxDelayedTaskList+1
 2398 0a04 42E4      		ldi r20,lo8(66)
 2399 0a06 CE01      		movw r24,r28
 2400 0a08 0E94 0000 		call prvListTaskWithinSingleList
 2401               	.L164:
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 2403               	.LM266:
 2404 0a0c E091 0000 		lds r30,pxOverflowDelayedTaskList
 2405 0a10 F091 0000 		lds r31,pxOverflowDelayedTaskList+1
 2406 0a14 8081      		ld r24,Z
 2407 0a16 8823      		tst r24
 2408 0a18 01F0      		breq .L165
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 2410               	.LM267:
 2411 0a1a 6091 0000 		lds r22,pxOverflowDelayedTaskList
 2412 0a1e 7091 0000 		lds r23,pxOverflowDelayedTaskList+1
 2413 0a22 42E4      		ldi r20,lo8(66)
 2414 0a24 CE01      		movw r24,r28
 2415 0a26 0E94 0000 		call prvListTaskWithinSingleList
 2416               	.L165:
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 2418               	.LM268:
 2419 0a2a 8091 0000 		lds r24,xSuspendedTaskList
 2420 0a2e 8823      		tst r24
 2421 0a30 01F0      		breq .L166
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 2423               	.LM269:
 2424 0a32 43E5      		ldi r20,lo8(83)
 2425 0a34 60E0      		ldi r22,lo8(xSuspendedTaskList)
 2426 0a36 70E0      		ldi r23,hi8(xSuspendedTaskList)
 2427 0a38 CE01      		movw r24,r28
 2428 0a3a 0E94 0000 		call prvListTaskWithinSingleList
 2429               	.L166:
 2430               	/* epilogue start */
1245:../../freeRtos/Source/tasks.c **** 	}
 2432               	.LM270:
 2433 0a3e DF91      		pop r29
 2434 0a40 CF91      		pop r28
 2435 0a42 1F91      		pop r17
 2436 0a44 0F91      		pop r16
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
 2438               	.LM271:
 2439 0a46 0C94 0000 		jmp xTaskResumeAll
 2444               	.Lscope21:
 2446               		.stabd	78,0,0
 2448               	.global	vTaskSwitchContext
 2450               	vTaskSwitchContext:
 2451               		.stabd	46,0,0
1554:../../freeRtos/Source/tasks.c **** {
 2453               	.LM272:
 2454               	.LFBB22:
 2455               	/* prologue: function */
 2456               	/* frame size = 0 */
 2457               	/* stack size = 0 */
 2458               	.L__stack_usage = 0
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2460               	.LM273:
 2461 0a4a 8091 0000 		lds r24,uxSchedulerSuspended
 2462 0a4e 8111      		cpse r24,__zero_reg__
 2463 0a50 00C0      		rjmp .L180
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2465               	.LM274:
 2466 0a52 99E0      		ldi r25,lo8(9)
 2467 0a54 00C0      		rjmp .L181
 2468               	.L180:
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2470               	.LM275:
 2471 0a56 81E0      		ldi r24,lo8(1)
 2472 0a58 8093 0000 		sts xMissedYield,r24
1560:../../freeRtos/Source/tasks.c **** 		return;
 2474               	.LM276:
 2475 0a5c 0895      		ret
 2476               	.L181:
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2478               	.LM277:
 2479 0a5e E091 0000 		lds r30,uxTopReadyPriority
 2480 0a62 9E9F      		mul r25,r30
 2481 0a64 F001      		movw r30,r0
 2482 0a66 1124      		clr __zero_reg__
 2483 0a68 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2484 0a6a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2485 0a6c 8081      		ld r24,Z
 2486 0a6e 8111      		cpse r24,__zero_reg__
 2487 0a70 00C0      		rjmp .L189
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
 2489               	.LM278:
 2490 0a72 8091 0000 		lds r24,uxTopReadyPriority
 2491 0a76 8150      		subi r24,lo8(-(-1))
 2492 0a78 8093 0000 		sts uxTopReadyPriority,r24
 2493 0a7c 00C0      		rjmp .L181
 2494               	.L189:
 2495               	.LBB37:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2497               	.LM279:
 2498 0a7e E091 0000 		lds r30,uxTopReadyPriority
 2499 0a82 89E0      		ldi r24,lo8(9)
 2500 0a84 E89F      		mul r30,r24
 2501 0a86 F001      		movw r30,r0
 2502 0a88 1124      		clr __zero_reg__
 2503 0a8a E050      		subi r30,lo8(-(pxReadyTasksLists))
 2504 0a8c F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2505 0a8e A181      		ldd r26,Z+1
 2506 0a90 B281      		ldd r27,Z+2
 2507 0a92 1296      		adiw r26,2
 2508 0a94 0D90      		ld __tmp_reg__,X+
 2509 0a96 BC91      		ld r27,X
 2510 0a98 A02D      		mov r26,__tmp_reg__
 2511 0a9a B283      		std Z+2,r27
 2512 0a9c A183      		std Z+1,r26
 2513 0a9e CF01      		movw r24,r30
 2514 0aa0 0396      		adiw r24,3
 2515 0aa2 A817      		cp r26,r24
 2516 0aa4 B907      		cpc r27,r25
 2517 0aa6 01F4      		brne .L184
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2519               	.LM280:
 2520 0aa8 1296      		adiw r26,2
 2521 0aaa 8D91      		ld r24,X+
 2522 0aac 9C91      		ld r25,X
 2523 0aae 1397      		sbiw r26,2+1
 2524 0ab0 9283      		std Z+2,r25
 2525 0ab2 8183      		std Z+1,r24
 2526               	.L184:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2528               	.LM281:
 2529 0ab4 0180      		ldd __tmp_reg__,Z+1
 2530 0ab6 F281      		ldd r31,Z+2
 2531 0ab8 E02D      		mov r30,__tmp_reg__
 2532 0aba 8681      		ldd r24,Z+6
 2533 0abc 9781      		ldd r25,Z+7
 2534 0abe 9093 0000 		sts pxCurrentTCB+1,r25
 2535 0ac2 8093 0000 		sts pxCurrentTCB,r24
 2536               	.LBE37:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2538               	.LM282:
 2539 0ac6 8091 0000 		lds r24,xTracing
 2540 0aca 8823      		tst r24
 2541 0acc 01F4      		brne .+2
 2542 0ace 00C0      		rjmp .L179
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2544               	.LM283:
 2545 0ad0 E091 0000 		lds r30,pxCurrentTCB
 2546 0ad4 F091 0000 		lds r31,pxCurrentTCB+1
 2547 0ad8 9091 0000 		lds r25,uxPreviousTask
 2548 0adc 83A1      		ldd r24,Z+35
 2549 0ade 9817      		cp r25,r24
 2550 0ae0 01F4      		brne .+2
 2551 0ae2 00C0      		rjmp .L179
 2552 0ae4 8091 0000 		lds r24,pcTraceBuffer
 2553 0ae8 9091 0000 		lds r25,pcTraceBuffer+1
 2554 0aec 0896      		adiw r24,8
 2555 0aee 2091 0000 		lds r18,pcTraceBufferEnd
 2556 0af2 3091 0000 		lds r19,pcTraceBufferEnd+1
 2557 0af6 8217      		cp r24,r18
 2558 0af8 9307      		cpc r25,r19
 2559 0afa 00F4      		brsh .L185
 2560 0afc E091 0000 		lds r30,pxCurrentTCB
 2561 0b00 F091 0000 		lds r31,pxCurrentTCB+1
 2562 0b04 83A1      		ldd r24,Z+35
 2563 0b06 8093 0000 		sts uxPreviousTask,r24
 2564 0b0a E091 0000 		lds r30,pcTraceBuffer
 2565 0b0e F091 0000 		lds r31,pcTraceBuffer+1
 2566 0b12 4091 0000 		lds r20,xTickCount
 2567 0b16 5091 0000 		lds r21,xTickCount+1
 2568 0b1a 60E0      		ldi r22,0
 2569 0b1c 70E0      		ldi r23,0
 2570 0b1e 4083      		st Z,r20
 2571 0b20 5183      		std Z+1,r21
 2572 0b22 6283      		std Z+2,r22
 2573 0b24 7383      		std Z+3,r23
 2574 0b26 2091 0000 		lds r18,pcTraceBuffer
 2575 0b2a 3091 0000 		lds r19,pcTraceBuffer+1
 2576 0b2e 2C5F      		subi r18,-4
 2577 0b30 3F4F      		sbci r19,-1
 2578 0b32 3093 0000 		sts pcTraceBuffer+1,r19
 2579 0b36 2093 0000 		sts pcTraceBuffer,r18
 2580 0b3a E091 0000 		lds r30,pcTraceBuffer
 2581 0b3e F091 0000 		lds r31,pcTraceBuffer+1
 2582 0b42 90E0      		ldi r25,0
 2583 0b44 A0E0      		ldi r26,0
 2584 0b46 B0E0      		ldi r27,0
 2585 0b48 8083      		st Z,r24
 2586 0b4a 9183      		std Z+1,r25
 2587 0b4c A283      		std Z+2,r26
 2588 0b4e B383      		std Z+3,r27
 2589 0b50 8091 0000 		lds r24,pcTraceBuffer
 2590 0b54 9091 0000 		lds r25,pcTraceBuffer+1
 2591 0b58 0496      		adiw r24,4
 2592 0b5a 9093 0000 		sts pcTraceBuffer+1,r25
 2593 0b5e 8093 0000 		sts pcTraceBuffer,r24
 2594 0b62 0895      		ret
 2595               	.L185:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2597               	.LM284:
 2598 0b64 1092 0000 		sts xTracing,__zero_reg__
 2599               	.L179:
 2600 0b68 0895      		ret
 2605               	.Lscope22:
 2607               		.stabd	78,0,0
 2611               	.global	vTaskPlaceOnEventList
 2613               	vTaskPlaceOnEventList:
 2614               		.stabd	46,0,0
1598:../../freeRtos/Source/tasks.c **** {
 2616               	.LM285:
 2617               	.LFBB23:
 2618 0b6a CF93      		push r28
 2619 0b6c DF93      		push r29
 2620               	/* prologue: function */
 2621               	/* frame size = 0 */
 2622               	/* stack size = 2 */
 2623               	.L__stack_usage = 2
 2624 0b6e EB01      		movw r28,r22
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2626               	.LM286:
 2627 0b70 6091 0000 		lds r22,pxCurrentTCB
 2628 0b74 7091 0000 		lds r23,pxCurrentTCB+1
 2629 0b78 645F      		subi r22,-12
 2630 0b7a 7F4F      		sbci r23,-1
 2631 0b7c 0E94 0000 		call vListInsert
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2633               	.LM287:
 2634 0b80 8091 0000 		lds r24,pxCurrentTCB
 2635 0b84 9091 0000 		lds r25,pxCurrentTCB+1
 2636 0b88 0296      		adiw r24,2
 2637 0b8a 0E94 0000 		call vListRemove
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2639               	.LM288:
 2640 0b8e CF3F      		cpi r28,-1
 2641 0b90 8FEF      		ldi r24,-1
 2642 0b92 D807      		cpc r29,r24
 2643 0b94 01F4      		brne .L191
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2645               	.LM289:
 2646 0b96 6091 0000 		lds r22,pxCurrentTCB
 2647 0b9a 7091 0000 		lds r23,pxCurrentTCB+1
 2648 0b9e 6E5F      		subi r22,-2
 2649 0ba0 7F4F      		sbci r23,-1
 2650 0ba2 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2651 0ba4 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2652               	/* epilogue start */
1664:../../freeRtos/Source/tasks.c **** }
 2654               	.LM290:
 2655 0ba6 DF91      		pop r29
 2656 0ba8 CF91      		pop r28
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2658               	.LM291:
 2659 0baa 0C94 0000 		jmp vListInsertEnd
 2660               	.L191:
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2662               	.LM292:
 2663 0bae 8091 0000 		lds r24,xTickCount
 2664 0bb2 9091 0000 		lds r25,xTickCount+1
 2665 0bb6 8C0F      		add r24,r28
 2666 0bb8 9D1F      		adc r25,r29
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2668               	.LM293:
 2669 0bba E091 0000 		lds r30,pxCurrentTCB
 2670 0bbe F091 0000 		lds r31,pxCurrentTCB+1
 2671 0bc2 9383      		std Z+3,r25
 2672 0bc4 8283      		std Z+2,r24
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2674               	.LM294:
 2675 0bc6 2091 0000 		lds r18,xTickCount
 2676 0bca 3091 0000 		lds r19,xTickCount+1
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2678               	.LM295:
 2679 0bce 6091 0000 		lds r22,pxCurrentTCB
 2680 0bd2 7091 0000 		lds r23,pxCurrentTCB+1
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2682               	.LM296:
 2683 0bd6 8217      		cp r24,r18
 2684 0bd8 9307      		cpc r25,r19
 2685 0bda 00F4      		brsh .L192
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2687               	.LM297:
 2688 0bdc 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2689 0be0 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2690 0be4 00C0      		rjmp .L193
 2691               	.L192:
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2693               	.LM298:
 2694 0be6 8091 0000 		lds r24,pxDelayedTaskList
 2695 0bea 9091 0000 		lds r25,pxDelayedTaskList+1
 2696               	.L193:
 2697 0bee 6E5F      		subi r22,-2
 2698 0bf0 7F4F      		sbci r23,-1
 2699               	/* epilogue start */
1664:../../freeRtos/Source/tasks.c **** }
 2701               	.LM299:
 2702 0bf2 DF91      		pop r29
 2703 0bf4 CF91      		pop r28
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2705               	.LM300:
 2706 0bf6 0C94 0000 		jmp vListInsert
 2711               	.Lscope23:
 2713               		.stabd	78,0,0
 2716               	.global	xTaskRemoveFromEventList
 2718               	xTaskRemoveFromEventList:
 2719               		.stabd	46,0,0
1668:../../freeRtos/Source/tasks.c **** {
 2721               	.LM301:
 2722               	.LFBB24:
 2723 0bfa 0F93      		push r16
 2724 0bfc 1F93      		push r17
 2725 0bfe CF93      		push r28
 2726 0c00 DF93      		push r29
 2727               	/* prologue: function */
 2728               	/* frame size = 0 */
 2729               	/* stack size = 4 */
 2730               	.L__stack_usage = 4
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2732               	.LM302:
 2733 0c02 DC01      		movw r26,r24
 2734 0c04 2C91      		ld r18,X
 2735 0c06 2223      		tst r18
 2736 0c08 01F0      		breq .L200
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2738               	.LM303:
 2739 0c0a 1596      		adiw r26,5
 2740 0c0c ED91      		ld r30,X+
 2741 0c0e FC91      		ld r31,X
 2742 0c10 1697      		sbiw r26,5+1
 2743 0c12 C681      		ldd r28,Z+6
 2744 0c14 D781      		ldd r29,Z+7
 2745 0c16 00C0      		rjmp .L195
 2746               	.L200:
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2748               	.LM304:
 2749 0c18 C0E0      		ldi r28,0
 2750 0c1a D0E0      		ldi r29,0
 2751               	.L195:
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2753               	.LM305:
 2754 0c1c 8E01      		movw r16,r28
 2755 0c1e 045F      		subi r16,-12
 2756 0c20 1F4F      		sbci r17,-1
 2757 0c22 C801      		movw r24,r16
 2758 0c24 0E94 0000 		call vListRemove
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2760               	.LM306:
 2761 0c28 8091 0000 		lds r24,uxSchedulerSuspended
 2762 0c2c 8111      		cpse r24,__zero_reg__
 2763 0c2e 00C0      		rjmp .L196
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2765               	.LM307:
 2766 0c30 8E01      		movw r16,r28
 2767 0c32 0E5F      		subi r16,-2
 2768 0c34 1F4F      		sbci r17,-1
 2769 0c36 C801      		movw r24,r16
 2770 0c38 0E94 0000 		call vListRemove
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2772               	.LM308:
 2773 0c3c 8E89      		ldd r24,Y+22
 2774 0c3e 9091 0000 		lds r25,uxTopReadyPriority
 2775 0c42 9817      		cp r25,r24
 2776 0c44 00F4      		brsh .L197
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2778               	.LM309:
 2779 0c46 8093 0000 		sts uxTopReadyPriority,r24
 2780               	.L197:
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2782               	.LM310:
 2783 0c4a B9E0      		ldi r27,lo8(9)
 2784 0c4c 8B9F      		mul r24,r27
 2785 0c4e C001      		movw r24,r0
 2786 0c50 1124      		clr __zero_reg__
 2787 0c52 B801      		movw r22,r16
 2788 0c54 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2789 0c56 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2790 0c58 00C0      		rjmp .L201
 2791               	.L196:
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2793               	.LM311:
 2794 0c5a B801      		movw r22,r16
 2795 0c5c 80E0      		ldi r24,lo8(xPendingReadyList)
 2796 0c5e 90E0      		ldi r25,hi8(xPendingReadyList)
 2797               	.L201:
 2798 0c60 0E94 0000 		call vListInsertEnd
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2800               	.LM312:
 2801 0c64 E091 0000 		lds r30,pxCurrentTCB
 2802 0c68 F091 0000 		lds r31,pxCurrentTCB+1
 2803 0c6c 81E0      		ldi r24,lo8(1)
 2804 0c6e 2E89      		ldd r18,Y+22
 2805 0c70 9689      		ldd r25,Z+22
 2806 0c72 2917      		cp r18,r25
 2807 0c74 00F4      		brsh .L199
 2808 0c76 80E0      		ldi r24,0
 2809               	.L199:
 2810               	/* epilogue start */
1711:../../freeRtos/Source/tasks.c **** }
 2812               	.LM313:
 2813 0c78 DF91      		pop r29
 2814 0c7a CF91      		pop r28
 2815 0c7c 1F91      		pop r17
 2816 0c7e 0F91      		pop r16
 2817 0c80 0895      		ret
 2822               	.Lscope24:
 2824               		.stabd	78,0,0
 2827               	.global	vTaskSetTimeOutState
 2829               	vTaskSetTimeOutState:
 2830               		.stabd	46,0,0
1715:../../freeRtos/Source/tasks.c **** {
 2832               	.LM314:
 2833               	.LFBB25:
 2834               	/* prologue: function */
 2835               	/* frame size = 0 */
 2836               	/* stack size = 0 */
 2837               	.L__stack_usage = 0
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2839               	.LM315:
 2840 0c82 2091 0000 		lds r18,xNumOfOverflows
 2841 0c86 FC01      		movw r30,r24
 2842 0c88 2083      		st Z,r18
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2844               	.LM316:
 2845 0c8a 2091 0000 		lds r18,xTickCount
 2846 0c8e 3091 0000 		lds r19,xTickCount+1
 2847 0c92 3283      		std Z+2,r19
 2848 0c94 2183      		std Z+1,r18
 2849 0c96 0895      		ret
 2851               	.Lscope25:
 2853               		.stabd	78,0,0
 2857               	.global	xTaskCheckForTimeOut
 2859               	xTaskCheckForTimeOut:
 2860               		.stabd	46,0,0
1722:../../freeRtos/Source/tasks.c **** {
 2862               	.LM317:
 2863               	.LFBB26:
 2864               	/* prologue: function */
 2865               	/* frame size = 0 */
 2866               	/* stack size = 0 */
 2867               	.L__stack_usage = 0
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 2869               	.LM318:
 2870               	/* #APP */
 2871               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 2872 0c98 0FB6      		in		__tmp_reg__, __SREG__
 2873               	 ;  0 "" 2
 2874               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 2875 0c9a F894      		cli
 2876               	 ;  0 "" 2
 2877               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 2878 0c9c 0F92      		push	__tmp_reg__
 2879               	 ;  0 "" 2
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2881               	.LM319:
 2882               	/* #NOAPP */
 2883 0c9e DB01      		movw r26,r22
 2884 0ca0 4D91      		ld r20,X+
 2885 0ca2 5C91      		ld r21,X
 2886 0ca4 4F3F      		cpi r20,-1
 2887 0ca6 BFEF      		ldi r27,-1
 2888 0ca8 5B07      		cpc r21,r27
 2889 0caa 01F0      		breq .L206
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2891               	.LM320:
 2892 0cac F091 0000 		lds r31,xNumOfOverflows
 2893 0cb0 DC01      		movw r26,r24
 2894 0cb2 EC91      		ld r30,X
 2895 0cb4 1196      		adiw r26,1
 2896 0cb6 2D91      		ld r18,X+
 2897 0cb8 3C91      		ld r19,X
 2898 0cba 1297      		sbiw r26,1+1
 2899 0cbc FE17      		cp r31,r30
 2900 0cbe 01F0      		breq .L205
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2902               	.LM321:
 2903 0cc0 E091 0000 		lds r30,xTickCount
 2904 0cc4 F091 0000 		lds r31,xTickCount+1
 2905 0cc8 E217      		cp r30,r18
 2906 0cca F307      		cpc r31,r19
 2907 0ccc 00F4      		brsh .L208
 2908               	.L205:
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2910               	.LM322:
 2911 0cce E091 0000 		lds r30,xTickCount
 2912 0cd2 F091 0000 		lds r31,xTickCount+1
 2913 0cd6 E21B      		sub r30,r18
 2914 0cd8 F30B      		sbc r31,r19
 2915 0cda E417      		cp r30,r20
 2916 0cdc F507      		cpc r31,r21
 2917 0cde 00F4      		brsh .L208
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2919               	.LM323:
 2920 0ce0 E091 0000 		lds r30,xTickCount
 2921 0ce4 F091 0000 		lds r31,xTickCount+1
 2922 0ce8 2E1B      		sub r18,r30
 2923 0cea 3F0B      		sbc r19,r31
 2924 0cec 240F      		add r18,r20
 2925 0cee 351F      		adc r19,r21
 2926 0cf0 FB01      		movw r30,r22
 2927 0cf2 3183      		std Z+1,r19
 2928 0cf4 2083      		st Z,r18
1750:../../freeRtos/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2930               	.LM324:
 2931 0cf6 0E94 0000 		call vTaskSetTimeOutState
 2932               	.L206:
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
 2934               	.LM325:
 2935 0cfa 80E0      		ldi r24,0
 2936 0cfc 00C0      		rjmp .L204
 2937               	.L208:
1744:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
 2939               	.LM326:
 2940 0cfe 81E0      		ldi r24,lo8(1)
 2941               	.L204:
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 2943               	.LM327:
 2944               	/* #APP */
 2945               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 2946 0d00 0F90      		pop		__tmp_reg__
 2947               	 ;  0 "" 2
 2948               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 2949 0d02 0FBE      		out		__SREG__, __tmp_reg__
 2950               	 ;  0 "" 2
1761:../../freeRtos/Source/tasks.c **** }
 2952               	.LM328:
 2953               	/* #NOAPP */
 2954 0d04 0895      		ret
 2959               	.Lscope26:
 2961               		.stabd	78,0,0
 2963               	.global	vTaskMissedYield
 2965               	vTaskMissedYield:
 2966               		.stabd	46,0,0
1765:../../freeRtos/Source/tasks.c **** {
 2968               	.LM329:
 2969               	.LFBB27:
 2970               	/* prologue: function */
 2971               	/* frame size = 0 */
 2972               	/* stack size = 0 */
 2973               	.L__stack_usage = 0
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2975               	.LM330:
 2976 0d06 81E0      		ldi r24,lo8(1)
 2977 0d08 8093 0000 		sts xMissedYield,r24
 2978 0d0c 0895      		ret
 2980               	.Lscope27:
 2982               		.stabd	78,0,0
 2983               		.local	pcStatusString
 2984               		.comm	pcStatusString,50,1
 2985               		.data
 2988               	uxPreviousTask:
 2989 0000 FF        		.byte	-1
 2990               		.local	xTracing
 2991               		.comm	xTracing,1,1
 2992               		.local	pcTraceBufferEnd
 2993               		.comm	pcTraceBufferEnd,2,1
 2994               		.local	pcTraceBufferStart
 2995               		.comm	pcTraceBufferStart,2,1
 2996               		.local	pcTraceBuffer
 2997               		.comm	pcTraceBuffer,2,1
 2998               		.local	uxTaskNumber
 2999               		.comm	uxTaskNumber,1,1
 3000               		.local	xNumOfOverflows
 3001               		.comm	xNumOfOverflows,1,1
 3002               		.local	xMissedYield
 3003               		.comm	xMissedYield,1,1
 3004               		.local	uxMissedTicks
 3005               		.comm	uxMissedTicks,1,1
 3006               		.local	uxSchedulerSuspended
 3007               		.comm	uxSchedulerSuspended,1,1
 3008               		.local	xSchedulerRunning
 3009               		.comm	xSchedulerRunning,1,1
 3010               		.local	uxTopReadyPriority
 3011               		.comm	uxTopReadyPriority,1,1
 3012               		.local	uxTopUsedPriority
 3013               		.comm	uxTopUsedPriority,1,1
 3014               		.local	xTickCount
 3015               		.comm	xTickCount,2,1
 3016               		.local	uxCurrentNumberOfTasks
 3017               		.comm	uxCurrentNumberOfTasks,1,1
 3018               		.local	xSuspendedTaskList
 3019               		.comm	xSuspendedTaskList,9,1
 3020               		.local	xPendingReadyList
 3021               		.comm	xPendingReadyList,9,1
 3022               		.local	pxOverflowDelayedTaskList
 3023               		.comm	pxOverflowDelayedTaskList,2,1
 3024               		.local	pxDelayedTaskList
 3025               		.comm	pxDelayedTaskList,2,1
 3026               		.local	xDelayedTaskList2
 3027               		.comm	xDelayedTaskList2,9,1
 3028               		.local	xDelayedTaskList1
 3029               		.comm	xDelayedTaskList1,9,1
 3030               		.local	pxReadyTasksLists
 3031               		.comm	pxReadyTasksLists,27,1
 3032               	.global	pxCurrentTCB
 3033               		.section .bss
 3036               	pxCurrentTCB:
 3037 0000 0000      		.zero	2
 3062               		.text
 3064               	.Letext0:
 3065               		.ident	"GCC: (GNU) 4.8.2"
 3066               	.global __do_copy_data
 3067               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccezyPFf.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccezyPFf.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccezyPFf.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccezyPFf.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccezyPFf.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccezyPFf.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccezyPFf.s:157    .text:0000000000000000 prvIdleTask
     /tmp/ccezyPFf.s:184    .text:0000000000000006 prvListTaskWithinSingleList
                             .bss:0000000000000002 pcStatusString
     /tmp/ccezyPFf.s:416    .text:0000000000000152 xTaskGenericCreate
     /tmp/ccezyPFf.s:3015   .bss:0000000000000045 uxCurrentNumberOfTasks
     /tmp/ccezyPFf.s:3036   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccezyPFf.s:3029   .bss:000000000000006e pxReadyTasksLists
     /tmp/ccezyPFf.s:3027   .bss:0000000000000065 xDelayedTaskList1
     /tmp/ccezyPFf.s:3025   .bss:000000000000005c xDelayedTaskList2
     /tmp/ccezyPFf.s:3019   .bss:000000000000004f xPendingReadyList
     /tmp/ccezyPFf.s:3017   .bss:0000000000000046 xSuspendedTaskList
     /tmp/ccezyPFf.s:3023   .bss:000000000000005a pxDelayedTaskList
     /tmp/ccezyPFf.s:3021   .bss:0000000000000058 pxOverflowDelayedTaskList
     /tmp/ccezyPFf.s:3007   .bss:0000000000000040 xSchedulerRunning
     /tmp/ccezyPFf.s:3011   .bss:0000000000000042 uxTopUsedPriority
     /tmp/ccezyPFf.s:2997   .bss:000000000000003b uxTaskNumber
     /tmp/ccezyPFf.s:3009   .bss:0000000000000041 uxTopReadyPriority
     /tmp/ccezyPFf.s:776    .text:000000000000032e uxTaskPriorityGet
     /tmp/ccezyPFf.s:831    .text:000000000000034a vTaskPrioritySet
     /tmp/ccezyPFf.s:1005   .text:0000000000000408 vTaskSuspend
     /tmp/ccezyPFf.s:1119   .text:0000000000000482 xTaskIsTaskSuspended
     /tmp/ccezyPFf.s:1173   .text:00000000000004a6 vTaskResume
     /tmp/ccezyPFf.s:1283   .text:0000000000000520 xTaskResumeFromISR
     /tmp/ccezyPFf.s:3005   .bss:000000000000003f uxSchedulerSuspended
     /tmp/ccezyPFf.s:1386   .text:000000000000059e vTaskStartScheduler
     /tmp/ccezyPFf.s:3013   .bss:0000000000000043 xTickCount
     /tmp/ccezyPFf.s:1470   .text:0000000000000602 vTaskEndScheduler
     /tmp/ccezyPFf.s:1499   .text:000000000000060c vTaskSuspendAll
     /tmp/ccezyPFf.s:1521   .text:0000000000000618 xTaskGetTickCount
     /tmp/ccezyPFf.s:1570   .text:000000000000062c uxTaskGetNumberOfTasks
     /tmp/ccezyPFf.s:1594   .text:0000000000000632 vTaskStartTrace
     /tmp/ccezyPFf.s:2995   .bss:0000000000000039 pcTraceBuffer
     /tmp/ccezyPFf.s:2993   .bss:0000000000000037 pcTraceBufferStart
     /tmp/ccezyPFf.s:2991   .bss:0000000000000035 pcTraceBufferEnd
     /tmp/ccezyPFf.s:2984   .bss:0000000000000034 xTracing
     /tmp/ccezyPFf.s:1654   .text:0000000000000664 ulTaskEndTrace
     /tmp/ccezyPFf.s:1711   .text:0000000000000690 vTaskIncrementTick
     /tmp/ccezyPFf.s:2999   .bss:000000000000003c xNumOfOverflows
     /tmp/ccezyPFf.s:3003   .bss:000000000000003e uxMissedTicks
     /tmp/ccezyPFf.s:1885   .text:0000000000000790 xTaskResumeAll
     /tmp/ccezyPFf.s:3001   .bss:000000000000003d xMissedYield
     /tmp/ccezyPFf.s:2083   .text:0000000000000876 vTaskDelayUntil
     /tmp/ccezyPFf.s:2226   .text:000000000000092c vTaskDelay
     /tmp/ccezyPFf.s:2329   .text:00000000000009ac vTaskList
     /tmp/ccezyPFf.s:2450   .text:0000000000000a4a vTaskSwitchContext
     /tmp/ccezyPFf.s:2988   .data:0000000000000000 uxPreviousTask
     /tmp/ccezyPFf.s:2613   .text:0000000000000b6a vTaskPlaceOnEventList
     /tmp/ccezyPFf.s:2718   .text:0000000000000bfa xTaskRemoveFromEventList
     /tmp/ccezyPFf.s:2829   .text:0000000000000c82 vTaskSetTimeOutState
     /tmp/ccezyPFf.s:2859   .text:0000000000000c98 xTaskCheckForTimeOut
     /tmp/ccezyPFf.s:2965   .text:0000000000000d06 vTaskMissedYield

UNDEFINED SYMBOLS
vPortYield
sprintf
strcat
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vListInsert
__do_copy_data
__do_clear_bss
