   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 159               	prvCopyDataToQueue:
 160               		.stabd	46,0,0
   1:../../freeRtos/Source/queue.c **** /*
   2:../../freeRtos/Source/queue.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/queue.c **** 
   4:../../freeRtos/Source/queue.c ****     ***************************************************************************
   5:../../freeRtos/Source/queue.c ****     *                                                                         *
   6:../../freeRtos/Source/queue.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/queue.c ****     *                                                                         *
   8:../../freeRtos/Source/queue.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/queue.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/queue.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/queue.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/queue.c ****     *                                                                         *
  13:../../freeRtos/Source/queue.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/queue.c ****     *                                                                         *
  15:../../freeRtos/Source/queue.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/queue.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/queue.c ****     *                                                                         *
  18:../../freeRtos/Source/queue.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/queue.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/queue.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/queue.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/queue.c ****     *                                                                         *
  23:../../freeRtos/Source/queue.c ****     ***************************************************************************
  24:../../freeRtos/Source/queue.c **** 
  25:../../freeRtos/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/queue.c **** 
  27:../../freeRtos/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/queue.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/queue.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/queue.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/queue.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/queue.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/queue.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/queue.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/queue.c **** 
  42:../../freeRtos/Source/queue.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/queue.c **** 
  44:../../freeRtos/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/queue.c ****     contact details.
  46:../../freeRtos/Source/queue.c **** 
  47:../../freeRtos/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/queue.c ****     critical systems.
  49:../../freeRtos/Source/queue.c **** 
  50:../../freeRtos/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/queue.c ****     licensing and training services.
  52:../../freeRtos/Source/queue.c **** */
  53:../../freeRtos/Source/queue.c **** 
  54:../../freeRtos/Source/queue.c **** #include <stdlib.h>
  55:../../freeRtos/Source/queue.c **** #include <string.h>
  56:../../freeRtos/Source/queue.c **** 
  57:../../freeRtos/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../../freeRtos/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../../freeRtos/Source/queue.c **** task.h is included from an application file. */
  60:../../freeRtos/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../../freeRtos/Source/queue.c **** 
  62:../../freeRtos/Source/queue.c **** #include "FreeRTOS.h"
  63:../../freeRtos/Source/queue.c **** #include "task.h"
  64:../../freeRtos/Source/queue.c **** #include "croutine.h"
  65:../../freeRtos/Source/queue.c **** 
  66:../../freeRtos/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  67:../../freeRtos/Source/queue.c **** 
  68:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
  69:../../freeRtos/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  70:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
  71:../../freeRtos/Source/queue.c **** 
  72:../../freeRtos/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  73:../../freeRtos/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  74:../../freeRtos/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  75:../../freeRtos/Source/queue.c **** 
  76:../../freeRtos/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  77:../../freeRtos/Source/queue.c **** 
  78:../../freeRtos/Source/queue.c **** /* For internal use only. */
  79:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  80:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  81:../../freeRtos/Source/queue.c **** 
  82:../../freeRtos/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  83:../../freeRtos/Source/queue.c **** #define pxMutexHolder					pcTail
  84:../../freeRtos/Source/queue.c **** #define uxQueueType						pcHead
  85:../../freeRtos/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  86:../../freeRtos/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  87:../../freeRtos/Source/queue.c **** 
  88:../../freeRtos/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  89:../../freeRtos/Source/queue.c **** zero. */
  90:../../freeRtos/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( 0 )
  91:../../freeRtos/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0 )
  92:../../freeRtos/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0 )
  93:../../freeRtos/Source/queue.c **** 
  94:../../freeRtos/Source/queue.c **** /*
  95:../../freeRtos/Source/queue.c ****  * Definition of the queue used by the scheduler.
  96:../../freeRtos/Source/queue.c ****  * Items are queued by copy, not reference.
  97:../../freeRtos/Source/queue.c ****  */
  98:../../freeRtos/Source/queue.c **** typedef struct QueueDefinition
  99:../../freeRtos/Source/queue.c **** {
 100:../../freeRtos/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 101:../../freeRtos/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 102:../../freeRtos/Source/queue.c **** 
 103:../../freeRtos/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 104:../../freeRtos/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 105:../../freeRtos/Source/queue.c **** 
 106:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 107:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 108:../../freeRtos/Source/queue.c **** 
 109:../../freeRtos/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 110:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 111:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 112:../../freeRtos/Source/queue.c **** 
 113:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 114:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 115:../../freeRtos/Source/queue.c **** 
 116:../../freeRtos/Source/queue.c **** } xQUEUE;
 117:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 118:../../freeRtos/Source/queue.c **** 
 119:../../freeRtos/Source/queue.c **** /*
 120:../../freeRtos/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 121:../../freeRtos/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 122:../../freeRtos/Source/queue.c ****  * pointer to void.
 123:../../freeRtos/Source/queue.c ****  */
 124:../../freeRtos/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 125:../../freeRtos/Source/queue.c **** 
 126:../../freeRtos/Source/queue.c **** /*
 127:../../freeRtos/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 128:../../freeRtos/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 129:../../freeRtos/Source/queue.c ****  * functions are documented in the API header file.
 130:../../freeRtos/Source/queue.c ****  */
 131:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 132:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 133:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 134:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 135:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 136:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 137:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 138:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 139:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 140:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 141:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 142:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 143:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 144:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 145:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 146:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 147:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 148:../../freeRtos/Source/queue.c **** 
 149:../../freeRtos/Source/queue.c **** /*
 150:../../freeRtos/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 151:../../freeRtos/Source/queue.c ****  * an optional component.
 152:../../freeRtos/Source/queue.c ****  */
 153:../../freeRtos/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 154:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 155:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 156:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 157:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 158:../../freeRtos/Source/queue.c **** #endif
 159:../../freeRtos/Source/queue.c **** 
 160:../../freeRtos/Source/queue.c **** /*
 161:../../freeRtos/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 162:../../freeRtos/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 163:../../freeRtos/Source/queue.c ****  */
 164:../../freeRtos/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 165:../../freeRtos/Source/queue.c **** 
 166:../../freeRtos/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 167:../../freeRtos/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 168:../../freeRtos/Source/queue.c **** 	more user friendly. */
 169:../../freeRtos/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 170:../../freeRtos/Source/queue.c **** 	{
 171:../../freeRtos/Source/queue.c **** 		signed char *pcQueueName;
 172:../../freeRtos/Source/queue.c **** 		xQueueHandle xHandle;
 173:../../freeRtos/Source/queue.c **** 	} xQueueRegistryItem;
 174:../../freeRtos/Source/queue.c **** 
 175:../../freeRtos/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 176:../../freeRtos/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 177:../../freeRtos/Source/queue.c **** 	array position being vacant. */
 178:../../freeRtos/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 179:../../freeRtos/Source/queue.c **** 
 180:../../freeRtos/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 181:../../freeRtos/Source/queue.c **** 	member to NULL. */
 182:../../freeRtos/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 183:../../freeRtos/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 184:../../freeRtos/Source/queue.c **** #endif
 185:../../freeRtos/Source/queue.c **** 
 186:../../freeRtos/Source/queue.c **** /*
 187:../../freeRtos/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 188:../../freeRtos/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 189:../../freeRtos/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 190:../../freeRtos/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 191:../../freeRtos/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 192:../../freeRtos/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 193:../../freeRtos/Source/queue.c ****  */
 194:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 195:../../freeRtos/Source/queue.c **** 
 196:../../freeRtos/Source/queue.c **** /*
 197:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 198:../../freeRtos/Source/queue.c ****  *
 199:../../freeRtos/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 200:../../freeRtos/Source/queue.c ****  */
 201:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 202:../../freeRtos/Source/queue.c **** 
 203:../../freeRtos/Source/queue.c **** /*
 204:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 205:../../freeRtos/Source/queue.c ****  *
 206:../../freeRtos/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 207:../../freeRtos/Source/queue.c ****  */
 208:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 209:../../freeRtos/Source/queue.c **** 
 210:../../freeRtos/Source/queue.c **** /*
 211:../../freeRtos/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 212:../../freeRtos/Source/queue.c ****  * back of the queue.
 213:../../freeRtos/Source/queue.c ****  */
 214:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 215:../../freeRtos/Source/queue.c **** 
 216:../../freeRtos/Source/queue.c **** /*
 217:../../freeRtos/Source/queue.c ****  * Copies an item out of a queue.
 218:../../freeRtos/Source/queue.c ****  */
 219:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 220:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 221:../../freeRtos/Source/queue.c **** 
 222:../../freeRtos/Source/queue.c **** /*
 223:../../freeRtos/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 224:../../freeRtos/Source/queue.c ****  * accessing the queue event lists.
 225:../../freeRtos/Source/queue.c ****  */
 226:../../freeRtos/Source/queue.c **** #define prvLockQueue( pxQueue )							\
 227:../../freeRtos/Source/queue.c **** {														\
 228:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();								\
 229:../../freeRtos/Source/queue.c **** 	{													\
 230:../../freeRtos/Source/queue.c **** 		if( pxQueue->xRxLock == queueUNLOCKED )			\
 231:../../freeRtos/Source/queue.c **** 		{												\
 232:../../freeRtos/Source/queue.c **** 			pxQueue->xRxLock = queueLOCKED_UNMODIFIED;	\
 233:../../freeRtos/Source/queue.c **** 		}												\
 234:../../freeRtos/Source/queue.c **** 		if( pxQueue->xTxLock == queueUNLOCKED )			\
 235:../../freeRtos/Source/queue.c **** 		{												\
 236:../../freeRtos/Source/queue.c **** 			pxQueue->xTxLock = queueLOCKED_UNMODIFIED;	\
 237:../../freeRtos/Source/queue.c **** 		}												\
 238:../../freeRtos/Source/queue.c **** 	}													\
 239:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();								\
 240:../../freeRtos/Source/queue.c **** }
 241:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/queue.c **** 
 243:../../freeRtos/Source/queue.c **** 
 244:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
 245:../../freeRtos/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 246:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
 247:../../freeRtos/Source/queue.c **** 
 248:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 249:../../freeRtos/Source/queue.c **** {
 250:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 251:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 252:../../freeRtos/Source/queue.c **** 
 253:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 255:../../freeRtos/Source/queue.c **** 	{
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 258:../../freeRtos/Source/queue.c **** 		{
 259:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 260:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 262:../../freeRtos/Source/queue.c **** 
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 265:../../freeRtos/Source/queue.c **** 			{
 266:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 267:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 276:../../freeRtos/Source/queue.c **** 
 277:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 280:../../freeRtos/Source/queue.c **** 
 281:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 283:../../freeRtos/Source/queue.c **** 			}
 284:../../freeRtos/Source/queue.c **** 			else
 285:../../freeRtos/Source/queue.c **** 			{
 286:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 288:../../freeRtos/Source/queue.c **** 			}
 289:../../freeRtos/Source/queue.c **** 		}
 290:../../freeRtos/Source/queue.c **** 	}
 291:../../freeRtos/Source/queue.c **** 
 292:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 293:../../freeRtos/Source/queue.c **** 	was required. */
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 295:../../freeRtos/Source/queue.c **** }
 296:../../freeRtos/Source/queue.c **** 
 297:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 298:../../freeRtos/Source/queue.c **** {
 299:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 300:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 301:../../freeRtos/Source/queue.c **** 
 302:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 304:../../freeRtos/Source/queue.c **** 	{
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 307:../../freeRtos/Source/queue.c **** 		{
 308:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 309:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 310:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 311:../../freeRtos/Source/queue.c **** 
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 314:../../freeRtos/Source/queue.c **** 			{
 315:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 316:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 325:../../freeRtos/Source/queue.c **** 
 326:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 329:../../freeRtos/Source/queue.c **** 
 330:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 332:../../freeRtos/Source/queue.c **** 			}
 333:../../freeRtos/Source/queue.c **** 			else
 334:../../freeRtos/Source/queue.c **** 			{
 335:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 337:../../freeRtos/Source/queue.c **** 			}
 338:../../freeRtos/Source/queue.c **** 		}
 339:../../freeRtos/Source/queue.c **** 	}
 340:../../freeRtos/Source/queue.c **** 
 341:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 342:../../freeRtos/Source/queue.c **** 	was required. */
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 344:../../freeRtos/Source/queue.c **** }
 345:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 346:../../freeRtos/Source/queue.c **** 
 347:../../freeRtos/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 348:../../freeRtos/Source/queue.c **** 
 349:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 350:../../freeRtos/Source/queue.c **** 	{
 351:../../freeRtos/Source/queue.c **** 	xQUEUE *pxNewQueue;
 352:../../freeRtos/Source/queue.c **** 
 353:../../freeRtos/Source/queue.c **** 		/* Allocate the new queue structure. */
 354:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 355:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 356:../../freeRtos/Source/queue.c **** 		{
 357:../../freeRtos/Source/queue.c **** 			/* Information required for priority inheritance. */
 358:../../freeRtos/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 359:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 360:../../freeRtos/Source/queue.c **** 
 361:../../freeRtos/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 362:../../freeRtos/Source/queue.c **** 			of the queue. */
 363:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 364:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 365:../../freeRtos/Source/queue.c **** 
 366:../../freeRtos/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 367:../../freeRtos/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 368:../../freeRtos/Source/queue.c **** 			of the mutex. */
 369:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = 0;
 370:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxLength = 1;
 371:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxItemSize = 0;
 372:../../freeRtos/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 373:../../freeRtos/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 374:../../freeRtos/Source/queue.c **** 
 375:../../freeRtos/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 376:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 377:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 378:../../freeRtos/Source/queue.c **** 
 379:../../freeRtos/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 380:../../freeRtos/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, 0, queueSEND_TO_BACK );
 381:../../freeRtos/Source/queue.c **** 
 382:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 383:../../freeRtos/Source/queue.c **** 		}
 384:../../freeRtos/Source/queue.c **** 		else
 385:../../freeRtos/Source/queue.c **** 		{
 386:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 387:../../freeRtos/Source/queue.c **** 		}
 388:../../freeRtos/Source/queue.c **** 
 389:../../freeRtos/Source/queue.c **** 		return pxNewQueue;
 390:../../freeRtos/Source/queue.c **** 	}
 391:../../freeRtos/Source/queue.c **** 
 392:../../freeRtos/Source/queue.c **** #endif /* configUSE_MUTEXES */
 393:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 394:../../freeRtos/Source/queue.c **** 
 395:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 396:../../freeRtos/Source/queue.c **** 
 397:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 398:../../freeRtos/Source/queue.c **** 	{
 399:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 400:../../freeRtos/Source/queue.c **** 
 401:../../freeRtos/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 402:../../freeRtos/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 403:../../freeRtos/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 404:../../freeRtos/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 405:../../freeRtos/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 406:../../freeRtos/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 407:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 408:../../freeRtos/Source/queue.c **** 		{
 409:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 410:../../freeRtos/Source/queue.c **** 
 411:../../freeRtos/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 412:../../freeRtos/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 413:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 414:../../freeRtos/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 415:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount member. */
 416:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 417:../../freeRtos/Source/queue.c **** 
 418:../../freeRtos/Source/queue.c **** 			/* Have we unwound the call count? */
 419:../../freeRtos/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 420:../../freeRtos/Source/queue.c **** 			{
 421:../../freeRtos/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 422:../../freeRtos/Source/queue.c **** 				task that might be waiting to access the mutex. */
 423:../../freeRtos/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 424:../../freeRtos/Source/queue.c **** 			}
 425:../../freeRtos/Source/queue.c **** 
 426:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 427:../../freeRtos/Source/queue.c **** 		}
 428:../../freeRtos/Source/queue.c **** 		else
 429:../../freeRtos/Source/queue.c **** 		{
 430:../../freeRtos/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 431:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 432:../../freeRtos/Source/queue.c **** 
 433:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 434:../../freeRtos/Source/queue.c **** 		}
 435:../../freeRtos/Source/queue.c **** 
 436:../../freeRtos/Source/queue.c **** 		return xReturn;
 437:../../freeRtos/Source/queue.c **** 	}
 438:../../freeRtos/Source/queue.c **** 
 439:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 440:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 441:../../freeRtos/Source/queue.c **** 
 442:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 443:../../freeRtos/Source/queue.c **** 
 444:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 445:../../freeRtos/Source/queue.c **** 	{
 446:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 447:../../freeRtos/Source/queue.c **** 
 448:../../freeRtos/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 449:../../freeRtos/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 450:../../freeRtos/Source/queue.c **** 
 451:../../freeRtos/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 452:../../freeRtos/Source/queue.c **** 
 453:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 454:../../freeRtos/Source/queue.c **** 		{
 455:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 456:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 457:../../freeRtos/Source/queue.c **** 		}
 458:../../freeRtos/Source/queue.c **** 		else
 459:../../freeRtos/Source/queue.c **** 		{
 460:../../freeRtos/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 461:../../freeRtos/Source/queue.c **** 
 462:../../freeRtos/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 463:../../freeRtos/Source/queue.c **** 			we may have blocked to reach here. */
 464:../../freeRtos/Source/queue.c **** 			if( xReturn == pdPASS )
 465:../../freeRtos/Source/queue.c **** 			{
 466:../../freeRtos/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 467:../../freeRtos/Source/queue.c **** 			}
 468:../../freeRtos/Source/queue.c **** 		}
 469:../../freeRtos/Source/queue.c **** 
 470:../../freeRtos/Source/queue.c **** 		return xReturn;
 471:../../freeRtos/Source/queue.c **** 	}
 472:../../freeRtos/Source/queue.c **** 
 473:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 474:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 475:../../freeRtos/Source/queue.c **** 
 476:../../freeRtos/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 477:../../freeRtos/Source/queue.c **** 
 478:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 479:../../freeRtos/Source/queue.c **** 	{
 480:../../freeRtos/Source/queue.c **** 	xQueueHandle pxHandle;
 481:../../freeRtos/Source/queue.c **** 
 482:../../freeRtos/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 483:../../freeRtos/Source/queue.c **** 
 484:../../freeRtos/Source/queue.c **** 		if( pxHandle != NULL )
 485:../../freeRtos/Source/queue.c **** 		{
 486:../../freeRtos/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 487:../../freeRtos/Source/queue.c **** 
 488:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 489:../../freeRtos/Source/queue.c **** 		}
 490:../../freeRtos/Source/queue.c **** 		else
 491:../../freeRtos/Source/queue.c **** 		{
 492:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 493:../../freeRtos/Source/queue.c **** 		}
 494:../../freeRtos/Source/queue.c **** 
 495:../../freeRtos/Source/queue.c **** 		return pxHandle;
 496:../../freeRtos/Source/queue.c **** 	}
 497:../../freeRtos/Source/queue.c **** 
 498:../../freeRtos/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 499:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 500:../../freeRtos/Source/queue.c **** 
 501:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 502:../../freeRtos/Source/queue.c **** {
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 504:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 505:../../freeRtos/Source/queue.c **** 
 506:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 509:../../freeRtos/Source/queue.c **** 	for( ;; )
 510:../../freeRtos/Source/queue.c **** 	{
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 512:../../freeRtos/Source/queue.c **** 		{
 513:../../freeRtos/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../../freeRtos/Source/queue.c **** 			{
 517:../../freeRtos/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../../freeRtos/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../../freeRtos/Source/queue.c **** 
 520:../../freeRtos/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../../freeRtos/Source/queue.c **** 				queue then unblock it now. */
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../../freeRtos/Source/queue.c **** 				{
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../../freeRtos/Source/queue.c **** 					{
 526:../../freeRtos/Source/queue.c **** 						/* The unblocked task has a priority higher than
 527:../../freeRtos/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../../freeRtos/Source/queue.c **** 						this from within the critical section - the kernel
 529:../../freeRtos/Source/queue.c **** 						takes care of that. */
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 531:../../freeRtos/Source/queue.c **** 					}
 532:../../freeRtos/Source/queue.c **** 				}
 533:../../freeRtos/Source/queue.c **** 
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 535:../../freeRtos/Source/queue.c **** 
 536:../../freeRtos/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../../freeRtos/Source/queue.c **** 				function. */
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 539:../../freeRtos/Source/queue.c **** 			}
 540:../../freeRtos/Source/queue.c **** 			else
 541:../../freeRtos/Source/queue.c **** 			{
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../../freeRtos/Source/queue.c **** 				{
 544:../../freeRtos/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 547:../../freeRtos/Source/queue.c **** 
 548:../../freeRtos/Source/queue.c **** 					/* Return to the original privilege level before exiting
 549:../../freeRtos/Source/queue.c **** 					the function. */
 550:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 552:../../freeRtos/Source/queue.c **** 				}
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../../freeRtos/Source/queue.c **** 				{
 555:../../freeRtos/Source/queue.c **** 					/* The queue was full and a block time was specified so
 556:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../../freeRtos/Source/queue.c **** 				}
 560:../../freeRtos/Source/queue.c **** 			}
 561:../../freeRtos/Source/queue.c **** 		}
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 563:../../freeRtos/Source/queue.c **** 
 564:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 566:../../freeRtos/Source/queue.c **** 
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 569:../../freeRtos/Source/queue.c **** 
 570:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../../freeRtos/Source/queue.c **** 		{
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 574:../../freeRtos/Source/queue.c **** 			{
 575:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../../freeRtos/Source/queue.c **** 
 578:../../freeRtos/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../../freeRtos/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../../freeRtos/Source/queue.c **** 				remove this task from the event	list again - but as the
 581:../../freeRtos/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../../freeRtos/Source/queue.c **** 				ready last instead of the actual ready list. */
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../../freeRtos/Source/queue.c **** 
 585:../../freeRtos/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../../freeRtos/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../../freeRtos/Source/queue.c **** 				task is already in a ready list before it yields - in which
 588:../../freeRtos/Source/queue.c **** 				case the yield will not cause a context switch unless there
 589:../../freeRtos/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 591:../../freeRtos/Source/queue.c **** 				{
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 593:../../freeRtos/Source/queue.c **** 				}
 594:../../freeRtos/Source/queue.c **** 			}
 595:../../freeRtos/Source/queue.c **** 			else
 596:../../freeRtos/Source/queue.c **** 			{
 597:../../freeRtos/Source/queue.c **** 				/* Try again. */
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 600:../../freeRtos/Source/queue.c **** 			}
 601:../../freeRtos/Source/queue.c **** 		}
 602:../../freeRtos/Source/queue.c **** 		else
 603:../../freeRtos/Source/queue.c **** 		{
 604:../../freeRtos/Source/queue.c **** 			/* The timeout has expired. */
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 607:../../freeRtos/Source/queue.c **** 
 608:../../freeRtos/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../../freeRtos/Source/queue.c **** 			function. */
 610:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 612:../../freeRtos/Source/queue.c **** 		}
 613:../../freeRtos/Source/queue.c **** 	}
 614:../../freeRtos/Source/queue.c **** }
 615:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 616:../../freeRtos/Source/queue.c **** 
 617:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../../freeRtos/Source/queue.c **** 
 619:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../../freeRtos/Source/queue.c **** 	{
 621:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 623:../../freeRtos/Source/queue.c **** 
 624:../../freeRtos/Source/queue.c **** 		for( ;; )
 625:../../freeRtos/Source/queue.c **** 		{
 626:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 627:../../freeRtos/Source/queue.c **** 			{
 628:../../freeRtos/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 629:../../freeRtos/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 630:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 631:../../freeRtos/Source/queue.c **** 				{
 632:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 633:../../freeRtos/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 634:../../freeRtos/Source/queue.c **** 
 635:../../freeRtos/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 636:../../freeRtos/Source/queue.c **** 					queue then unblock it now. */
 637:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 638:../../freeRtos/Source/queue.c **** 					{
 639:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 640:../../freeRtos/Source/queue.c **** 						{
 641:../../freeRtos/Source/queue.c **** 							/* The unblocked task has a priority higher than
 642:../../freeRtos/Source/queue.c **** 							our own so yield immediately. */
 643:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 644:../../freeRtos/Source/queue.c **** 						}
 645:../../freeRtos/Source/queue.c **** 					}
 646:../../freeRtos/Source/queue.c **** 
 647:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 648:../../freeRtos/Source/queue.c **** 					return pdPASS;
 649:../../freeRtos/Source/queue.c **** 				}
 650:../../freeRtos/Source/queue.c **** 				else
 651:../../freeRtos/Source/queue.c **** 				{
 652:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 653:../../freeRtos/Source/queue.c **** 					{
 654:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 655:../../freeRtos/Source/queue.c **** 						return errQUEUE_FULL;
 656:../../freeRtos/Source/queue.c **** 					}
 657:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 658:../../freeRtos/Source/queue.c **** 					{
 659:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 660:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 661:../../freeRtos/Source/queue.c **** 					}
 662:../../freeRtos/Source/queue.c **** 				}
 663:../../freeRtos/Source/queue.c **** 			}
 664:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 665:../../freeRtos/Source/queue.c **** 
 666:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 667:../../freeRtos/Source/queue.c **** 			{
 668:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 669:../../freeRtos/Source/queue.c **** 				{
 670:../../freeRtos/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) )
 671:../../freeRtos/Source/queue.c **** 					{
 672:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 673:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 674:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 675:../../freeRtos/Source/queue.c **** 					}
 676:../../freeRtos/Source/queue.c **** 				}
 677:../../freeRtos/Source/queue.c **** 				else
 678:../../freeRtos/Source/queue.c **** 				{
 679:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 680:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 681:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 682:../../freeRtos/Source/queue.c **** 				}
 683:../../freeRtos/Source/queue.c **** 			}
 684:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 685:../../freeRtos/Source/queue.c **** 		}
 686:../../freeRtos/Source/queue.c **** 	}
 687:../../freeRtos/Source/queue.c **** 
 688:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 689:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 690:../../freeRtos/Source/queue.c **** 
 691:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 692:../../freeRtos/Source/queue.c **** 
 693:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 694:../../freeRtos/Source/queue.c **** 	{
 695:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 696:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 697:../../freeRtos/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 698:../../freeRtos/Source/queue.c **** 
 699:../../freeRtos/Source/queue.c **** 		for( ;; )
 700:../../freeRtos/Source/queue.c **** 		{
 701:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 702:../../freeRtos/Source/queue.c **** 			{
 703:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 704:../../freeRtos/Source/queue.c **** 				{
 705:../../freeRtos/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 706:../../freeRtos/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 707:../../freeRtos/Source/queue.c **** 
 708:../../freeRtos/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 709:../../freeRtos/Source/queue.c **** 
 710:../../freeRtos/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 711:../../freeRtos/Source/queue.c **** 					{
 712:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 713:../../freeRtos/Source/queue.c **** 
 714:../../freeRtos/Source/queue.c **** 						/* We are actually removing data. */
 715:../../freeRtos/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 716:../../freeRtos/Source/queue.c **** 
 717:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 718:../../freeRtos/Source/queue.c **** 						{
 719:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 720:../../freeRtos/Source/queue.c **** 							{
 721:../../freeRtos/Source/queue.c **** 								/* Record the information required to implement
 722:../../freeRtos/Source/queue.c **** 								priority inheritance should it become necessary. */
 723:../../freeRtos/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 724:../../freeRtos/Source/queue.c **** 							}
 725:../../freeRtos/Source/queue.c **** 						}
 726:../../freeRtos/Source/queue.c **** 						#endif
 727:../../freeRtos/Source/queue.c **** 
 728:../../freeRtos/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 729:../../freeRtos/Source/queue.c **** 						{
 730:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 731:../../freeRtos/Source/queue.c **** 							{
 732:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 733:../../freeRtos/Source/queue.c **** 							}
 734:../../freeRtos/Source/queue.c **** 						}
 735:../../freeRtos/Source/queue.c **** 					}
 736:../../freeRtos/Source/queue.c **** 					else
 737:../../freeRtos/Source/queue.c **** 					{
 738:../../freeRtos/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 739:../../freeRtos/Source/queue.c **** 
 740:../../freeRtos/Source/queue.c **** 						/* We are not removing the data, so reset our read
 741:../../freeRtos/Source/queue.c **** 						pointer. */
 742:../../freeRtos/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 743:../../freeRtos/Source/queue.c **** 
 744:../../freeRtos/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 745:../../freeRtos/Source/queue.c **** 						any other tasks waiting for the data. */
 746:../../freeRtos/Source/queue.c **** 						if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 747:../../freeRtos/Source/queue.c **** 						{
 748:../../freeRtos/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 749:../../freeRtos/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 750:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 751:../../freeRtos/Source/queue.c **** 							{
 752:../../freeRtos/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 753:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 754:../../freeRtos/Source/queue.c **** 							}
 755:../../freeRtos/Source/queue.c **** 						}
 756:../../freeRtos/Source/queue.c **** 
 757:../../freeRtos/Source/queue.c **** 					}
 758:../../freeRtos/Source/queue.c **** 
 759:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 760:../../freeRtos/Source/queue.c **** 					return pdPASS;
 761:../../freeRtos/Source/queue.c **** 				}
 762:../../freeRtos/Source/queue.c **** 				else
 763:../../freeRtos/Source/queue.c **** 				{
 764:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 765:../../freeRtos/Source/queue.c **** 					{
 766:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 767:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 768:../../freeRtos/Source/queue.c **** 						return errQUEUE_EMPTY;
 769:../../freeRtos/Source/queue.c **** 					}
 770:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 771:../../freeRtos/Source/queue.c **** 					{
 772:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 773:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 774:../../freeRtos/Source/queue.c **** 					}
 775:../../freeRtos/Source/queue.c **** 				}
 776:../../freeRtos/Source/queue.c **** 			}
 777:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 778:../../freeRtos/Source/queue.c **** 
 779:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 780:../../freeRtos/Source/queue.c **** 			{
 781:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 782:../../freeRtos/Source/queue.c **** 				{
 783:../../freeRtos/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) )
 784:../../freeRtos/Source/queue.c **** 					{
 785:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 786:../../freeRtos/Source/queue.c **** 
 787:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 788:../../freeRtos/Source/queue.c **** 						{
 789:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 790:../../freeRtos/Source/queue.c **** 							{
 791:../../freeRtos/Source/queue.c **** 								portENTER_CRITICAL();
 792:../../freeRtos/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 793:../../freeRtos/Source/queue.c **** 								portEXIT_CRITICAL();
 794:../../freeRtos/Source/queue.c **** 							}
 795:../../freeRtos/Source/queue.c **** 						}
 796:../../freeRtos/Source/queue.c **** 						#endif
 797:../../freeRtos/Source/queue.c **** 
 798:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 799:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 800:../../freeRtos/Source/queue.c **** 					}
 801:../../freeRtos/Source/queue.c **** 				}
 802:../../freeRtos/Source/queue.c **** 				else
 803:../../freeRtos/Source/queue.c **** 				{
 804:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 805:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 806:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 807:../../freeRtos/Source/queue.c **** 				}
 808:../../freeRtos/Source/queue.c **** 			}
 809:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 810:../../freeRtos/Source/queue.c **** 		}
 811:../../freeRtos/Source/queue.c **** 	}
 812:../../freeRtos/Source/queue.c **** 
 813:../../freeRtos/Source/queue.c **** 
 814:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 815:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 816:../../freeRtos/Source/queue.c **** 
 817:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 818:../../freeRtos/Source/queue.c **** {
 819:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
 820:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 821:../../freeRtos/Source/queue.c **** 
 822:../../freeRtos/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 823:../../freeRtos/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 824:../../freeRtos/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 825:../../freeRtos/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 826:../../freeRtos/Source/queue.c **** 	by this	post). */
 827:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 828:../../freeRtos/Source/queue.c **** 	{
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 830:../../freeRtos/Source/queue.c **** 		{
 831:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 832:../../freeRtos/Source/queue.c **** 
 833:../../freeRtos/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:../../freeRtos/Source/queue.c **** 
 835:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 836:../../freeRtos/Source/queue.c **** 			be done when the queue is unlocked later. */
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 838:../../freeRtos/Source/queue.c **** 			{
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 840:../../freeRtos/Source/queue.c **** 				{
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 842:../../freeRtos/Source/queue.c **** 					{
 843:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 844:../../freeRtos/Source/queue.c **** 						context	switch is required. */
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 846:../../freeRtos/Source/queue.c **** 					}
 847:../../freeRtos/Source/queue.c **** 				}
 848:../../freeRtos/Source/queue.c **** 			}
 849:../../freeRtos/Source/queue.c **** 			else
 850:../../freeRtos/Source/queue.c **** 			{
 851:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 852:../../freeRtos/Source/queue.c **** 				knows that data was posted while it was locked. */
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 854:../../freeRtos/Source/queue.c **** 			}
 855:../../freeRtos/Source/queue.c **** 
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 857:../../freeRtos/Source/queue.c **** 		}
 858:../../freeRtos/Source/queue.c **** 		else
 859:../../freeRtos/Source/queue.c **** 		{
 860:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 862:../../freeRtos/Source/queue.c **** 		}
 863:../../freeRtos/Source/queue.c **** 	}
 864:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 865:../../freeRtos/Source/queue.c **** 
 866:../../freeRtos/Source/queue.c **** 	return xReturn;
 867:../../freeRtos/Source/queue.c **** }
 868:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 869:../../freeRtos/Source/queue.c **** 
 870:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 871:../../freeRtos/Source/queue.c **** {
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 873:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 874:../../freeRtos/Source/queue.c **** signed char *pcOriginalReadPosition;
 875:../../freeRtos/Source/queue.c **** 
 876:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 877:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 878:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 879:../../freeRtos/Source/queue.c **** 
 880:../../freeRtos/Source/queue.c **** 	for( ;; )
 881:../../freeRtos/Source/queue.c **** 	{
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 883:../../freeRtos/Source/queue.c **** 		{
 884:../../freeRtos/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 885:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 887:../../freeRtos/Source/queue.c **** 			{
 888:../../freeRtos/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 890:../../freeRtos/Source/queue.c **** 
 891:../../freeRtos/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 892:../../freeRtos/Source/queue.c **** 
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 894:../../freeRtos/Source/queue.c **** 				{
 895:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 896:../../freeRtos/Source/queue.c **** 
 897:../../freeRtos/Source/queue.c **** 					/* We are actually removing data. */
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 899:../../freeRtos/Source/queue.c **** 
 900:../../freeRtos/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 901:../../freeRtos/Source/queue.c **** 					{
 902:../../freeRtos/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 903:../../freeRtos/Source/queue.c **** 						{
 904:../../freeRtos/Source/queue.c **** 							/* Record the information required to implement
 905:../../freeRtos/Source/queue.c **** 							priority inheritance should it become necessary. */
 906:../../freeRtos/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 907:../../freeRtos/Source/queue.c **** 						}
 908:../../freeRtos/Source/queue.c **** 					}
 909:../../freeRtos/Source/queue.c **** 					#endif
 910:../../freeRtos/Source/queue.c **** 
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 912:../../freeRtos/Source/queue.c **** 					{
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 914:../../freeRtos/Source/queue.c **** 						{
 915:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:../../freeRtos/Source/queue.c **** 						}
 917:../../freeRtos/Source/queue.c **** 					}
 918:../../freeRtos/Source/queue.c **** 				}
 919:../../freeRtos/Source/queue.c **** 				else
 920:../../freeRtos/Source/queue.c **** 				{
 921:../../freeRtos/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 922:../../freeRtos/Source/queue.c **** 
 923:../../freeRtos/Source/queue.c **** 					/* We are not removing the data, so reset our read
 924:../../freeRtos/Source/queue.c **** 					pointer. */
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 926:../../freeRtos/Source/queue.c **** 
 927:../../freeRtos/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 928:../../freeRtos/Source/queue.c **** 					any other tasks waiting for the data. */
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 930:../../freeRtos/Source/queue.c **** 					{
 931:../../freeRtos/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 932:../../freeRtos/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 934:../../freeRtos/Source/queue.c **** 						{
 935:../../freeRtos/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 936:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 937:../../freeRtos/Source/queue.c **** 						}
 938:../../freeRtos/Source/queue.c **** 					}
 939:../../freeRtos/Source/queue.c **** 
 940:../../freeRtos/Source/queue.c **** 				}
 941:../../freeRtos/Source/queue.c **** 
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 944:../../freeRtos/Source/queue.c **** 			}
 945:../../freeRtos/Source/queue.c **** 			else
 946:../../freeRtos/Source/queue.c **** 			{
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 948:../../freeRtos/Source/queue.c **** 				{
 949:../../freeRtos/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 950:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 952:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 953:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 954:../../freeRtos/Source/queue.c **** 				}
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 956:../../freeRtos/Source/queue.c **** 				{
 957:../../freeRtos/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 958:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 960:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 961:../../freeRtos/Source/queue.c **** 				}
 962:../../freeRtos/Source/queue.c **** 			}
 963:../../freeRtos/Source/queue.c **** 		}
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 965:../../freeRtos/Source/queue.c **** 
 966:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 967:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 968:../../freeRtos/Source/queue.c **** 
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 971:../../freeRtos/Source/queue.c **** 
 972:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 974:../../freeRtos/Source/queue.c **** 		{
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 976:../../freeRtos/Source/queue.c **** 			{
 977:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 978:../../freeRtos/Source/queue.c **** 
 979:../../freeRtos/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 980:../../freeRtos/Source/queue.c **** 				{
 981:../../freeRtos/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 982:../../freeRtos/Source/queue.c **** 					{
 983:../../freeRtos/Source/queue.c **** 						portENTER_CRITICAL();
 984:../../freeRtos/Source/queue.c **** 						{
 985:../../freeRtos/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 986:../../freeRtos/Source/queue.c **** 						}
 987:../../freeRtos/Source/queue.c **** 						portEXIT_CRITICAL();
 988:../../freeRtos/Source/queue.c **** 					}
 989:../../freeRtos/Source/queue.c **** 				}
 990:../../freeRtos/Source/queue.c **** 				#endif
 991:../../freeRtos/Source/queue.c **** 
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 995:../../freeRtos/Source/queue.c **** 				{
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 997:../../freeRtos/Source/queue.c **** 				}
 998:../../freeRtos/Source/queue.c **** 			}
 999:../../freeRtos/Source/queue.c **** 			else
1000:../../freeRtos/Source/queue.c **** 			{
1001:../../freeRtos/Source/queue.c **** 				/* Try again. */
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
1004:../../freeRtos/Source/queue.c **** 			}
1005:../../freeRtos/Source/queue.c **** 		}
1006:../../freeRtos/Source/queue.c **** 		else
1007:../../freeRtos/Source/queue.c **** 		{
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
1010:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
1012:../../freeRtos/Source/queue.c **** 		}
1013:../../freeRtos/Source/queue.c **** 	}
1014:../../freeRtos/Source/queue.c **** }
1015:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1016:../../freeRtos/Source/queue.c **** 
1017:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1018:../../freeRtos/Source/queue.c **** {
1019:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1020:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1021:../../freeRtos/Source/queue.c **** 
1022:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1023:../../freeRtos/Source/queue.c **** 	{
1024:../../freeRtos/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1026:../../freeRtos/Source/queue.c **** 		{
1027:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1028:../../freeRtos/Source/queue.c **** 
1029:../../freeRtos/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1031:../../freeRtos/Source/queue.c **** 
1032:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1033:../../freeRtos/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1034:../../freeRtos/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1036:../../freeRtos/Source/queue.c **** 			{
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1038:../../freeRtos/Source/queue.c **** 				{
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1040:../../freeRtos/Source/queue.c **** 					{
1041:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1042:../../freeRtos/Source/queue.c **** 						force a context switch. */
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
1044:../../freeRtos/Source/queue.c **** 					}
1045:../../freeRtos/Source/queue.c **** 				}
1046:../../freeRtos/Source/queue.c **** 			}
1047:../../freeRtos/Source/queue.c **** 			else
1048:../../freeRtos/Source/queue.c **** 			{
1049:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1050:../../freeRtos/Source/queue.c **** 				knows that data was removed while it was locked. */
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
1052:../../freeRtos/Source/queue.c **** 			}
1053:../../freeRtos/Source/queue.c **** 
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
1055:../../freeRtos/Source/queue.c **** 		}
1056:../../freeRtos/Source/queue.c **** 		else
1057:../../freeRtos/Source/queue.c **** 		{
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
1059:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1060:../../freeRtos/Source/queue.c **** 		}
1061:../../freeRtos/Source/queue.c **** 	}
1062:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1063:../../freeRtos/Source/queue.c **** 
1064:../../freeRtos/Source/queue.c **** 	return xReturn;
1065:../../freeRtos/Source/queue.c **** }
1066:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1067:../../freeRtos/Source/queue.c **** 
1068:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1069:../../freeRtos/Source/queue.c **** {
1070:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1071:../../freeRtos/Source/queue.c **** 
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1075:../../freeRtos/Source/queue.c **** 
1076:../../freeRtos/Source/queue.c **** 	return uxReturn;
1077:../../freeRtos/Source/queue.c **** }
1078:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1079:../../freeRtos/Source/queue.c **** 
1080:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1081:../../freeRtos/Source/queue.c **** {
1082:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1083:../../freeRtos/Source/queue.c **** 
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1085:../../freeRtos/Source/queue.c **** 
1086:../../freeRtos/Source/queue.c **** 	return uxReturn;
1087:../../freeRtos/Source/queue.c **** }
1088:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1089:../../freeRtos/Source/queue.c **** 
1090:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1091:../../freeRtos/Source/queue.c **** {
1092:../../freeRtos/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1093:../../freeRtos/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
1096:../../freeRtos/Source/queue.c **** }
1097:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1098:../../freeRtos/Source/queue.c **** 
1099:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1100:../../freeRtos/Source/queue.c **** {
 162               	.LM0:
 163               	.LFBB1:
 164 0000 CF93      		push r28
 165 0002 DF93      		push r29
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 2 */
 169               	.L__stack_usage = 2
 170 0004 EC01      		movw r28,r24
 171 0006 942F      		mov r25,r20
1101:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 173               	.LM1:
 174 0008 8C8D      		ldd r24,Y+28
 175 000a 8823      		tst r24
 176 000c 01F0      		breq .L3
 177 000e 482F      		mov r20,r24
 178 0010 50E0      		ldi r21,0
1102:../../freeRtos/Source/queue.c **** 	{
1103:../../freeRtos/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1104:../../freeRtos/Source/queue.c **** 		{
1105:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1106:../../freeRtos/Source/queue.c **** 			{
1107:../../freeRtos/Source/queue.c **** 				/* The mutex is no longer being held. */
1108:../../freeRtos/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1109:../../freeRtos/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1110:../../freeRtos/Source/queue.c **** 			}
1111:../../freeRtos/Source/queue.c **** 		}
1112:../../freeRtos/Source/queue.c **** 		#endif
1113:../../freeRtos/Source/queue.c **** 	}
1114:../../freeRtos/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 180               	.LM2:
 181 0012 9111      		cpse r25,__zero_reg__
 182 0014 00C0      		rjmp .L4
1115:../../freeRtos/Source/queue.c **** 	{
1116:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 184               	.LM3:
 185 0016 8C81      		ldd r24,Y+4
 186 0018 9D81      		ldd r25,Y+5
 187 001a 0E94 0000 		call memcpy
1117:../../freeRtos/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 189               	.LM4:
 190 001e 2C8D      		ldd r18,Y+28
 191 0020 8C81      		ldd r24,Y+4
 192 0022 9D81      		ldd r25,Y+5
 193 0024 820F      		add r24,r18
 194 0026 911D      		adc r25,__zero_reg__
 195 0028 9D83      		std Y+5,r25
 196 002a 8C83      		std Y+4,r24
1118:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 198               	.LM5:
 199 002c 2A81      		ldd r18,Y+2
 200 002e 3B81      		ldd r19,Y+3
 201 0030 8217      		cp r24,r18
 202 0032 9307      		cpc r25,r19
 203 0034 00F0      		brlo .L3
1119:../../freeRtos/Source/queue.c **** 		{
1120:../../freeRtos/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 205               	.LM6:
 206 0036 8881      		ld r24,Y
 207 0038 9981      		ldd r25,Y+1
 208 003a 9D83      		std Y+5,r25
 209 003c 8C83      		std Y+4,r24
 210 003e 00C0      		rjmp .L3
 211               	.L4:
1121:../../freeRtos/Source/queue.c **** 		}
1122:../../freeRtos/Source/queue.c **** 	}
1123:../../freeRtos/Source/queue.c **** 	else
1124:../../freeRtos/Source/queue.c **** 	{
1125:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 213               	.LM7:
 214 0040 8E81      		ldd r24,Y+6
 215 0042 9F81      		ldd r25,Y+7
 216 0044 0E94 0000 		call memcpy
1126:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 218               	.LM8:
 219 0048 2C8D      		ldd r18,Y+28
 220 004a 30E0      		ldi r19,0
 221 004c 3195      		neg r19
 222 004e 2195      		neg r18
 223 0050 3109      		sbc r19,__zero_reg__
 224 0052 8E81      		ldd r24,Y+6
 225 0054 9F81      		ldd r25,Y+7
 226 0056 820F      		add r24,r18
 227 0058 931F      		adc r25,r19
 228 005a 9F83      		std Y+7,r25
 229 005c 8E83      		std Y+6,r24
1127:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 231               	.LM9:
 232 005e 4881      		ld r20,Y
 233 0060 5981      		ldd r21,Y+1
 234 0062 8417      		cp r24,r20
 235 0064 9507      		cpc r25,r21
 236 0066 00F4      		brsh .L3
1128:../../freeRtos/Source/queue.c **** 		{
1129:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 238               	.LM10:
 239 0068 8A81      		ldd r24,Y+2
 240 006a 9B81      		ldd r25,Y+3
 241 006c 820F      		add r24,r18
 242 006e 931F      		adc r25,r19
 243 0070 9F83      		std Y+7,r25
 244 0072 8E83      		std Y+6,r24
 245               	.L3:
1130:../../freeRtos/Source/queue.c **** 		}
1131:../../freeRtos/Source/queue.c **** 	}
1132:../../freeRtos/Source/queue.c **** 
1133:../../freeRtos/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 247               	.LM11:
 248 0074 8A8D      		ldd r24,Y+26
 249 0076 8F5F      		subi r24,lo8(-(1))
 250 0078 8A8F      		std Y+26,r24
 251               	/* epilogue start */
1134:../../freeRtos/Source/queue.c **** }
 253               	.LM12:
 254 007a DF91      		pop r29
 255 007c CF91      		pop r28
 256 007e 0895      		ret
 258               	.Lscope1:
 260               		.stabd	78,0,0
 265               	prvCopyDataFromQueue:
 266               		.stabd	46,0,0
1135:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1136:../../freeRtos/Source/queue.c **** 
1137:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1138:../../freeRtos/Source/queue.c **** {
 268               	.LM13:
 269               	.LFBB2:
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272               	/* stack size = 0 */
 273               	.L__stack_usage = 0
 274 0080 FC01      		movw r30,r24
 275 0082 CB01      		movw r24,r22
1139:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 277               	.LM14:
 278 0084 A081      		ld r26,Z
 279 0086 B181      		ldd r27,Z+1
 280 0088 1097      		sbiw r26,0
 281 008a 01F0      		breq .L7
1140:../../freeRtos/Source/queue.c **** 	{
1141:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 283               	.LM15:
 284 008c 448D      		ldd r20,Z+28
 285 008e 50E0      		ldi r21,0
 286 0090 2681      		ldd r18,Z+6
 287 0092 3781      		ldd r19,Z+7
 288 0094 240F      		add r18,r20
 289 0096 351F      		adc r19,r21
 290 0098 3783      		std Z+7,r19
 291 009a 2683      		std Z+6,r18
1142:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 293               	.LM16:
 294 009c 6281      		ldd r22,Z+2
 295 009e 7381      		ldd r23,Z+3
 296 00a0 2617      		cp r18,r22
 297 00a2 3707      		cpc r19,r23
 298 00a4 00F0      		brlo .L9
1143:../../freeRtos/Source/queue.c **** 		{
1144:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 300               	.LM17:
 301 00a6 B783      		std Z+7,r27
 302 00a8 A683      		std Z+6,r26
 303               	.L9:
1145:../../freeRtos/Source/queue.c **** 		}
1146:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 305               	.LM18:
 306 00aa 6681      		ldd r22,Z+6
 307 00ac 7781      		ldd r23,Z+7
 308 00ae 0C94 0000 		jmp memcpy
 309               	.L7:
 310 00b2 0895      		ret
 312               	.Lscope2:
 314               		.stabd	78,0,0
 318               	prvUnlockQueue:
 319               		.stabd	46,0,0
1147:../../freeRtos/Source/queue.c **** 	}
1148:../../freeRtos/Source/queue.c **** }
1149:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1150:../../freeRtos/Source/queue.c **** 
1151:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1152:../../freeRtos/Source/queue.c **** {
 321               	.LM19:
 322               	.LFBB3:
 323 00b4 0F93      		push r16
 324 00b6 1F93      		push r17
 325 00b8 CF93      		push r28
 326 00ba DF93      		push r29
 327               	/* prologue: function */
 328               	/* frame size = 0 */
 329               	/* stack size = 4 */
 330               	.L__stack_usage = 4
 331 00bc EC01      		movw r28,r24
1153:../../freeRtos/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1154:../../freeRtos/Source/queue.c **** 
1155:../../freeRtos/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1156:../../freeRtos/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1157:../../freeRtos/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1158:../../freeRtos/Source/queue.c **** 	updated. */
1159:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 333               	.LM20:
 334               	/* #APP */
 335               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 336 00be 0FB6      		in		__tmp_reg__, __SREG__
 337               	 ;  0 "" 2
 338               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 339 00c0 F894      		cli
 340               	 ;  0 "" 2
 341               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 342 00c2 0F92      		push	__tmp_reg__
 343               	 ;  0 "" 2
1160:../../freeRtos/Source/queue.c **** 	{
1161:../../freeRtos/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
1163:../../freeRtos/Source/queue.c **** 		{
1164:../../freeRtos/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1165:../../freeRtos/Source/queue.c **** 			blocked waiting for data to become available? */
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
1167:../../freeRtos/Source/queue.c **** 			{
1168:../../freeRtos/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1169:../../freeRtos/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1170:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 345               	.LM21:
 346               	/* #NOAPP */
 347 00c4 8C01      		movw r16,r24
 348 00c6 0F5E      		subi r16,-17
 349 00c8 1F4F      		sbci r17,-1
 350               	.L11:
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 352               	.LM22:
 353 00ca 8E8D      		ldd r24,Y+30
 354 00cc 1816      		cp __zero_reg__,r24
 355 00ce 04F4      		brge .L12
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 357               	.LM23:
 358 00d0 8989      		ldd r24,Y+17
 359 00d2 8823      		tst r24
 360 00d4 01F0      		breq .L12
 362               	.LM24:
 363 00d6 C801      		movw r24,r16
 364 00d8 0E94 0000 		call xTaskRemoveFromEventList
 365 00dc 8111      		cpse r24,__zero_reg__
1171:../../freeRtos/Source/queue.c **** 				{
1172:../../freeRtos/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1173:../../freeRtos/Source/queue.c **** 					context	switch is required. */
1174:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 367               	.LM25:
 368 00de 0E94 0000 		call vTaskMissedYield
 369               	.L13:
1175:../../freeRtos/Source/queue.c **** 				}
1176:../../freeRtos/Source/queue.c **** 
1177:../../freeRtos/Source/queue.c **** 				--( pxQueue->xTxLock );
 371               	.LM26:
 372 00e2 8E8D      		ldd r24,Y+30
 373 00e4 8150      		subi r24,lo8(-(-1))
 374 00e6 8E8F      		std Y+30,r24
 375 00e8 00C0      		rjmp .L11
 376               	.L12:
1178:../../freeRtos/Source/queue.c **** 			}
1179:../../freeRtos/Source/queue.c **** 			else
1180:../../freeRtos/Source/queue.c **** 			{
1181:../../freeRtos/Source/queue.c **** 				break;
1182:../../freeRtos/Source/queue.c **** 			}
1183:../../freeRtos/Source/queue.c **** 		}
1184:../../freeRtos/Source/queue.c **** 
1185:../../freeRtos/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 378               	.LM27:
 379 00ea 8FEF      		ldi r24,lo8(-1)
 380 00ec 8E8F      		std Y+30,r24
1186:../../freeRtos/Source/queue.c **** 	}
1187:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 382               	.LM28:
 383               	/* #APP */
 384               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 385 00ee 0F90      		pop		__tmp_reg__
 386               	 ;  0 "" 2
 387               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 388 00f0 0FBE      		out		__SREG__, __tmp_reg__
 389               	 ;  0 "" 2
1188:../../freeRtos/Source/queue.c **** 
1189:../../freeRtos/Source/queue.c **** 	/* Do the same for the Rx lock. */
1190:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 391               	.LM29:
 392               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 393 00f2 0FB6      		in		__tmp_reg__, __SREG__
 394               	 ;  0 "" 2
 395               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 396 00f4 F894      		cli
 397               	 ;  0 "" 2
 398               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 399 00f6 0F92      		push	__tmp_reg__
 400               	 ;  0 "" 2
1191:../../freeRtos/Source/queue.c **** 	{
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
1193:../../freeRtos/Source/queue.c **** 		{
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1195:../../freeRtos/Source/queue.c **** 			{
1196:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 402               	.LM30:
 403               	/* #NOAPP */
 404 00f8 8E01      		movw r16,r28
 405 00fa 085F      		subi r16,-8
 406 00fc 1F4F      		sbci r17,-1
 407               	.L15:
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 409               	.LM31:
 410 00fe 8D8D      		ldd r24,Y+29
 411 0100 1816      		cp __zero_reg__,r24
 412 0102 04F4      		brge .L16
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 414               	.LM32:
 415 0104 8885      		ldd r24,Y+8
 416 0106 8823      		tst r24
 417 0108 01F0      		breq .L16
 419               	.LM33:
 420 010a C801      		movw r24,r16
 421 010c 0E94 0000 		call xTaskRemoveFromEventList
 422 0110 8111      		cpse r24,__zero_reg__
1197:../../freeRtos/Source/queue.c **** 				{
1198:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 424               	.LM34:
 425 0112 0E94 0000 		call vTaskMissedYield
 426               	.L17:
1199:../../freeRtos/Source/queue.c **** 				}
1200:../../freeRtos/Source/queue.c **** 
1201:../../freeRtos/Source/queue.c **** 				--( pxQueue->xRxLock );
 428               	.LM35:
 429 0116 8D8D      		ldd r24,Y+29
 430 0118 8150      		subi r24,lo8(-(-1))
 431 011a 8D8F      		std Y+29,r24
 432 011c 00C0      		rjmp .L15
 433               	.L16:
1202:../../freeRtos/Source/queue.c **** 			}
1203:../../freeRtos/Source/queue.c **** 			else
1204:../../freeRtos/Source/queue.c **** 			{
1205:../../freeRtos/Source/queue.c **** 				break;
1206:../../freeRtos/Source/queue.c **** 			}
1207:../../freeRtos/Source/queue.c **** 		}
1208:../../freeRtos/Source/queue.c **** 
1209:../../freeRtos/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 435               	.LM36:
 436 011e 8FEF      		ldi r24,lo8(-1)
 437 0120 8D8F      		std Y+29,r24
1210:../../freeRtos/Source/queue.c **** 	}
1211:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 439               	.LM37:
 440               	/* #APP */
 441               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 442 0122 0F90      		pop		__tmp_reg__
 443               	 ;  0 "" 2
 444               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 445 0124 0FBE      		out		__SREG__, __tmp_reg__
 446               	 ;  0 "" 2
 447               	/* epilogue start */
1212:../../freeRtos/Source/queue.c **** }
 449               	.LM38:
 450               	/* #NOAPP */
 451 0126 DF91      		pop r29
 452 0128 CF91      		pop r28
 453 012a 1F91      		pop r17
 454 012c 0F91      		pop r16
 455 012e 0895      		ret
 457               	.Lscope3:
 459               		.stabd	78,0,0
 463               	.global	xQueueCreate
 465               	xQueueCreate:
 466               		.stabd	46,0,0
 249:../../freeRtos/Source/queue.c **** {
 468               	.LM39:
 469               	.LFBB4:
 470 0130 CF92      		push r12
 471 0132 DF92      		push r13
 472 0134 EF92      		push r14
 473 0136 FF92      		push r15
 474 0138 0F93      		push r16
 475 013a 1F93      		push r17
 476 013c CF93      		push r28
 477 013e DF93      		push r29
 478               	/* prologue: function */
 479               	/* frame size = 0 */
 480               	/* stack size = 8 */
 481               	.L__stack_usage = 8
 482 0140 D82E      		mov r13,r24
 483 0142 C62E      		mov r12,r22
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 485               	.LM40:
 486 0144 8823      		tst r24
 487 0146 01F0      		breq .L39
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 489               	.LM41:
 490 0148 8FE1      		ldi r24,lo8(31)
 491 014a 90E0      		ldi r25,0
 492 014c 0E94 0000 		call pvPortMalloc
 493 0150 EC01      		movw r28,r24
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 495               	.LM42:
 496 0152 0097      		sbiw r24,0
 497 0154 01F0      		breq .L39
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 499               	.LM43:
 500 0156 EC2C      		mov r14,r12
 501 0158 F12C      		mov r15,__zero_reg__
 502 015a DC9C      		mul r13,r12
 503 015c 8001      		movw r16,r0
 504 015e 1124      		clr __zero_reg__
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 506               	.LM44:
 507 0160 C801      		movw r24,r16
 508 0162 0196      		adiw r24,1
 509 0164 0E94 0000 		call pvPortMalloc
 510 0168 9983      		std Y+1,r25
 511 016a 8883      		st Y,r24
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 513               	.LM45:
 514 016c 0097      		sbiw r24,0
 515 016e 01F0      		breq .L35
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 517               	.LM46:
 518 0170 9C01      		movw r18,r24
 519 0172 200F      		add r18,r16
 520 0174 311F      		adc r19,r17
 521 0176 3B83      		std Y+3,r19
 522 0178 2A83      		std Y+2,r18
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 524               	.LM47:
 525 017a 1A8E      		std Y+26,__zero_reg__
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 527               	.LM48:
 528 017c 9D83      		std Y+5,r25
 529 017e 8C83      		std Y+4,r24
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 531               	.LM49:
 532 0180 0E19      		sub r16,r14
 533 0182 1F09      		sbc r17,r15
 534 0184 080F      		add r16,r24
 535 0186 191F      		adc r17,r25
 536 0188 1F83      		std Y+7,r17
 537 018a 0E83      		std Y+6,r16
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 539               	.LM50:
 540 018c DB8E      		std Y+27,r13
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 542               	.LM51:
 543 018e CC8E      		std Y+28,r12
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 545               	.LM52:
 546 0190 8FEF      		ldi r24,lo8(-1)
 547 0192 8D8F      		std Y+29,r24
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 549               	.LM53:
 550 0194 8E8F      		std Y+30,r24
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 552               	.LM54:
 553 0196 CE01      		movw r24,r28
 554 0198 0896      		adiw r24,8
 555 019a 0E94 0000 		call vListInitialise
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 557               	.LM55:
 558 019e CE01      		movw r24,r28
 559 01a0 4196      		adiw r24,17
 560 01a2 0E94 0000 		call vListInitialise
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 562               	.LM56:
 563 01a6 CE01      		movw r24,r28
 564 01a8 00C0      		rjmp .L33
 565               	.L35:
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 567               	.LM57:
 568 01aa CE01      		movw r24,r28
 569 01ac 0E94 0000 		call vPortFree
 570               	.L39:
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 572               	.LM58:
 573 01b0 80E0      		ldi r24,0
 574 01b2 90E0      		ldi r25,0
 575               	.L33:
 576               	/* epilogue start */
 295:../../freeRtos/Source/queue.c **** }
 578               	.LM59:
 579 01b4 DF91      		pop r29
 580 01b6 CF91      		pop r28
 581 01b8 1F91      		pop r17
 582 01ba 0F91      		pop r16
 583 01bc FF90      		pop r15
 584 01be EF90      		pop r14
 585 01c0 DF90      		pop r13
 586 01c2 CF90      		pop r12
 587 01c4 0895      		ret
 592               	.Lscope4:
 594               		.stabd	78,0,0
 599               	.global	xQueueCreateExternal
 601               	xQueueCreateExternal:
 602               		.stabd	46,0,0
 298:../../freeRtos/Source/queue.c **** {
 604               	.LM60:
 605               	.LFBB5:
 606 01c6 CF92      		push r12
 607 01c8 DF92      		push r13
 608 01ca FF92      		push r15
 609 01cc 0F93      		push r16
 610 01ce 1F93      		push r17
 611 01d0 CF93      		push r28
 612 01d2 DF93      		push r29
 613 01d4 1F92      		push __zero_reg__
 614 01d6 CDB7      		in r28,__SP_L__
 615 01d8 DEB7      		in r29,__SP_H__
 616               	/* prologue: function */
 617               	/* frame size = 1 */
 618               	/* stack size = 8 */
 619               	.L__stack_usage = 8
 620 01da F82E      		mov r15,r24
 621 01dc 8A01      		movw r16,r20
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 623               	.LM61:
 624 01de 8823      		tst r24
 625 01e0 01F0      		breq .L48
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 627               	.LM62:
 628 01e2 8FE1      		ldi r24,lo8(31)
 629 01e4 90E0      		ldi r25,0
 630 01e6 6983      		std Y+1,r22
 631 01e8 0E94 0000 		call pvPortMalloc
 632 01ec 6C01      		movw r12,r24
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 634               	.LM63:
 635 01ee 6981      		ldd r22,Y+1
 636 01f0 0097      		sbiw r24,0
 637 01f2 01F0      		breq .L48
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 639               	.LM64:
 640 01f4 FC01      		movw r30,r24
 641 01f6 1183      		std Z+1,r17
 642 01f8 0083      		st Z,r16
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 644               	.LM65:
 645 01fa 0115      		cp r16,__zero_reg__
 646 01fc 1105      		cpc r17,__zero_reg__
 647 01fe 01F0      		breq .L44
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 649               	.LM66:
 650 0200 F69E      		mul r15,r22
 651 0202 9001      		movw r18,r0
 652 0204 1124      		clr __zero_reg__
 653 0206 A801      		movw r20,r16
 654 0208 420F      		add r20,r18
 655 020a 531F      		adc r21,r19
 656 020c 5383      		std Z+3,r21
 657 020e 4283      		std Z+2,r20
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 659               	.LM67:
 660 0210 128E      		std Z+26,__zero_reg__
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 662               	.LM68:
 663 0212 1583      		std Z+5,r17
 664 0214 0483      		std Z+4,r16
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 666               	.LM69:
 667 0216 261B      		sub r18,r22
 668 0218 3109      		sbc r19,__zero_reg__
 669 021a 200F      		add r18,r16
 670 021c 311F      		adc r19,r17
 671 021e 3783      		std Z+7,r19
 672 0220 2683      		std Z+6,r18
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 674               	.LM70:
 675 0222 F38E      		std Z+27,r15
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 677               	.LM71:
 678 0224 648F      		std Z+28,r22
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 680               	.LM72:
 681 0226 8FEF      		ldi r24,lo8(-1)
 682 0228 858F      		std Z+29,r24
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 684               	.LM73:
 685 022a 868F      		std Z+30,r24
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 687               	.LM74:
 688 022c C601      		movw r24,r12
 689 022e 0896      		adiw r24,8
 690 0230 0E94 0000 		call vListInitialise
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 692               	.LM75:
 693 0234 C601      		movw r24,r12
 694 0236 4196      		adiw r24,17
 695 0238 0E94 0000 		call vListInitialise
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 697               	.LM76:
 698 023c C601      		movw r24,r12
 699 023e 00C0      		rjmp .L42
 700               	.L44:
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 702               	.LM77:
 703 0240 0E94 0000 		call vPortFree
 704               	.L48:
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 706               	.LM78:
 707 0244 80E0      		ldi r24,0
 708 0246 90E0      		ldi r25,0
 709               	.L42:
 710               	/* epilogue start */
 344:../../freeRtos/Source/queue.c **** }
 712               	.LM79:
 713 0248 0F90      		pop __tmp_reg__
 714 024a DF91      		pop r29
 715 024c CF91      		pop r28
 716 024e 1F91      		pop r17
 717 0250 0F91      		pop r16
 718 0252 FF90      		pop r15
 719 0254 DF90      		pop r13
 720 0256 CF90      		pop r12
 721 0258 0895      		ret
 726               	.Lscope5:
 728               		.stabd	78,0,0
 734               	.global	xQueueGenericSend
 736               	xQueueGenericSend:
 737               		.stabd	46,0,0
 502:../../freeRtos/Source/queue.c **** {
 739               	.LM80:
 740               	.LFBB6:
 741 025a BF92      		push r11
 742 025c CF92      		push r12
 743 025e DF92      		push r13
 744 0260 EF92      		push r14
 745 0262 FF92      		push r15
 746 0264 0F93      		push r16
 747 0266 1F93      		push r17
 748 0268 CF93      		push r28
 749 026a DF93      		push r29
 750 026c 00D0      		rcall .
 751 026e 00D0      		rcall .
 752 0270 1F92      		push __zero_reg__
 753 0272 CDB7      		in r28,__SP_L__
 754 0274 DEB7      		in r29,__SP_H__
 755               	/* prologue: function */
 756               	/* frame size = 5 */
 757               	/* stack size = 14 */
 758               	.L__stack_usage = 14
 759 0276 8C01      		movw r16,r24
 760 0278 6B01      		movw r12,r22
 761 027a 5D83      		std Y+5,r21
 762 027c 4C83      		std Y+4,r20
 763 027e B22E      		mov r11,r18
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 765               	.LM81:
 766 0280 30E0      		ldi r19,0
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 768               	.LM82:
 769 0282 7C01      		movw r14,r24
 770 0284 88E0      		ldi r24,8
 771 0286 E80E      		add r14,r24
 772 0288 F11C      		adc r15,__zero_reg__
 773               	.L50:
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 775               	.LM83:
 776               	/* #APP */
 777               	 ;  511 "../../freeRtos/Source/queue.c" 1
 778 028a 0FB6      		in		__tmp_reg__, __SREG__
 779               	 ;  0 "" 2
 780               	 ;  511 "../../freeRtos/Source/queue.c" 1
 781 028c F894      		cli
 782               	 ;  0 "" 2
 783               	 ;  511 "../../freeRtos/Source/queue.c" 1
 784 028e 0F92      		push	__tmp_reg__
 785               	 ;  0 "" 2
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 787               	.LM84:
 788               	/* #NOAPP */
 789 0290 F801      		movw r30,r16
 790 0292 928D      		ldd r25,Z+26
 791 0294 838D      		ldd r24,Z+27
 792 0296 9817      		cp r25,r24
 793 0298 00F4      		brsh .L51
 518:../../freeRtos/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 795               	.LM85:
 796 029a 4B2D      		mov r20,r11
 797 029c B601      		movw r22,r12
 798 029e C801      		movw r24,r16
 799 02a0 0E94 0000 		call prvCopyDataToQueue
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801               	.LM86:
 802 02a4 F801      		movw r30,r16
 803 02a6 8189      		ldd r24,Z+17
 804 02a8 8823      		tst r24
 805 02aa 01F0      		breq .L53
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 807               	.LM87:
 808 02ac C801      		movw r24,r16
 809 02ae 4196      		adiw r24,17
 810 02b0 0E94 0000 		call xTaskRemoveFromEventList
 811 02b4 8130      		cpi r24,lo8(1)
 812 02b6 01F4      		brne .L53
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 814               	.LM88:
 815 02b8 0E94 0000 		call vPortYield
 816               	.L53:
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 818               	.LM89:
 819               	/* #APP */
 820               	 ;  534 "../../freeRtos/Source/queue.c" 1
 821 02bc 0F90      		pop		__tmp_reg__
 822               	 ;  0 "" 2
 823               	 ;  534 "../../freeRtos/Source/queue.c" 1
 824 02be 0FBE      		out		__SREG__, __tmp_reg__
 825               	 ;  0 "" 2
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 827               	.LM90:
 828               	/* #NOAPP */
 829 02c0 81E0      		ldi r24,lo8(1)
 830 02c2 00C0      		rjmp .L55
 831               	.L51:
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 833               	.LM91:
 834 02c4 8C81      		ldd r24,Y+4
 835 02c6 9D81      		ldd r25,Y+5
 836 02c8 892B      		or r24,r25
 837 02ca 01F4      		brne .L56
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 839               	.LM92:
 840               	/* #APP */
 841               	 ;  546 "../../freeRtos/Source/queue.c" 1
 842 02cc 0F90      		pop		__tmp_reg__
 843               	 ;  0 "" 2
 844               	 ;  546 "../../freeRtos/Source/queue.c" 1
 845 02ce 0FBE      		out		__SREG__, __tmp_reg__
 846               	 ;  0 "" 2
 847               	/* #NOAPP */
 848 02d0 00C0      		rjmp .L63
 849               	.L56:
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 851               	.LM93:
 852 02d2 3111      		cpse r19,__zero_reg__
 853 02d4 00C0      		rjmp .L57
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 855               	.LM94:
 856 02d6 CE01      		movw r24,r28
 857 02d8 0196      		adiw r24,1
 858 02da 0E94 0000 		call vTaskSetTimeOutState
 859               	.L57:
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 861               	.LM95:
 862               	/* #APP */
 863               	 ;  562 "../../freeRtos/Source/queue.c" 1
 864 02de 0F90      		pop		__tmp_reg__
 865               	 ;  0 "" 2
 866               	 ;  562 "../../freeRtos/Source/queue.c" 1
 867 02e0 0FBE      		out		__SREG__, __tmp_reg__
 868               	 ;  0 "" 2
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 870               	.LM96:
 871               	/* #NOAPP */
 872 02e2 0E94 0000 		call vTaskSuspendAll
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 874               	.LM97:
 875               	/* #APP */
 876               	 ;  568 "../../freeRtos/Source/queue.c" 1
 877 02e6 0FB6      		in		__tmp_reg__, __SREG__
 878               	 ;  0 "" 2
 879               	 ;  568 "../../freeRtos/Source/queue.c" 1
 880 02e8 F894      		cli
 881               	 ;  0 "" 2
 882               	 ;  568 "../../freeRtos/Source/queue.c" 1
 883 02ea 0F92      		push	__tmp_reg__
 884               	 ;  0 "" 2
 885               	/* #NOAPP */
 886 02ec F801      		movw r30,r16
 887 02ee 858D      		ldd r24,Z+29
 888 02f0 8F3F      		cpi r24,lo8(-1)
 889 02f2 01F4      		brne .L58
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 891               	.LM98:
 892 02f4 158E      		std Z+29,__zero_reg__
 893               	.L58:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 895               	.LM99:
 896 02f6 F801      		movw r30,r16
 897 02f8 868D      		ldd r24,Z+30
 898 02fa 8F3F      		cpi r24,lo8(-1)
 899 02fc 01F4      		brne .L59
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 901               	.LM100:
 902 02fe 168E      		std Z+30,__zero_reg__
 903               	.L59:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 905               	.LM101:
 906               	/* #APP */
 907               	 ;  568 "../../freeRtos/Source/queue.c" 1
 908 0300 0F90      		pop		__tmp_reg__
 909               	 ;  0 "" 2
 910               	 ;  568 "../../freeRtos/Source/queue.c" 1
 911 0302 0FBE      		out		__SREG__, __tmp_reg__
 912               	 ;  0 "" 2
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 914               	.LM102:
 915               	/* #NOAPP */
 916 0304 BE01      		movw r22,r28
 917 0306 6C5F      		subi r22,-4
 918 0308 7F4F      		sbci r23,-1
 919 030a CE01      		movw r24,r28
 920 030c 0196      		adiw r24,1
 921 030e 0E94 0000 		call xTaskCheckForTimeOut
 922 0312 8111      		cpse r24,__zero_reg__
 923 0314 00C0      		rjmp .L60
 924               	.LBB4:
 925               	.LBB5:
1213:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1214:../../freeRtos/Source/queue.c **** 
1215:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1216:../../freeRtos/Source/queue.c **** {
1217:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1218:../../freeRtos/Source/queue.c **** 
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1222:../../freeRtos/Source/queue.c **** 
1223:../../freeRtos/Source/queue.c **** 	return xReturn;
1224:../../freeRtos/Source/queue.c **** }
1225:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1226:../../freeRtos/Source/queue.c **** 
1227:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1228:../../freeRtos/Source/queue.c **** {
1229:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:../../freeRtos/Source/queue.c **** 
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1232:../../freeRtos/Source/queue.c **** 
1233:../../freeRtos/Source/queue.c **** 	return xReturn;
1234:../../freeRtos/Source/queue.c **** }
1235:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1236:../../freeRtos/Source/queue.c **** 
1237:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1238:../../freeRtos/Source/queue.c **** {
1239:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1240:../../freeRtos/Source/queue.c **** 
1241:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 927               	.LM103:
 928               	/* #APP */
 929               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 930 0316 0FB6      		in		__tmp_reg__, __SREG__
 931               	 ;  0 "" 2
 932               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 933 0318 F894      		cli
 934               	 ;  0 "" 2
 935               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 936 031a 0F92      		push	__tmp_reg__
 937               	 ;  0 "" 2
1242:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 939               	.LM104:
 940               	/* #NOAPP */
 941 031c F801      		movw r30,r16
 942 031e 928D      		ldd r25,Z+26
1243:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 944               	.LM105:
 945               	/* #APP */
 946               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 947 0320 0F90      		pop		__tmp_reg__
 948               	 ;  0 "" 2
 949               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 950 0322 0FBE      		out		__SREG__, __tmp_reg__
 951               	 ;  0 "" 2
 952               	/* #NOAPP */
 953               	.LBE5:
 954               	.LBE4:
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 956               	.LM106:
 957 0324 F801      		movw r30,r16
 958 0326 838D      		ldd r24,Z+27
 959 0328 9813      		cpse r25,r24
 960 032a 00C0      		rjmp .L61
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 962               	.LM107:
 963 032c 6C81      		ldd r22,Y+4
 964 032e 7D81      		ldd r23,Y+5
 965 0330 C701      		movw r24,r14
 966 0332 0E94 0000 		call vTaskPlaceOnEventList
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 968               	.LM108:
 969 0336 C801      		movw r24,r16
 970 0338 0E94 0000 		call prvUnlockQueue
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 972               	.LM109:
 973 033c 0E94 0000 		call xTaskResumeAll
 974 0340 8823      		tst r24
 975 0342 01F0      		breq .L64
 976               	.L62:
 977 0344 31E0      		ldi r19,lo8(1)
 978 0346 00C0      		rjmp .L50
 979               	.L64:
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 981               	.LM110:
 982 0348 0E94 0000 		call vPortYield
 983 034c 00C0      		rjmp .L62
 984               	.L61:
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 986               	.LM111:
 987 034e C801      		movw r24,r16
 988 0350 0E94 0000 		call prvUnlockQueue
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 990               	.LM112:
 991 0354 0E94 0000 		call xTaskResumeAll
 992 0358 00C0      		rjmp .L62
 993               	.L60:
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 995               	.LM113:
 996 035a C801      		movw r24,r16
 997 035c 0E94 0000 		call prvUnlockQueue
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 999               	.LM114:
 1000 0360 0E94 0000 		call xTaskResumeAll
 1001               	.L63:
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 1003               	.LM115:
 1004 0364 80E0      		ldi r24,0
 1005               	.L55:
 1006               	/* epilogue start */
 614:../../freeRtos/Source/queue.c **** }
 1008               	.LM116:
 1009 0366 0F90      		pop __tmp_reg__
 1010 0368 0F90      		pop __tmp_reg__
 1011 036a 0F90      		pop __tmp_reg__
 1012 036c 0F90      		pop __tmp_reg__
 1013 036e 0F90      		pop __tmp_reg__
 1014 0370 DF91      		pop r29
 1015 0372 CF91      		pop r28
 1016 0374 1F91      		pop r17
 1017 0376 0F91      		pop r16
 1018 0378 FF90      		pop r15
 1019 037a EF90      		pop r14
 1020 037c DF90      		pop r13
 1021 037e CF90      		pop r12
 1022 0380 BF90      		pop r11
 1023 0382 0895      		ret
 1029               	.Lscope6:
 1031               		.stabd	78,0,0
 1037               	.global	xQueueGenericSendFromISR
 1039               	xQueueGenericSendFromISR:
 1040               		.stabd	46,0,0
 818:../../freeRtos/Source/queue.c **** {
 1042               	.LM117:
 1043               	.LFBB7:
 1044 0384 0F93      		push r16
 1045 0386 1F93      		push r17
 1046 0388 CF93      		push r28
 1047 038a DF93      		push r29
 1048               	/* prologue: function */
 1049               	/* frame size = 0 */
 1050               	/* stack size = 4 */
 1051               	.L__stack_usage = 4
 1052 038c EC01      		movw r28,r24
 1053 038e 8A01      		movw r16,r20
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1055               	.LM118:
 1056 0390 9A8D      		ldd r25,Y+26
 1057 0392 8B8D      		ldd r24,Y+27
 1058 0394 9817      		cp r25,r24
 1059 0396 00F4      		brsh .L70
 833:../../freeRtos/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1061               	.LM119:
 1062 0398 422F      		mov r20,r18
 1063 039a CE01      		movw r24,r28
 1064 039c 0E94 0000 		call prvCopyDataToQueue
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1066               	.LM120:
 1067 03a0 8E8D      		ldd r24,Y+30
 1068 03a2 8F3F      		cpi r24,lo8(-1)
 1069 03a4 01F4      		brne .L67
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1071               	.LM121:
 1072 03a6 8989      		ldd r24,Y+17
 1073 03a8 8823      		tst r24
 1074 03aa 01F0      		breq .L74
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1076               	.LM122:
 1077 03ac CE01      		movw r24,r28
 1078 03ae 4196      		adiw r24,17
 1079 03b0 0E94 0000 		call xTaskRemoveFromEventList
 1080 03b4 8823      		tst r24
 1081 03b6 01F0      		breq .L74
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 1083               	.LM123:
 1084 03b8 81E0      		ldi r24,lo8(1)
 1085 03ba F801      		movw r30,r16
 1086 03bc 8083      		st Z,r24
 1087 03be 00C0      		rjmp .L66
 1088               	.L67:
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 1090               	.LM124:
 1091 03c0 8F5F      		subi r24,lo8(-(1))
 1092 03c2 8E8F      		std Y+30,r24
 1093               	.L74:
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1095               	.LM125:
 1096 03c4 81E0      		ldi r24,lo8(1)
 1097 03c6 00C0      		rjmp .L66
 1098               	.L70:
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1100               	.LM126:
 1101 03c8 80E0      		ldi r24,0
 1102               	.L66:
 1103               	/* epilogue start */
 867:../../freeRtos/Source/queue.c **** }
 1105               	.LM127:
 1106 03ca DF91      		pop r29
 1107 03cc CF91      		pop r28
 1108 03ce 1F91      		pop r17
 1109 03d0 0F91      		pop r16
 1110 03d2 0895      		ret
 1115               	.Lscope7:
 1117               		.stabd	78,0,0
 1123               	.global	xQueueGenericReceive
 1125               	xQueueGenericReceive:
 1126               		.stabd	46,0,0
 871:../../freeRtos/Source/queue.c **** {
 1128               	.LM128:
 1129               	.LFBB8:
 1130 03d4 BF92      		push r11
 1131 03d6 CF92      		push r12
 1132 03d8 DF92      		push r13
 1133 03da EF92      		push r14
 1134 03dc FF92      		push r15
 1135 03de 0F93      		push r16
 1136 03e0 1F93      		push r17
 1137 03e2 CF93      		push r28
 1138 03e4 DF93      		push r29
 1139 03e6 00D0      		rcall .
 1140 03e8 00D0      		rcall .
 1141 03ea 1F92      		push __zero_reg__
 1142 03ec CDB7      		in r28,__SP_L__
 1143 03ee DEB7      		in r29,__SP_H__
 1144               	/* prologue: function */
 1145               	/* frame size = 5 */
 1146               	/* stack size = 14 */
 1147               	.L__stack_usage = 14
 1148 03f0 8C01      		movw r16,r24
 1149 03f2 6B01      		movw r12,r22
 1150 03f4 5D83      		std Y+5,r21
 1151 03f6 4C83      		std Y+4,r20
 1152 03f8 B22E      		mov r11,r18
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1154               	.LM129:
 1155 03fa 30E0      		ldi r19,0
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1157               	.LM130:
 1158 03fc 7C01      		movw r14,r24
 1159 03fe 81E1      		ldi r24,17
 1160 0400 E80E      		add r14,r24
 1161 0402 F11C      		adc r15,__zero_reg__
 1162               	.L76:
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 1164               	.LM131:
 1165               	/* #APP */
 1166               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1167 0404 0FB6      		in		__tmp_reg__, __SREG__
 1168               	 ;  0 "" 2
 1169               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1170 0406 F894      		cli
 1171               	 ;  0 "" 2
 1172               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1173 0408 0F92      		push	__tmp_reg__
 1174               	 ;  0 "" 2
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1176               	.LM132:
 1177               	/* #NOAPP */
 1178 040a F801      		movw r30,r16
 1179 040c 828D      		ldd r24,Z+26
 1180 040e 8823      		tst r24
 1181 0410 01F0      		breq .L77
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 1183               	.LM133:
 1184 0412 E680      		ldd r14,Z+6
 1185 0414 F780      		ldd r15,Z+7
 891:../../freeRtos/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1187               	.LM134:
 1188 0416 B601      		movw r22,r12
 1189 0418 C801      		movw r24,r16
 1190 041a 0E94 0000 		call prvCopyDataFromQueue
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1192               	.LM135:
 1193 041e F801      		movw r30,r16
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1195               	.LM136:
 1196 0420 B110      		cpse r11,__zero_reg__
 1197 0422 00C0      		rjmp .L78
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1199               	.LM137:
 1200 0424 828D      		ldd r24,Z+26
 1201 0426 8150      		subi r24,lo8(-(-1))
 1202 0428 828F      		std Z+26,r24
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1204               	.LM138:
 1205 042a 8085      		ldd r24,Z+8
 1206 042c 8823      		tst r24
 1207 042e 01F0      		breq .L80
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1209               	.LM139:
 1210 0430 C801      		movw r24,r16
 1211 0432 0896      		adiw r24,8
 1212 0434 0E94 0000 		call xTaskRemoveFromEventList
 1213 0438 8130      		cpi r24,lo8(1)
 1214 043a 01F4      		brne .L80
 1215               	.L82:
 915:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 1217               	.LM140:
 1218 043c 0E94 0000 		call vPortYield
 1219 0440 00C0      		rjmp .L80
 1220               	.L78:
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 1222               	.LM141:
 1223 0442 F782      		std Z+7,r15
 1224 0444 E682      		std Z+6,r14
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1226               	.LM142:
 1227 0446 8189      		ldd r24,Z+17
 1228 0448 8823      		tst r24
 1229 044a 01F0      		breq .L80
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1231               	.LM143:
 1232 044c C801      		movw r24,r16
 1233 044e 4196      		adiw r24,17
 1234 0450 0E94 0000 		call xTaskRemoveFromEventList
 1235 0454 8111      		cpse r24,__zero_reg__
 1236 0456 00C0      		rjmp .L82
 1237               	.L80:
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 1239               	.LM144:
 1240               	/* #APP */
 1241               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1242 0458 0F90      		pop		__tmp_reg__
 1243               	 ;  0 "" 2
 1244               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1245 045a 0FBE      		out		__SREG__, __tmp_reg__
 1246               	 ;  0 "" 2
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 1248               	.LM145:
 1249               	/* #NOAPP */
 1250 045c 81E0      		ldi r24,lo8(1)
 1251 045e 00C0      		rjmp .L83
 1252               	.L77:
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1254               	.LM146:
 1255 0460 8C81      		ldd r24,Y+4
 1256 0462 9D81      		ldd r25,Y+5
 1257 0464 892B      		or r24,r25
 1258 0466 01F4      		brne .L84
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 1260               	.LM147:
 1261               	/* #APP */
 1262               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1263 0468 0F90      		pop		__tmp_reg__
 1264               	 ;  0 "" 2
 1265               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1266 046a 0FBE      		out		__SREG__, __tmp_reg__
 1267               	 ;  0 "" 2
 1268               	/* #NOAPP */
 1269 046c 00C0      		rjmp .L94
 1270               	.L84:
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1272               	.LM148:
 1273 046e 3111      		cpse r19,__zero_reg__
 1274 0470 00C0      		rjmp .L85
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1276               	.LM149:
 1277 0472 CE01      		movw r24,r28
 1278 0474 0196      		adiw r24,1
 1279 0476 0E94 0000 		call vTaskSetTimeOutState
 1280               	.L85:
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 1282               	.LM150:
 1283               	/* #APP */
 1284               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1285 047a 0F90      		pop		__tmp_reg__
 1286               	 ;  0 "" 2
 1287               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1288 047c 0FBE      		out		__SREG__, __tmp_reg__
 1289               	 ;  0 "" 2
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 1291               	.LM151:
 1292               	/* #NOAPP */
 1293 047e 0E94 0000 		call vTaskSuspendAll
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1295               	.LM152:
 1296               	/* #APP */
 1297               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1298 0482 0FB6      		in		__tmp_reg__, __SREG__
 1299               	 ;  0 "" 2
 1300               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1301 0484 F894      		cli
 1302               	 ;  0 "" 2
 1303               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1304 0486 0F92      		push	__tmp_reg__
 1305               	 ;  0 "" 2
 1306               	/* #NOAPP */
 1307 0488 F801      		movw r30,r16
 1308 048a 858D      		ldd r24,Z+29
 1309 048c 8F3F      		cpi r24,lo8(-1)
 1310 048e 01F4      		brne .L86
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1312               	.LM153:
 1313 0490 158E      		std Z+29,__zero_reg__
 1314               	.L86:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1316               	.LM154:
 1317 0492 F801      		movw r30,r16
 1318 0494 868D      		ldd r24,Z+30
 1319 0496 8F3F      		cpi r24,lo8(-1)
 1320 0498 01F4      		brne .L87
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1322               	.LM155:
 1323 049a 168E      		std Z+30,__zero_reg__
 1324               	.L87:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1326               	.LM156:
 1327               	/* #APP */
 1328               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1329 049c 0F90      		pop		__tmp_reg__
 1330               	 ;  0 "" 2
 1331               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1332 049e 0FBE      		out		__SREG__, __tmp_reg__
 1333               	 ;  0 "" 2
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1335               	.LM157:
 1336               	/* #NOAPP */
 1337 04a0 BE01      		movw r22,r28
 1338 04a2 6C5F      		subi r22,-4
 1339 04a4 7F4F      		sbci r23,-1
 1340 04a6 CE01      		movw r24,r28
 1341 04a8 0196      		adiw r24,1
 1342 04aa 0E94 0000 		call xTaskCheckForTimeOut
 1343 04ae 8111      		cpse r24,__zero_reg__
 1344 04b0 00C0      		rjmp .L88
 1345               	.LBB8:
 1346               	.LBB9:
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1348               	.LM158:
 1349               	/* #APP */
 1350               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1351 04b2 0FB6      		in		__tmp_reg__, __SREG__
 1352               	 ;  0 "" 2
 1353               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1354 04b4 F894      		cli
 1355               	 ;  0 "" 2
 1356               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1357 04b6 0F92      		push	__tmp_reg__
 1358               	 ;  0 "" 2
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1360               	.LM159:
 1361               	/* #NOAPP */
 1362 04b8 F801      		movw r30,r16
 1363 04ba 828D      		ldd r24,Z+26
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1365               	.LM160:
 1366               	/* #APP */
 1367               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1368 04bc 0F90      		pop		__tmp_reg__
 1369               	 ;  0 "" 2
 1370               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1371 04be 0FBE      		out		__SREG__, __tmp_reg__
 1372               	 ;  0 "" 2
 1373               	/* #NOAPP */
 1374               	.LBE9:
 1375               	.LBE8:
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 1377               	.LM161:
 1378 04c0 8111      		cpse r24,__zero_reg__
 1379 04c2 00C0      		rjmp .L89
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1381               	.LM162:
 1382 04c4 6C81      		ldd r22,Y+4
 1383 04c6 7D81      		ldd r23,Y+5
 1384 04c8 C701      		movw r24,r14
 1385 04ca 0E94 0000 		call vTaskPlaceOnEventList
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1387               	.LM163:
 1388 04ce C801      		movw r24,r16
 1389 04d0 0E94 0000 		call prvUnlockQueue
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 1391               	.LM164:
 1392 04d4 0E94 0000 		call xTaskResumeAll
 1393 04d8 8823      		tst r24
 1394 04da 01F0      		breq .L95
 1395               	.L90:
 1396 04dc 31E0      		ldi r19,lo8(1)
 1397 04de 00C0      		rjmp .L76
 1398               	.L95:
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 1400               	.LM165:
 1401 04e0 0E94 0000 		call vPortYield
 1402 04e4 00C0      		rjmp .L90
 1403               	.L89:
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1405               	.LM166:
 1406 04e6 C801      		movw r24,r16
 1407 04e8 0E94 0000 		call prvUnlockQueue
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 1409               	.LM167:
 1410 04ec 0E94 0000 		call xTaskResumeAll
 1411 04f0 00C0      		rjmp .L90
 1412               	.L88:
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1414               	.LM168:
 1415 04f2 C801      		movw r24,r16
 1416 04f4 0E94 0000 		call prvUnlockQueue
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 1418               	.LM169:
 1419 04f8 0E94 0000 		call xTaskResumeAll
 1420               	.L94:
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
 1422               	.LM170:
 1423 04fc 80E0      		ldi r24,0
 1424               	.L83:
 1425               	/* epilogue start */
1014:../../freeRtos/Source/queue.c **** }
 1427               	.LM171:
 1428 04fe 0F90      		pop __tmp_reg__
 1429 0500 0F90      		pop __tmp_reg__
 1430 0502 0F90      		pop __tmp_reg__
 1431 0504 0F90      		pop __tmp_reg__
 1432 0506 0F90      		pop __tmp_reg__
 1433 0508 DF91      		pop r29
 1434 050a CF91      		pop r28
 1435 050c 1F91      		pop r17
 1436 050e 0F91      		pop r16
 1437 0510 FF90      		pop r15
 1438 0512 EF90      		pop r14
 1439 0514 DF90      		pop r13
 1440 0516 CF90      		pop r12
 1441 0518 BF90      		pop r11
 1442 051a 0895      		ret
 1449               	.Lscope8:
 1451               		.stabd	78,0,0
 1456               	.global	xQueueReceiveFromISR
 1458               	xQueueReceiveFromISR:
 1459               		.stabd	46,0,0
1018:../../freeRtos/Source/queue.c **** {
 1461               	.LM172:
 1462               	.LFBB9:
 1463 051c 0F93      		push r16
 1464 051e 1F93      		push r17
 1465 0520 CF93      		push r28
 1466 0522 DF93      		push r29
 1467               	/* prologue: function */
 1468               	/* frame size = 0 */
 1469               	/* stack size = 4 */
 1470               	.L__stack_usage = 4
 1471 0524 EC01      		movw r28,r24
 1472 0526 8A01      		movw r16,r20
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1474               	.LM173:
 1475 0528 8A8D      		ldd r24,Y+26
 1476 052a 8823      		tst r24
 1477 052c 01F0      		breq .L101
1029:../../freeRtos/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1479               	.LM174:
 1480 052e CE01      		movw r24,r28
 1481 0530 0E94 0000 		call prvCopyDataFromQueue
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1483               	.LM175:
 1484 0534 8A8D      		ldd r24,Y+26
 1485 0536 8150      		subi r24,lo8(-(-1))
 1486 0538 8A8F      		std Y+26,r24
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1488               	.LM176:
 1489 053a 8D8D      		ldd r24,Y+29
 1490 053c 8F3F      		cpi r24,lo8(-1)
 1491 053e 01F4      		brne .L98
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 1493               	.LM177:
 1494 0540 8885      		ldd r24,Y+8
 1495 0542 8823      		tst r24
 1496 0544 01F0      		breq .L105
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1498               	.LM178:
 1499 0546 CE01      		movw r24,r28
 1500 0548 0896      		adiw r24,8
 1501 054a 0E94 0000 		call xTaskRemoveFromEventList
 1502 054e 8823      		tst r24
 1503 0550 01F0      		breq .L105
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 1505               	.LM179:
 1506 0552 81E0      		ldi r24,lo8(1)
 1507 0554 F801      		movw r30,r16
 1508 0556 8083      		st Z,r24
 1509 0558 00C0      		rjmp .L97
 1510               	.L98:
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
 1512               	.LM180:
 1513 055a 8F5F      		subi r24,lo8(-(1))
 1514 055c 8D8F      		std Y+29,r24
 1515               	.L105:
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1517               	.LM181:
 1518 055e 81E0      		ldi r24,lo8(1)
 1519 0560 00C0      		rjmp .L97
 1520               	.L101:
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 1522               	.LM182:
 1523 0562 80E0      		ldi r24,0
 1524               	.L97:
 1525               	/* epilogue start */
1065:../../freeRtos/Source/queue.c **** }
 1527               	.LM183:
 1528 0564 DF91      		pop r29
 1529 0566 CF91      		pop r28
 1530 0568 1F91      		pop r17
 1531 056a 0F91      		pop r16
 1532 056c 0895      		ret
 1537               	.Lscope9:
 1539               		.stabd	78,0,0
 1542               	.global	uxQueueMessagesWaiting
 1544               	uxQueueMessagesWaiting:
 1545               		.stabd	46,0,0
1069:../../freeRtos/Source/queue.c **** {
 1547               	.LM184:
 1548               	.LFBB10:
 1549               	/* prologue: function */
 1550               	/* frame size = 0 */
 1551               	/* stack size = 0 */
 1552               	.L__stack_usage = 0
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1554               	.LM185:
 1555               	/* #APP */
 1556               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1557 056e 0FB6      		in		__tmp_reg__, __SREG__
 1558               	 ;  0 "" 2
 1559               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1560 0570 F894      		cli
 1561               	 ;  0 "" 2
 1562               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1563 0572 0F92      		push	__tmp_reg__
 1564               	 ;  0 "" 2
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 1566               	.LM186:
 1567               	/* #NOAPP */
 1568 0574 FC01      		movw r30,r24
 1569 0576 828D      		ldd r24,Z+26
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1571               	.LM187:
 1572               	/* #APP */
 1573               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 1574 0578 0F90      		pop		__tmp_reg__
 1575               	 ;  0 "" 2
 1576               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 1577 057a 0FBE      		out		__SREG__, __tmp_reg__
 1578               	 ;  0 "" 2
1077:../../freeRtos/Source/queue.c **** }
 1580               	.LM188:
 1581               	/* #NOAPP */
 1582 057c 0895      		ret
 1587               	.Lscope10:
 1589               		.stabd	78,0,0
 1592               	.global	uxQueueMessagesWaitingFromISR
 1594               	uxQueueMessagesWaitingFromISR:
 1595               		.stabd	46,0,0
1081:../../freeRtos/Source/queue.c **** {
 1597               	.LM189:
 1598               	.LFBB11:
 1599               	/* prologue: function */
 1600               	/* frame size = 0 */
 1601               	/* stack size = 0 */
 1602               	.L__stack_usage = 0
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 1604               	.LM190:
 1605 057e FC01      		movw r30,r24
 1606 0580 828D      		ldd r24,Z+26
1087:../../freeRtos/Source/queue.c **** }
 1608               	.LM191:
 1609 0582 0895      		ret
 1614               	.Lscope11:
 1616               		.stabd	78,0,0
 1619               	.global	vQueueDelete
 1621               	vQueueDelete:
 1622               		.stabd	46,0,0
1091:../../freeRtos/Source/queue.c **** {
 1624               	.LM192:
 1625               	.LFBB12:
 1626 0584 CF93      		push r28
 1627 0586 DF93      		push r29
 1628               	/* prologue: function */
 1629               	/* frame size = 0 */
 1630               	/* stack size = 2 */
 1631               	.L__stack_usage = 2
 1632 0588 EC01      		movw r28,r24
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1634               	.LM193:
 1635 058a 8881      		ld r24,Y
 1636 058c 9981      		ldd r25,Y+1
 1637 058e 0E94 0000 		call vPortFree
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
 1639               	.LM194:
 1640 0592 CE01      		movw r24,r28
 1641               	/* epilogue start */
1096:../../freeRtos/Source/queue.c **** }
 1643               	.LM195:
 1644 0594 DF91      		pop r29
 1645 0596 CF91      		pop r28
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
 1647               	.LM196:
 1648 0598 0C94 0000 		jmp vPortFree
 1650               	.Lscope12:
 1652               		.stabd	78,0,0
 1655               	.global	xQueueIsQueueEmptyFromISR
 1657               	xQueueIsQueueEmptyFromISR:
 1658               		.stabd	46,0,0
1228:../../freeRtos/Source/queue.c **** {
 1660               	.LM197:
 1661               	.LFBB13:
 1662               	/* prologue: function */
 1663               	/* frame size = 0 */
 1664               	/* stack size = 0 */
 1665               	.L__stack_usage = 0
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1667               	.LM198:
 1668 059c FC01      		movw r30,r24
 1669 059e 928D      		ldd r25,Z+26
 1670 05a0 81E0      		ldi r24,lo8(1)
 1671 05a2 9111      		cpse r25,__zero_reg__
 1672 05a4 80E0      		ldi r24,0
 1673               	.L110:
1234:../../freeRtos/Source/queue.c **** }
 1675               	.LM199:
 1676 05a6 0895      		ret
 1678               	.Lscope13:
 1680               		.stabd	78,0,0
 1683               	.global	xQueueIsQueueFullFromISR
 1685               	xQueueIsQueueFullFromISR:
 1686               		.stabd	46,0,0
1244:../../freeRtos/Source/queue.c **** 
1245:../../freeRtos/Source/queue.c **** 	return xReturn;
1246:../../freeRtos/Source/queue.c **** }
1247:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1248:../../freeRtos/Source/queue.c **** 
1249:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1250:../../freeRtos/Source/queue.c **** {
 1688               	.LM200:
 1689               	.LFBB14:
 1690               	/* prologue: function */
 1691               	/* frame size = 0 */
 1692               	/* stack size = 0 */
 1693               	.L__stack_usage = 0
 1694 05a8 FC01      		movw r30,r24
1251:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1252:../../freeRtos/Source/queue.c **** 
1253:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1696               	.LM201:
 1697 05aa 228D      		ldd r18,Z+26
 1698 05ac 81E0      		ldi r24,lo8(1)
 1699 05ae 938D      		ldd r25,Z+27
 1700 05b0 2913      		cpse r18,r25
 1701 05b2 80E0      		ldi r24,0
 1702               	.L115:
1254:../../freeRtos/Source/queue.c **** 
1255:../../freeRtos/Source/queue.c **** 	return xReturn;
1256:../../freeRtos/Source/queue.c **** }
 1704               	.LM202:
 1705 05b4 0895      		ret
 1707               	.Lscope14:
 1709               		.stabd	78,0,0
 1711               	.Letext0:
 1712               		.ident	"GCC: (GNU) 4.8.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/cc8mEoad.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8mEoad.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8mEoad.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8mEoad.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc8mEoad.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8mEoad.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8mEoad.s:159    .text:0000000000000000 prvCopyDataToQueue
     /tmp/cc8mEoad.s:265    .text:0000000000000080 prvCopyDataFromQueue
     /tmp/cc8mEoad.s:318    .text:00000000000000b4 prvUnlockQueue
     /tmp/cc8mEoad.s:465    .text:0000000000000130 xQueueCreate
     /tmp/cc8mEoad.s:601    .text:00000000000001c6 xQueueCreateExternal
     /tmp/cc8mEoad.s:736    .text:000000000000025a xQueueGenericSend
     /tmp/cc8mEoad.s:1039   .text:0000000000000384 xQueueGenericSendFromISR
     /tmp/cc8mEoad.s:1125   .text:00000000000003d4 xQueueGenericReceive
     /tmp/cc8mEoad.s:1458   .text:000000000000051c xQueueReceiveFromISR
     /tmp/cc8mEoad.s:1544   .text:000000000000056e uxQueueMessagesWaiting
     /tmp/cc8mEoad.s:1594   .text:000000000000057e uxQueueMessagesWaitingFromISR
     /tmp/cc8mEoad.s:1621   .text:0000000000000584 vQueueDelete
     /tmp/cc8mEoad.s:1657   .text:000000000000059c xQueueIsQueueEmptyFromISR
     /tmp/cc8mEoad.s:1685   .text:00000000000005a8 xQueueIsQueueFullFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
pvPortMalloc
vListInitialise
vPortFree
vPortYield
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
