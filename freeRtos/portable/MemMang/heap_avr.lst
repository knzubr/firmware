   1               		.file	"heap_avr.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 148               	.global	pvPortMalloc
 150               	pvPortMalloc:
 151               		.stabd	46,0,0
   1:../../freeRtos/portable/MemMang/heap_avr.c **** /*
   2:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/portable/MemMang/heap_avr.c **** 
   4:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
   5:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   6:../../freeRtos/portable/MemMang/heap_avr.c ****     * If you are:                                                             *
   7:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   8:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  13:../../freeRtos/portable/MemMang/heap_avr.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  15:../../freeRtos/portable/MemMang/heap_avr.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/portable/MemMang/heap_avr.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  18:../../freeRtos/portable/MemMang/heap_avr.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/portable/MemMang/heap_avr.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/portable/MemMang/heap_avr.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/portable/MemMang/heap_avr.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  23:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
  24:../../freeRtos/portable/MemMang/heap_avr.c **** 
  25:../../freeRtos/portable/MemMang/heap_avr.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/portable/MemMang/heap_avr.c **** 
  27:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/portable/MemMang/heap_avr.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/portable/MemMang/heap_avr.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/portable/MemMang/heap_avr.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/portable/MemMang/heap_avr.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/portable/MemMang/heap_avr.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/portable/MemMang/heap_avr.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/portable/MemMang/heap_avr.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/portable/MemMang/heap_avr.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/portable/MemMang/heap_avr.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/portable/MemMang/heap_avr.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/portable/MemMang/heap_avr.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS WEB site.
  41:../../freeRtos/portable/MemMang/heap_avr.c **** 
  42:../../freeRtos/portable/MemMang/heap_avr.c ****     1 tab == 4 spaces!
  43:../../freeRtos/portable/MemMang/heap_avr.c **** 
  44:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/portable/MemMang/heap_avr.c ****     contact details.
  46:../../freeRtos/portable/MemMang/heap_avr.c **** 
  47:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/portable/MemMang/heap_avr.c ****     critical systems.
  49:../../freeRtos/portable/MemMang/heap_avr.c **** 
  50:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/portable/MemMang/heap_avr.c ****     licensing and training services.
  52:../../freeRtos/portable/MemMang/heap_avr.c **** */
  53:../../freeRtos/portable/MemMang/heap_avr.c **** 
  54:../../freeRtos/portable/MemMang/heap_avr.c **** 
  55:../../freeRtos/portable/MemMang/heap_avr.c **** /*
  56:../../freeRtos/portable/MemMang/heap_avr.c ****  * AVR implementation of pvPortMalloc().
  57:../../freeRtos/portable/MemMang/heap_avr.c ****  * Modified by Adam Kaliszan
  58:../../freeRtos/portable/MemMang/heap_avr.c ****  */
  59:../../freeRtos/portable/MemMang/heap_avr.c **** #include <stdlib.h>
  60:../../freeRtos/portable/MemMang/heap_avr.c **** 
  61:../../freeRtos/portable/MemMang/heap_avr.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  62:../../freeRtos/portable/MemMang/heap_avr.c **** all the API functions to use the MPU wrappers.  That should only be done when
  63:../../freeRtos/portable/MemMang/heap_avr.c **** task.h is included from an application file. */
  64:../../freeRtos/portable/MemMang/heap_avr.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  65:../../freeRtos/portable/MemMang/heap_avr.c **** 
  66:../../freeRtos/portable/MemMang/heap_avr.c **** #include "FreeRTOS.h"
  67:../../freeRtos/portable/MemMang/heap_avr.c **** #include "task.h"
  68:../../freeRtos/portable/MemMang/heap_avr.c **** 
  69:../../freeRtos/portable/MemMang/heap_avr.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../../freeRtos/portable/MemMang/heap_avr.c **** 
  71:../../freeRtos/portable/MemMang/heap_avr.c **** /* Allocate the memory for the heap.  The struct is used to force byte
  72:../../freeRtos/portable/MemMang/heap_avr.c **** alignment without using any non-portable code. */
  73:../../freeRtos/portable/MemMang/heap_avr.c **** static union xRTOS_HEAP
  74:../../freeRtos/portable/MemMang/heap_avr.c **** {
  75:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT == 8
  76:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile portDOUBLE dDummy;
  77:../../freeRtos/portable/MemMang/heap_avr.c **** 	#else
  78:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile unsigned long ulDummy;
  79:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
  80:../../freeRtos/portable/MemMang/heap_avr.c **** 	unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  81:../../freeRtos/portable/MemMang/heap_avr.c **** } xHeap;
  82:../../freeRtos/portable/MemMang/heap_avr.c **** 
  83:../../freeRtos/portable/MemMang/heap_avr.c **** static size_t xNextFreeByte = ( size_t ) 0;
  84:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
  85:../../freeRtos/portable/MemMang/heap_avr.c **** 
  86:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvPortMalloc( size_t xWantedSize )
  87:../../freeRtos/portable/MemMang/heap_avr.c **** {
 153               	.LM0:
 154               	.LFBB1:
 155 0000 0F93      		push r16
 156 0002 1F93      		push r17
 157 0004 CF93      		push r28
 158 0006 DF93      		push r29
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 4 */
 162               	.L__stack_usage = 4
 163 0008 8C01      		movw r16,r24
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
  89:../../freeRtos/portable/MemMang/heap_avr.c **** 
  90:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Ensure that blocks are always aligned to the required number of bytes. */
  91:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT != 1
  92:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  93:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
  94:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Byte alignment required. */
  95:../../freeRtos/portable/MemMang/heap_avr.c **** 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  96:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
  97:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif
  98:../../freeRtos/portable/MemMang/heap_avr.c **** 
  99:../../freeRtos/portable/MemMang/heap_avr.c **** 	vTaskSuspendAll();
 165               	.LM1:
 166 000a 0E94 0000 		call vTaskSuspendAll
 100:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 101:../../freeRtos/portable/MemMang/heap_avr.c **** 		/* Check there is enough room left for the allocation. */
 102:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 168               	.LM2:
 169 000e C091 0000 		lds r28,xNextFreeByte
 170 0012 D091 0000 		lds r29,xNextFreeByte+1
 171 0016 C801      		movw r24,r16
 172 0018 8C0F      		add r24,r28
 173 001a 9D1F      		adc r25,r29
 174 001c 8C31      		cpi r24,28
 175 001e 2CE0      		ldi r18,12
 176 0020 9207      		cpc r25,r18
 177 0022 00F4      		brsh .L4
 179               	.LM3:
 180 0024 C817      		cp r28,r24
 181 0026 D907      		cpc r29,r25
 182 0028 00F4      		brsh .L4
 103:../../freeRtos/portable/MemMang/heap_avr.c **** 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 104:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 105:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Return the next free byte then increment the index past this
 106:../../freeRtos/portable/MemMang/heap_avr.c **** 			block. */
 107:../../freeRtos/portable/MemMang/heap_avr.c **** 			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 184               	.LM4:
 185 002a C050      		subi r28,lo8(-(xHeap))
 186 002c D040      		sbci r29,hi8(-(xHeap))
 108:../../freeRtos/portable/MemMang/heap_avr.c **** 			xNextFreeByte += xWantedSize;			
 188               	.LM5:
 189 002e 9093 0000 		sts xNextFreeByte+1,r25
 190 0032 8093 0000 		sts xNextFreeByte,r24
 191 0036 00C0      		rjmp .L2
 192               	.L4:
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
 194               	.LM6:
 195 0038 C0E0      		ldi r28,0
 196 003a D0E0      		ldi r29,0
 197               	.L2:
 109:../../freeRtos/portable/MemMang/heap_avr.c **** 		}	
 110:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 111:../../freeRtos/portable/MemMang/heap_avr.c **** 	xTaskResumeAll();
 199               	.LM7:
 200 003c 0E94 0000 		call xTaskResumeAll
 112:../../freeRtos/portable/MemMang/heap_avr.c **** 	
 113:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 114:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 115:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( pvReturn == NULL )
 116:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 117:../../freeRtos/portable/MemMang/heap_avr.c **** 			extern void vApplicationMallocFailedHook( void );
 118:../../freeRtos/portable/MemMang/heap_avr.c **** 			vApplicationMallocFailedHook();
 119:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
 120:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 121:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
 122:../../freeRtos/portable/MemMang/heap_avr.c **** 
 123:../../freeRtos/portable/MemMang/heap_avr.c **** 	return pvReturn;
 124:../../freeRtos/portable/MemMang/heap_avr.c **** }
 202               	.LM8:
 203 0040 CE01      		movw r24,r28
 204               	/* epilogue start */
 205 0042 DF91      		pop r29
 206 0044 CF91      		pop r28
 207 0046 1F91      		pop r17
 208 0048 0F91      		pop r16
 209 004a 0895      		ret
 214               	.Lscope1:
 216               		.stabd	78,0,0
 219               	.global	vPortFree
 221               	vPortFree:
 222               		.stabd	46,0,0
 125:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 126:../../freeRtos/portable/MemMang/heap_avr.c **** 
 127:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortFree( void *pv )
 128:../../freeRtos/portable/MemMang/heap_avr.c **** {
 224               	.LM9:
 225               	.LFBB2:
 226               	/* prologue: function */
 227               	/* frame size = 0 */
 228               	/* stack size = 0 */
 229               	.L__stack_usage = 0
 230 004c 0895      		ret
 232               	.Lscope2:
 234               		.stabd	78,0,0
 236               	.global	vPortInitialiseBlocks
 238               	vPortInitialiseBlocks:
 239               		.stabd	46,0,0
 129:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
 130:../../freeRtos/portable/MemMang/heap_avr.c **** 	for alternative implementations, and the memory management pages of 
 131:../../freeRtos/portable/MemMang/heap_avr.c **** 	http://www.FreeRTOS.org for more information. */
 132:../../freeRtos/portable/MemMang/heap_avr.c **** 	( void ) pv;
 133:../../freeRtos/portable/MemMang/heap_avr.c **** }
 134:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 135:../../freeRtos/portable/MemMang/heap_avr.c **** 
 136:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortInitialiseBlocks( void )
 137:../../freeRtos/portable/MemMang/heap_avr.c **** {
 241               	.LM10:
 242               	.LFBB3:
 243               	/* prologue: function */
 244               	/* frame size = 0 */
 245               	/* stack size = 0 */
 246               	.L__stack_usage = 0
 138:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Only required when static memory is not cleared. */
 139:../../freeRtos/portable/MemMang/heap_avr.c **** 	xNextFreeByte = ( size_t ) 0;
 248               	.LM11:
 249 004e 1092 0000 		sts xNextFreeByte+1,__zero_reg__
 250 0052 1092 0000 		sts xNextFreeByte,__zero_reg__
 251 0056 0895      		ret
 253               	.Lscope3:
 255               		.stabd	78,0,0
 257               	.global	xPortGetFreeHeapSize
 259               	xPortGetFreeHeapSize:
 260               		.stabd	46,0,0
 140:../../freeRtos/portable/MemMang/heap_avr.c **** }
 141:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 142:../../freeRtos/portable/MemMang/heap_avr.c **** 
 143:../../freeRtos/portable/MemMang/heap_avr.c **** size_t xPortGetFreeHeapSize( void )
 144:../../freeRtos/portable/MemMang/heap_avr.c **** {
 262               	.LM12:
 263               	.LFBB4:
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 0 */
 267               	.L__stack_usage = 0
 145:../../freeRtos/portable/MemMang/heap_avr.c **** 	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
 269               	.LM13:
 270 0058 2091 0000 		lds r18,xNextFreeByte
 271 005c 3091 0000 		lds r19,xNextFreeByte+1
 146:../../freeRtos/portable/MemMang/heap_avr.c **** }
 273               	.LM14:
 274 0060 8CE1      		ldi r24,lo8(28)
 275 0062 9CE0      		ldi r25,lo8(12)
 276 0064 821B      		sub r24,r18
 277 0066 930B      		sbc r25,r19
 278 0068 0895      		ret
 280               	.Lscope4:
 282               		.stabd	78,0,0
 283               		.local	xNextFreeByte
 284               		.comm	xNextFreeByte,2,1
 285               		.local	xHeap
 286               		.comm	xHeap,3100,1
 290               	.Letext0:
 291               		.ident	"GCC: (GNU) 4.8.2"
 292               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 heap_avr.c
     /tmp/ccyCz4xs.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccyCz4xs.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccyCz4xs.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccyCz4xs.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccyCz4xs.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccyCz4xs.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccyCz4xs.s:150    .text:0000000000000000 pvPortMalloc
                             .bss:0000000000000000 xNextFreeByte
     /tmp/ccyCz4xs.s:284    .bss:0000000000000002 xHeap
     /tmp/ccyCz4xs.s:221    .text:000000000000004c vPortFree
     /tmp/ccyCz4xs.s:238    .text:000000000000004e vPortInitialiseBlocks
     /tmp/ccyCz4xs.s:259    .text:0000000000000058 xPortGetFreeHeapSize

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_clear_bss
