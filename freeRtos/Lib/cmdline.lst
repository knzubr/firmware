   1               		.file	"cmdline.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 563               	cmdlinePrintPrompt:
 564               		.stabd	46,0,0
   1:../../freeRtos/Lib/cmdline.c **** /**
   2:../../freeRtos/Lib/cmdline.c ****  * @file        cmdline.h 
   3:../../freeRtos/Lib/cmdline.c ****  * @author      Pascal Stang, Adam Kaliszan
   4:../../freeRtos/Lib/cmdline.c ****  * @brief       Command-Line Interface Library
   5:../../freeRtos/Lib/cmdline.c ****  * @ingroup     protocols
   6:../../freeRtos/Lib/cmdline.c ****  * @version     0.6
   7:../../freeRtos/Lib/cmdline.c ****  * Created      2003.07.16
   8:../../freeRtos/Lib/cmdline.c ****  * Revised      2010.04.23
   9:../../freeRtos/Lib/cmdline.c ****  * Editor Tabs  2
  10:../../freeRtos/Lib/cmdline.c ****  * Target MCU   Atmel AVR Series
  11:../../freeRtos/Lib/cmdline.c ****  *
  12:../../freeRtos/Lib/cmdline.c ****  * @par Description
  13:../../freeRtos/Lib/cmdline.c ****  * This library provides cammand lineinterpreter, that works on many instances. 
  14:../../freeRtos/Lib/cmdline.c ****  * Each instance requires: separate input/output stream, and separate instance of cmdState struct
  15:../../freeRtos/Lib/cmdline.c ****  * The library was optimised under memory consumption.
  16:../../freeRtos/Lib/cmdline.c ****  *
  17:../../freeRtos/Lib/cmdline.c ****  * @note: This code is currently below version 1.0, and therefore is considered
  18:../../freeRtos/Lib/cmdline.c ****  * to be lacking in some functionality or documentation, or may not be fully
  19:../../freeRtos/Lib/cmdline.c ****  * tested.  Nonetheless, you can expect most functions to work.
  20:../../freeRtos/Lib/cmdline.c ****  *
  21:../../freeRtos/Lib/cmdline.c ****  * This code is distributed under the GNU Public License
  22:../../freeRtos/Lib/cmdline.c ****  * which can be found at http://www.gnu.org/licenses/gpl.txt
  23:../../freeRtos/Lib/cmdline.c **** */
  24:../../freeRtos/Lib/cmdline.c **** //----- Include Files ---------------------------------------------------------
  25:../../freeRtos/Lib/cmdline.c **** 
  26:../../freeRtos/Lib/cmdline.c **** #include "main.h"
  27:../../freeRtos/Lib/cmdline.c **** 
  28:../../freeRtos/Lib/cmdline.c **** #include <stdio.h>          // fprint() support
  29:../../freeRtos/Lib/cmdline.c **** #include <avr/io.h>         // include I/O definitions (port names, pin names, etc)
  30:../../freeRtos/Lib/cmdline.c **** #include <avr/interrupt.h>  // include interrupt support
  31:../../freeRtos/Lib/cmdline.c **** #include <avr/pgmspace.h>   // include AVR program memory support
  32:../../freeRtos/Lib/cmdline.c **** #include <string.h>         // include standard C string functions
  33:../../freeRtos/Lib/cmdline.c **** #include <stdlib.h>         // include stdlib for string conversion functions
  34:../../freeRtos/Lib/cmdline.c **** 
  35:../../freeRtos/Lib/cmdline.c **** #include "cmdline.h"        // Configuration
  36:../../freeRtos/Lib/cmdline.c **** #include "vt100.h"          // vty100 constans
  37:../../freeRtos/Lib/cmdline.c **** 
  38:../../freeRtos/Lib/cmdline.c **** 
  39:../../freeRtos/Lib/cmdline.c **** // Constans Strings
  40:../../freeRtos/Lib/cmdline.c **** const char CmdlinePromptNormal[]    PROGMEM  = "DomOs>";
  41:../../freeRtos/Lib/cmdline.c **** const char CmdlinePromptEnable[]    PROGMEM  = "DomOs#";
  42:../../freeRtos/Lib/cmdline.c **** const char CmdlinePromptConfigure[] PROGMEM  = "DomOs@";
  43:../../freeRtos/Lib/cmdline.c **** const char CmdlineNotice[]          PROGMEM  = "cmdline: ";
  44:../../freeRtos/Lib/cmdline.c **** const char CmdlineCmdNotFound[]     PROGMEM  = "# nk";
  45:../../freeRtos/Lib/cmdline.c **** 
  46:../../freeRtos/Lib/cmdline.c **** 
  47:../../freeRtos/Lib/cmdline.c **** // internal commands
  48:../../freeRtos/Lib/cmdline.c **** static void cmdlineRepaint            (cmdState_t *state, char *buf);
  49:../../freeRtos/Lib/cmdline.c **** static void cmdlineDoHistory          (enum cliHistoryAction action, cmdState_t *state);
  50:../../freeRtos/Lib/cmdline.c **** static void cmdlineProcessInputString (cmdState_t *state);
  51:../../freeRtos/Lib/cmdline.c **** static void cmdlinePrintPrompt        (cmdState_t *state);
  52:../../freeRtos/Lib/cmdline.c **** static void cmdlinePrintError         (cmdState_t *state);
  53:../../freeRtos/Lib/cmdline.c **** static void cmdStateClear             (cmdState_t *state);
  54:../../freeRtos/Lib/cmdline.c **** static void cmdHistoryCopy            (cmdState_t *state);
  55:../../freeRtos/Lib/cmdline.c **** static void cmdHistoryMove            (cmdState_t *state);
  56:../../freeRtos/Lib/cmdline.c **** 
  57:../../freeRtos/Lib/cmdline.c **** 
  58:../../freeRtos/Lib/cmdline.c **** void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, c
  59:../../freeRtos/Lib/cmdline.c **** {
  60:../../freeRtos/Lib/cmdline.c ****   memset(state, 0, sizeof(cmdState_t));
  61:../../freeRtos/Lib/cmdline.c ****   memset(buffPtr, 0, bufferTotalSize);
  62:../../freeRtos/Lib/cmdline.c ****     
  63:../../freeRtos/Lib/cmdline.c ****   state->CmdlineBuffer = buffPtr;
  64:../../freeRtos/Lib/cmdline.c ****   state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
  65:../../freeRtos/Lib/cmdline.c **** 
  66:../../freeRtos/Lib/cmdline.c ****   state->cliMode = mode;
  67:../../freeRtos/Lib/cmdline.c ****   state->cmdList = commands;
  68:../../freeRtos/Lib/cmdline.c ****   
  69:../../freeRtos/Lib/cmdline.c ****   uint8_t i;
  70:../../freeRtos/Lib/cmdline.c ****   char *tmpPtr = buffPtr;
  71:../../freeRtos/Lib/cmdline.c ****   for (i=0; i < CMD_STATE_HISTORY; i++)
  72:../../freeRtos/Lib/cmdline.c ****   {
  73:../../freeRtos/Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
  74:../../freeRtos/Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
  75:../../freeRtos/Lib/cmdline.c ****   }
  76:../../freeRtos/Lib/cmdline.c ****   state->myStdInOut = stream;
  77:../../freeRtos/Lib/cmdline.c **** }
  78:../../freeRtos/Lib/cmdline.c **** 
  79:../../freeRtos/Lib/cmdline.c **** void cmdStateClear(cmdState_t *state)
  80:../../freeRtos/Lib/cmdline.c **** {
  81:../../freeRtos/Lib/cmdline.c ****   // reset vt100 processing state
  82:../../freeRtos/Lib/cmdline.c ****   state->CmdlineInputVT100State = 0;
  83:../../freeRtos/Lib/cmdline.c **** 
  84:../../freeRtos/Lib/cmdline.c ****   // initialize input buffer
  85:../../freeRtos/Lib/cmdline.c ****   state->CmdlineBufferLength = 0;
  86:../../freeRtos/Lib/cmdline.c ****   state->CmdlineBufferEditPos = 0;
  87:../../freeRtos/Lib/cmdline.c **** 
  88:../../freeRtos/Lib/cmdline.c ****   // initialize executing function
  89:../../freeRtos/Lib/cmdline.c ****   state->CmdlineExecFunction = 0;
  90:../../freeRtos/Lib/cmdline.c **** }
  91:../../freeRtos/Lib/cmdline.c **** 
  92:../../freeRtos/Lib/cmdline.c **** void cmdlineInputFunc(char c, cmdState_t *state)
  93:../../freeRtos/Lib/cmdline.c **** {
  94:../../freeRtos/Lib/cmdline.c ****   uint8_t i;
  95:../../freeRtos/Lib/cmdline.c ****   // process the received character
  96:../../freeRtos/Lib/cmdline.c **** 
  97:../../freeRtos/Lib/cmdline.c ****   // VT100 handling
  98:../../freeRtos/Lib/cmdline.c ****   // are we processing a VT100 command?
  99:../../freeRtos/Lib/cmdline.c ****   if(state->CmdlineInputVT100State == 2)
 100:../../freeRtos/Lib/cmdline.c ****   {
 101:../../freeRtos/Lib/cmdline.c ****     // we have already received ESC and [
 102:../../freeRtos/Lib/cmdline.c ****     // now process the vt100 codeCmdlineExcBuffer
 103:../../freeRtos/Lib/cmdline.c ****     switch(c)
 104:../../freeRtos/Lib/cmdline.c ****     {
 105:../../freeRtos/Lib/cmdline.c ****     case VT100_ARROWUP:
 106:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
 107:../../freeRtos/Lib/cmdline.c ****       break;
 108:../../freeRtos/Lib/cmdline.c ****     case VT100_ARROWDOWN:
 109:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
 110:../../freeRtos/Lib/cmdline.c ****       break;
 111:../../freeRtos/Lib/cmdline.c ****     case VT100_ARROWRIGHT:
 112:../../freeRtos/Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 113:../../freeRtos/Lib/cmdline.c ****         cmdHistoryCopy(state);
 114:../../freeRtos/Lib/cmdline.c ****       // if the edit position less than current string length
 115:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
 116:../../freeRtos/Lib/cmdline.c ****       {
 117:../../freeRtos/Lib/cmdline.c ****         // increment the edit position
 118:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos++;
 119:../../freeRtos/Lib/cmdline.c ****         // move cursor forward one space (no erase)
 120:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_ESC        , state->myStdInOut);
 121:../../freeRtos/Lib/cmdline.c ****         fputc('['              , state->myStdInOut);
 122:../../freeRtos/Lib/cmdline.c ****         fputc(VT100_ARROWRIGHT , state->myStdInOut);
 123:../../freeRtos/Lib/cmdline.c ****       }
 124:../../freeRtos/Lib/cmdline.c ****       else
 125:../../freeRtos/Lib/cmdline.c ****       {
 126:../../freeRtos/Lib/cmdline.c ****         // else, ring the bell
 127:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 128:../../freeRtos/Lib/cmdline.c ****       }
 129:../../freeRtos/Lib/cmdline.c ****       break;
 130:../../freeRtos/Lib/cmdline.c ****     case VT100_ARROWLEFT:
 131:../../freeRtos/Lib/cmdline.c ****       // if the edit position is non-zero
 132:../../freeRtos/Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 133:../../freeRtos/Lib/cmdline.c ****         cmdHistoryCopy(state);
 134:../../freeRtos/Lib/cmdline.c ****       
 135:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos)
 136:../../freeRtos/Lib/cmdline.c ****       {
 137:../../freeRtos/Lib/cmdline.c ****         // decrement the edit position
 138:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 139:../../freeRtos/Lib/cmdline.c ****         // move cursor back one space (no erase)
 140:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 141:../../freeRtos/Lib/cmdline.c ****       }
 142:../../freeRtos/Lib/cmdline.c ****       else
 143:../../freeRtos/Lib/cmdline.c ****       {
 144:../../freeRtos/Lib/cmdline.c ****         // else, ring the bell
 145:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 146:../../freeRtos/Lib/cmdline.c ****       }
 147:../../freeRtos/Lib/cmdline.c ****       break;
 148:../../freeRtos/Lib/cmdline.c ****     default:
 149:../../freeRtos/Lib/cmdline.c ****       break;
 150:../../freeRtos/Lib/cmdline.c ****     }
 151:../../freeRtos/Lib/cmdline.c ****     // done, reset state
 152:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 153:../../freeRtos/Lib/cmdline.c ****     return;
 154:../../freeRtos/Lib/cmdline.c ****   }
 155:../../freeRtos/Lib/cmdline.c ****   else if(state->CmdlineInputVT100State == 1)
 156:../../freeRtos/Lib/cmdline.c ****   {
 157:../../freeRtos/Lib/cmdline.c ****     // we last received [ESC]
 158:../../freeRtos/Lib/cmdline.c ****     if(c == '[')
 159:../../freeRtos/Lib/cmdline.c ****     {
 160:../../freeRtos/Lib/cmdline.c ****       state->CmdlineInputVT100State = 2;
 161:../../freeRtos/Lib/cmdline.c ****       return;
 162:../../freeRtos/Lib/cmdline.c ****     }
 163:../../freeRtos/Lib/cmdline.c ****     else
 164:../../freeRtos/Lib/cmdline.c ****       state->CmdlineInputVT100State = 0;
 165:../../freeRtos/Lib/cmdline.c ****   }
 166:../../freeRtos/Lib/cmdline.c ****   else
 167:../../freeRtos/Lib/cmdline.c ****   {
 168:../../freeRtos/Lib/cmdline.c ****     // anything else, reset state
 169:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 170:../../freeRtos/Lib/cmdline.c ****   }
 171:../../freeRtos/Lib/cmdline.c **** 
 172:../../freeRtos/Lib/cmdline.c ****   // Regular handling
 173:../../freeRtos/Lib/cmdline.c ****   //Protection against buffer Overflow
 174:../../freeRtos/Lib/cmdline.c ****   if (state->CmdlineBufferLength == state->bufferMaxSize)
 175:../../freeRtos/Lib/cmdline.c ****   {
 176:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength--;
 177:../../freeRtos/Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 178:../../freeRtos/Lib/cmdline.c ****     {
 179:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
 180:../../freeRtos/Lib/cmdline.c ****     }
 181:../../freeRtos/Lib/cmdline.c ****   }
 182:../../freeRtos/Lib/cmdline.c ****   
 183:../../freeRtos/Lib/cmdline.c ****   if( (c >= 0x20) && (c < 0x7F) )
 184:../../freeRtos/Lib/cmdline.c ****   {
 185:../../freeRtos/Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 186:../../freeRtos/Lib/cmdline.c ****       cmdHistoryCopy(state);
 187:../../freeRtos/Lib/cmdline.c ****     // character is printable
 188:../../freeRtos/Lib/cmdline.c ****     // is this a simple append
 189:../../freeRtos/Lib/cmdline.c ****     if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 190:../../freeRtos/Lib/cmdline.c ****     {
 191:../../freeRtos/Lib/cmdline.c ****       // echo character to the output
 192:../../freeRtos/Lib/cmdline.c ****       fputc(c                , state->myStdInOut);
 193:../../freeRtos/Lib/cmdline.c ****       // add it to the command line buffer
 194:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 195:../../freeRtos/Lib/cmdline.c ****       // update buffer length
 196:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBufferLength++;
 197:../../freeRtos/Lib/cmdline.c ****     }
 198:../../freeRtos/Lib/cmdline.c ****     else
 199:../../freeRtos/Lib/cmdline.c ****     {
 200:../../freeRtos/Lib/cmdline.c ****       // edit/cursor position != end of buffer
 201:../../freeRtos/Lib/cmdline.c ****       // we're inserting characters at a mid-line edit position
 202:../../freeRtos/Lib/cmdline.c ****       // make room at the insert point
 203:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBufferLength++;
 204:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 205:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
 206:../../freeRtos/Lib/cmdline.c ****       // insert character
 207:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 208:../../freeRtos/Lib/cmdline.c ****       // repaint
 209:../../freeRtos/Lib/cmdline.c ****       cmdlineRepaint(state, state->CmdlineBuffer);
 210:../../freeRtos/Lib/cmdline.c ****       // reposition cursor
 211:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 212:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 213:../../freeRtos/Lib/cmdline.c ****     }
 214:../../freeRtos/Lib/cmdline.c ****   }
 215:../../freeRtos/Lib/cmdline.c ****   // handle special characters
 216:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_CR)
 217:../../freeRtos/Lib/cmdline.c ****   {
 218:../../freeRtos/Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 219:../../freeRtos/Lib/cmdline.c ****       cmdHistoryMove(state);
 220:../../freeRtos/Lib/cmdline.c ****     
 221:../../freeRtos/Lib/cmdline.c ****     // user pressed [ENTER]
 222:../../freeRtos/Lib/cmdline.c ****     // echo CR and LF to terminal
 223:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_CR         , state->myStdInOut);
 224:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_LF         , state->myStdInOut);
 225:../../freeRtos/Lib/cmdline.c ****     // add null termination to command
 226:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
 227:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos++;
 228:../../freeRtos/Lib/cmdline.c ****     // command is complete, process it
 229:../../freeRtos/Lib/cmdline.c ****     cmdlineProcessInputString(state);
 230:../../freeRtos/Lib/cmdline.c ****     // reset buffer
 231:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = 0;
 232:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;
 233:../../freeRtos/Lib/cmdline.c ****   }
 234:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_BS)
 235:../../freeRtos/Lib/cmdline.c ****   {
 236:../../freeRtos/Lib/cmdline.c ****     if(state->CmdlineBufferEditPos)
 237:../../freeRtos/Lib/cmdline.c ****     {
 238:../../freeRtos/Lib/cmdline.c ****       // is this a simple delete (off the end of the line)
 239:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 240:../../freeRtos/Lib/cmdline.c ****       {
 241:../../freeRtos/Lib/cmdline.c ****         // destructive backspace
 242:../../freeRtos/Lib/cmdline.c ****         // echo backspace-space-backspace
 243:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 244:../../freeRtos/Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 245:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 246:../../freeRtos/Lib/cmdline.c ****         // decrement our buffer length and edit position
 247:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferLength--;
 248:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 249:../../freeRtos/Lib/cmdline.c ****       }
 250:../../freeRtos/Lib/cmdline.c ****       else
 251:../../freeRtos/Lib/cmdline.c ****       {
 252:../../freeRtos/Lib/cmdline.c ****         // edit/cursor position != end of buffer
 253:../../freeRtos/Lib/cmdline.c ****         // we're deleting characters at a mid-line edit position
 254:../../freeRtos/Lib/cmdline.c ****         // shift characters down, effectively deleting
 255:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferLength--;
 256:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 257:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 258:../../freeRtos/Lib/cmdline.c ****           state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
 259:../../freeRtos/Lib/cmdline.c ****         // repaint
 260:../../freeRtos/Lib/cmdline.c ****         cmdlineRepaint(state, state->CmdlineBuffer);
 261:../../freeRtos/Lib/cmdline.c ****         // add space to clear leftover characters
 262:../../freeRtos/Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 263:../../freeRtos/Lib/cmdline.c ****         // reposition cursor
 264:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 265:../../freeRtos/Lib/cmdline.c ****           fputc(ASCII_BS       , state->myStdInOut);
 266:../../freeRtos/Lib/cmdline.c ****       }
 267:../../freeRtos/Lib/cmdline.c ****     }
 268:../../freeRtos/Lib/cmdline.c ****     else
 269:../../freeRtos/Lib/cmdline.c ****     {
 270:../../freeRtos/Lib/cmdline.c ****       // else, ring the bell
 271:../../freeRtos/Lib/cmdline.c ****       fputc(ASCII_BEL          , state->myStdInOut);
 272:../../freeRtos/Lib/cmdline.c ****     }
 273:../../freeRtos/Lib/cmdline.c ****   }
 274:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_DEL)
 275:../../freeRtos/Lib/cmdline.c ****   {
 276:../../freeRtos/Lib/cmdline.c ****     // not yet handled
 277:../../freeRtos/Lib/cmdline.c ****   }
 278:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_ESC)
 279:../../freeRtos/Lib/cmdline.c ****   {
 280:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 1;
 281:../../freeRtos/Lib/cmdline.c ****   }
 282:../../freeRtos/Lib/cmdline.c **** }
 283:../../freeRtos/Lib/cmdline.c **** 
 284:../../freeRtos/Lib/cmdline.c **** void cmdlineRepaint(cmdState_t *state, char *buf)
 285:../../freeRtos/Lib/cmdline.c **** {
 286:../../freeRtos/Lib/cmdline.c ****   uint8_t i;
 287:../../freeRtos/Lib/cmdline.c **** 
 288:../../freeRtos/Lib/cmdline.c ****   // carriage return
 289:../../freeRtos/Lib/cmdline.c ****   fputc(ASCII_CR         , state->myStdInOut);
 290:../../freeRtos/Lib/cmdline.c ****   // print fresh prompt
 291:../../freeRtos/Lib/cmdline.c ****   cmdlinePrintPrompt(state);
 292:../../freeRtos/Lib/cmdline.c ****   // print the new command line buffer
 293:../../freeRtos/Lib/cmdline.c ****   i = state->CmdlineBufferLength;
 294:../../freeRtos/Lib/cmdline.c ****   while(i--) 
 295:../../freeRtos/Lib/cmdline.c ****     fputc(*buf++         , state->myStdInOut);
 296:../../freeRtos/Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 297:../../freeRtos/Lib/cmdline.c ****   while (i--)
 298:../../freeRtos/Lib/cmdline.c ****     fputc(' ', state->myStdInOut);
 299:../../freeRtos/Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 300:../../freeRtos/Lib/cmdline.c ****   while (i--)
 301:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_BS,  state->myStdInOut);
 302:../../freeRtos/Lib/cmdline.c **** }
 303:../../freeRtos/Lib/cmdline.c **** 
 304:../../freeRtos/Lib/cmdline.c **** void cmdHistoryCopy(cmdState_t *state)
 305:../../freeRtos/Lib/cmdline.c **** {
 306:../../freeRtos/Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 307:../../freeRtos/Lib/cmdline.c ****   {
 308:../../freeRtos/Lib/cmdline.c ****     uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MAS
 309:../../freeRtos/Lib/cmdline.c ****     memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
 310:../../freeRtos/Lib/cmdline.c ****     strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
 311:../../freeRtos/Lib/cmdline.c ****   }
 312:../../freeRtos/Lib/cmdline.c ****   
 313:../../freeRtos/Lib/cmdline.c ****   state->historyDepthIdx = 0;
 314:../../freeRtos/Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 315:../../freeRtos/Lib/cmdline.c **** }
 316:../../freeRtos/Lib/cmdline.c **** 
 317:../../freeRtos/Lib/cmdline.c **** void cmdHistoryMove(cmdState_t *state)
 318:../../freeRtos/Lib/cmdline.c **** {
 319:../../freeRtos/Lib/cmdline.c ****   uint8_t i=state->historyDepthIdx;
 320:../../freeRtos/Lib/cmdline.c **** 
 321:../../freeRtos/Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 322:../../freeRtos/Lib/cmdline.c ****   {
 323:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
 324:../../freeRtos/Lib/cmdline.c ****     for ( ; i<CMD_STATE_HISTORY; i++)
 325:../../freeRtos/Lib/cmdline.c ****     {
 326:../../freeRtos/Lib/cmdline.c ****       state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHisto
 327:../../freeRtos/Lib/cmdline.c ****     }
 328:../../freeRtos/Lib/cmdline.c ****   }
 329:../../freeRtos/Lib/cmdline.c ****   state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
 330:../../freeRtos/Lib/cmdline.c **** 
 331:../../freeRtos/Lib/cmdline.c ****   state->historyDepthIdx = 0;
 332:../../freeRtos/Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 333:../../freeRtos/Lib/cmdline.c **** }
 334:../../freeRtos/Lib/cmdline.c **** 
 335:../../freeRtos/Lib/cmdline.c **** void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
 336:../../freeRtos/Lib/cmdline.c **** {
 337:../../freeRtos/Lib/cmdline.c ****   uint8_t historyReadIdx;
 338:../../freeRtos/Lib/cmdline.c ****   switch(action)
 339:../../freeRtos/Lib/cmdline.c ****   {
 340:../../freeRtos/Lib/cmdline.c ****   case CMDLINE_HISTORY_SAVE:
 341:../../freeRtos/Lib/cmdline.c ****     // copy CmdlineBuffer to history if not null string
 342:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength  = 0;
 343:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;     
 344:../../freeRtos/Lib/cmdline.c ****     state->bufferHistoryState   = NOT_COPIED;
 345:../../freeRtos/Lib/cmdline.c **** 
 346:../../freeRtos/Lib/cmdline.c ****     if( strlen(state->CmdlineBuffer) )
 347:../../freeRtos/Lib/cmdline.c ****     {
 348:../../freeRtos/Lib/cmdline.c ****       state->historyWrIdx++;
 349:../../freeRtos/Lib/cmdline.c ****       state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
 350:../../freeRtos/Lib/cmdline.c ****       
 351:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
 352:../../freeRtos/Lib/cmdline.c ****     }
 353:../../freeRtos/Lib/cmdline.c ****     break;
 354:../../freeRtos/Lib/cmdline.c ****   case CMDLINE_HISTORY_PREV:
 355:../../freeRtos/Lib/cmdline.c ****     if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
 356:../../freeRtos/Lib/cmdline.c ****       break;                                               //We are on the end of the history list
 357:../../freeRtos/Lib/cmdline.c ****     
 358:../../freeRtos/Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
 359:../../freeRtos/Lib/cmdline.c ****     
 360:../../freeRtos/Lib/cmdline.c ****     if (state->CmdlineHistory[historyReadIdx][0] == 0)
 361:../../freeRtos/Lib/cmdline.c ****       break;
 362:../../freeRtos/Lib/cmdline.c ****     
 363:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx++;
 364:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
 365:../../freeRtos/Lib/cmdline.c ****     
 366:../../freeRtos/Lib/cmdline.c ****     // set the buffer position to the end of the line
 367:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 368:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 369:../../freeRtos/Lib/cmdline.c ****     
 370:../../freeRtos/Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 371:../../freeRtos/Lib/cmdline.c **** 
 372:../../freeRtos/Lib/cmdline.c ****     // "re-paint" line
 373:../../freeRtos/Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 374:../../freeRtos/Lib/cmdline.c ****     
 375:../../freeRtos/Lib/cmdline.c ****     break;
 376:../../freeRtos/Lib/cmdline.c ****   case CMDLINE_HISTORY_NEXT:      
 377:../../freeRtos/Lib/cmdline.c ****     if (state->historyDepthIdx == 0)
 378:../../freeRtos/Lib/cmdline.c ****       break;                                               //We are on the begining of the history 
 379:../../freeRtos/Lib/cmdline.c **** 
 380:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx --;
 381:../../freeRtos/Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
 382:../../freeRtos/Lib/cmdline.c ****    
 383:../../freeRtos/Lib/cmdline.c ****     // set the buffer position to the end of the line
 384:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 385:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 386:../../freeRtos/Lib/cmdline.c ****     
 387:../../freeRtos/Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 388:../../freeRtos/Lib/cmdline.c **** 
 389:../../freeRtos/Lib/cmdline.c ****     // "re-paint" line
 390:../../freeRtos/Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 391:../../freeRtos/Lib/cmdline.c ****     break;
 392:../../freeRtos/Lib/cmdline.c ****   }
 393:../../freeRtos/Lib/cmdline.c **** }
 394:../../freeRtos/Lib/cmdline.c **** 
 395:../../freeRtos/Lib/cmdline.c **** void cmdlineProcessInputString(cmdState_t *state)
 396:../../freeRtos/Lib/cmdline.c **** {
 397:../../freeRtos/Lib/cmdline.c ****   uint8_t i=0;
 398:../../freeRtos/Lib/cmdline.c ****   state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer la
 399:../../freeRtos/Lib/cmdline.c **** 
 400:../../freeRtos/Lib/cmdline.c ****   while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the comman
 401:../../freeRtos/Lib/cmdline.c ****     || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace char
 402:../../freeRtos/Lib/cmdline.c ****     i++;                                                              // i determines the cammand l
 403:../../freeRtos/Lib/cmdline.c **** 
 404:../../freeRtos/Lib/cmdline.c ****   if(!i)                                                              // command was null or empty
 405:../../freeRtos/Lib/cmdline.c ****   {
 406:../../freeRtos/Lib/cmdline.c ****     cmdlinePrintPrompt(state);                                        // output a new prompt
 407:../../freeRtos/Lib/cmdline.c ****     return;
 408:../../freeRtos/Lib/cmdline.c ****   }
 409:../../freeRtos/Lib/cmdline.c **** 
 410:../../freeRtos/Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The 
 411:../../freeRtos/Lib/cmdline.c ****   command_t  tmp;                                                     // We need to create this obj
 412:../../freeRtos/Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need t
 413:../../freeRtos/Lib/cmdline.c **** 
 414:../../freeRtos/Lib/cmdline.c ****   do                                                                  // search command list for ma
 415:../../freeRtos/Lib/cmdline.c ****   {
 416:../../freeRtos/Lib/cmdline.c ****     if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command match
 417:../../freeRtos/Lib/cmdline.c ****     {                                                                 // 
 418:../../freeRtos/Lib/cmdline.c ****       state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
 419:../../freeRtos/Lib/cmdline.c ****       state->command_str         = tmp.commandStr;
 420:../../freeRtos/Lib/cmdline.c ****       state->command_help_str    = tmp.commandHelpStr;
 421:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
 422:../../freeRtos/Lib/cmdline.c ****       return;
 423:../../freeRtos/Lib/cmdline.c ****     }
 424:../../freeRtos/Lib/cmdline.c ****     tmpPtr++;                                                         // Next command
 425:../../freeRtos/Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from fla
 426:../../freeRtos/Lib/cmdline.c ****   }
 427:../../freeRtos/Lib/cmdline.c ****   while (tmp.commandStr != NULL);                                     // Last command on the list i
 428:../../freeRtos/Lib/cmdline.c ****   
 429:../../freeRtos/Lib/cmdline.c ****   // if we did not get a match
 430:../../freeRtos/Lib/cmdline.c ****   cmdlinePrintError(state);                                           // output an error message
 431:../../freeRtos/Lib/cmdline.c ****   cmdlinePrintPrompt(state);                                          // output a new prompt
 432:../../freeRtos/Lib/cmdline.c **** }
 433:../../freeRtos/Lib/cmdline.c **** 
 434:../../freeRtos/Lib/cmdline.c **** void cmdlineMainLoop(cmdState_t *state)
 435:../../freeRtos/Lib/cmdline.c **** {
 436:../../freeRtos/Lib/cmdline.c ****   cliExRes_t result;
 437:../../freeRtos/Lib/cmdline.c ****   if(state->CmdlineExecFunction)                // do we have a command/function to be executed
 438:../../freeRtos/Lib/cmdline.c ****   {
 439:../../freeRtos/Lib/cmdline.c ****     state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
 440:../../freeRtos/Lib/cmdline.c ****     result = state->CmdlineExecFunction(state); // run it
 441:../../freeRtos/Lib/cmdline.c ****     
 442:../../freeRtos/Lib/cmdline.c ****     switch(result)
 443:../../freeRtos/Lib/cmdline.c ****     {
 444:../../freeRtos/Lib/cmdline.c ****       case OK_INFORM:
 445:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
 446:../../freeRtos/Lib/cmdline.c ****         break;
 447:../../freeRtos/Lib/cmdline.c ****       case SYNTAX_ERROR:
 448:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
 449:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_str);
 450:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR(" "));
 451:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_help_str);
 452:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("\r\n"));
 453:../../freeRtos/Lib/cmdline.c ****         break;
 454:../../freeRtos/Lib/cmdline.c ****       case ERROR_INFORM:
 455:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
 456:../../freeRtos/Lib/cmdline.c ****         break;
 457:../../freeRtos/Lib/cmdline.c ****       case ERROR_OPERATION_NOT_ALLOWED:
 458:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
 459:../../freeRtos/Lib/cmdline.c ****         break;
 460:../../freeRtos/Lib/cmdline.c ****       default:
 461:../../freeRtos/Lib/cmdline.c ****         break;
 462:../../freeRtos/Lib/cmdline.c ****     }
 463:../../freeRtos/Lib/cmdline.c ****     state->CmdlineExecFunction = NULL;          // reset
 464:../../freeRtos/Lib/cmdline.c ****     state->command_str         = NULL;
 465:../../freeRtos/Lib/cmdline.c ****     state->command_help_str    = NULL;
 466:../../freeRtos/Lib/cmdline.c ****     cmdlinePrintPrompt(state);                  // output new prompt
 467:../../freeRtos/Lib/cmdline.c ****   }
 468:../../freeRtos/Lib/cmdline.c **** }
 469:../../freeRtos/Lib/cmdline.c **** 
 470:../../freeRtos/Lib/cmdline.c **** void cmdlinePrintPrompt(cmdState_t *state)
 471:../../freeRtos/Lib/cmdline.c **** {
 566               	.LM0:
 567               	.LFBB1:
 568 0000 0F93      		push r16
 569 0002 1F93      		push r17
 570 0004 CF93      		push r28
 571 0006 DF93      		push r29
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 4 */
 575               	.L__stack_usage = 4
 576 0008 8C01      		movw r16,r24
 472:../../freeRtos/Lib/cmdline.c ****   const char* ptr;
 473:../../freeRtos/Lib/cmdline.c ****   // print a new command prompt
 474:../../freeRtos/Lib/cmdline.c ****   switch (state->cliMode)
 578               	.LM1:
 579 000a DC01      		movw r26,r24
 580 000c 9096      		adiw r26,32
 581 000e EC91      		ld r30,X
 582 0010 9097      		sbiw r26,32
 583 0012 E330      		cpi r30,lo8(3)
 584 0014 00F4      		brsh .L5
 585 0016 F0E0      		ldi r31,lo8(0)
 586 0018 EE0F      		lsl r30
 587 001a FF1F      		rol r31
 588 001c E050      		subi r30,lo8(-(CSWTCH.2))
 589 001e F040      		sbci r31,hi8(-(CSWTCH.2))
 590 0020 C081      		ld r28,Z
 591 0022 D181      		ldd r29,Z+1
 592 0024 00C0      		rjmp .L6
 593               	.L5:
 594 0026 C0E0      		ldi r28,lo8(CmdlinePromptNormal)
 595 0028 D0E0      		ldi r29,hi8(CmdlinePromptNormal)
 596 002a 00C0      		rjmp .L6
 597               	.L4:
 598               	.LBB4:
 475:../../freeRtos/Lib/cmdline.c ****   {
 476:../../freeRtos/Lib/cmdline.c ****     case NR_NORMAL:
 477:../../freeRtos/Lib/cmdline.c ****       ptr = CmdlinePromptNormal;
 478:../../freeRtos/Lib/cmdline.c ****       break;
 479:../../freeRtos/Lib/cmdline.c ****     case NR_ENABLE:
 480:../../freeRtos/Lib/cmdline.c ****       ptr = CmdlinePromptEnable;
 481:../../freeRtos/Lib/cmdline.c ****       break;
 482:../../freeRtos/Lib/cmdline.c ****     case NR_CONFIGURE:
 483:../../freeRtos/Lib/cmdline.c ****       ptr = CmdlinePromptConfigure;
 484:../../freeRtos/Lib/cmdline.c ****       break;
 485:../../freeRtos/Lib/cmdline.c ****     default:
 486:../../freeRtos/Lib/cmdline.c ****       ptr = CmdlinePromptNormal;
 487:../../freeRtos/Lib/cmdline.c ****       break;      
 488:../../freeRtos/Lib/cmdline.c ****   }
 489:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 490:../../freeRtos/Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 600               	.LM2:
 601 002c 2196      		adiw r28,1
 602 002e FC01      		movw r30,r24
 603               	/* #APP */
 604               	 ;  490 "../../freeRtos/Lib/cmdline.c" 1
 605 0030 8491      		lpm r24, Z
 606               		
 607               	 ;  0 "" 2
 608               	/* #NOAPP */
 609               	.LBE4:
 610 0032 D801      		movw r26,r16
 611 0034 5A96      		adiw r26,26
 612 0036 6D91      		ld r22,X+
 613 0038 7C91      		ld r23,X
 614 003a 5B97      		sbiw r26,26+1
 615 003c 90E0      		ldi r25,lo8(0)
 616 003e 0E94 0000 		call fputc
 617               	.L6:
 619               	.LM3:
 620 0042 CE01      		movw r24,r28
 621               	.LBB5:
 489:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 623               	.LM4:
 624 0044 FE01      		movw r30,r28
 625               	/* #APP */
 626               	 ;  489 "../../freeRtos/Lib/cmdline.c" 1
 627 0046 2491      		lpm r18, Z
 628               		
 629               	 ;  0 "" 2
 630               	/* #NOAPP */
 631               	.LBE5:
 632 0048 2223      		tst r18
 633 004a 01F4      		brne .L4
 634               	/* epilogue start */
 491:../../freeRtos/Lib/cmdline.c **** }
 636               	.LM5:
 637 004c DF91      		pop r29
 638 004e CF91      		pop r28
 639 0050 1F91      		pop r17
 640 0052 0F91      		pop r16
 641 0054 0895      		ret
 649               	.Lscope1:
 651               		.stabd	78,0,0
 656               	cmdlineRepaint:
 657               		.stabd	46,0,0
 285:../../freeRtos/Lib/cmdline.c **** {
 659               	.LM6:
 660               	.LFBB2:
 661 0056 FF92      		push r15
 662 0058 0F93      		push r16
 663 005a 1F93      		push r17
 664 005c CF93      		push r28
 665 005e DF93      		push r29
 666               	/* prologue: function */
 667               	/* frame size = 0 */
 668               	/* stack size = 5 */
 669               	.L__stack_usage = 5
 670 0060 EC01      		movw r28,r24
 671 0062 8B01      		movw r16,r22
 289:../../freeRtos/Lib/cmdline.c ****   fputc(ASCII_CR         , state->myStdInOut);
 673               	.LM7:
 674 0064 6A8D      		ldd r22,Y+26
 675 0066 7B8D      		ldd r23,Y+27
 676 0068 8DE0      		ldi r24,lo8(13)
 677 006a 90E0      		ldi r25,hi8(13)
 678 006c 0E94 0000 		call fputc
 291:../../freeRtos/Lib/cmdline.c ****   cmdlinePrintPrompt(state);
 680               	.LM8:
 681 0070 CE01      		movw r24,r28
 682 0072 0E94 0000 		call cmdlinePrintPrompt
 293:../../freeRtos/Lib/cmdline.c ****   i = state->CmdlineBufferLength;
 684               	.LM9:
 685 0076 FD84      		ldd r15,Y+13
 294:../../freeRtos/Lib/cmdline.c ****   while(i--) 
 687               	.LM10:
 688 0078 00C0      		rjmp .L8
 689               	.L9:
 295:../../freeRtos/Lib/cmdline.c ****     fputc(*buf++         , state->myStdInOut);
 691               	.LM11:
 692 007a F801      		movw r30,r16
 693 007c 8191      		ld r24,Z+
 694 007e 8F01      		movw r16,r30
 695 0080 6A8D      		ldd r22,Y+26
 696 0082 7B8D      		ldd r23,Y+27
 697 0084 9927      		clr r25
 698 0086 87FD      		sbrc r24,7
 699 0088 9095      		com r25
 700 008a 0E94 0000 		call fputc
 701 008e FA94      		dec r15
 702               	.L8:
 294:../../freeRtos/Lib/cmdline.c ****   while(i--) 
 704               	.LM12:
 705 0090 FF20      		tst r15
 706 0092 01F4      		brne .L9
 296:../../freeRtos/Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 708               	.LM13:
 709 0094 0C85      		ldd r16,Y+12
 710 0096 8D85      		ldd r24,Y+13
 711 0098 081B      		sub r16,r24
 297:../../freeRtos/Lib/cmdline.c ****   while (i--)
 713               	.LM14:
 714 009a 00C0      		rjmp .L10
 715               	.L11:
 298:../../freeRtos/Lib/cmdline.c ****     fputc(' ', state->myStdInOut);
 717               	.LM15:
 718 009c 6A8D      		ldd r22,Y+26
 719 009e 7B8D      		ldd r23,Y+27
 720 00a0 80E2      		ldi r24,lo8(32)
 721 00a2 90E0      		ldi r25,hi8(32)
 722 00a4 0E94 0000 		call fputc
 723 00a8 0150      		subi r16,lo8(-(-1))
 724               	.L10:
 297:../../freeRtos/Lib/cmdline.c ****   while (i--)
 726               	.LM16:
 727 00aa 0023      		tst r16
 728 00ac 01F4      		brne .L11
 299:../../freeRtos/Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 730               	.LM17:
 731 00ae 0C85      		ldd r16,Y+12
 732 00b0 8D85      		ldd r24,Y+13
 733 00b2 081B      		sub r16,r24
 300:../../freeRtos/Lib/cmdline.c ****   while (i--)
 735               	.LM18:
 736 00b4 00C0      		rjmp .L12
 737               	.L13:
 301:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_BS,  state->myStdInOut);
 739               	.LM19:
 740 00b6 6A8D      		ldd r22,Y+26
 741 00b8 7B8D      		ldd r23,Y+27
 742 00ba 88E0      		ldi r24,lo8(8)
 743 00bc 90E0      		ldi r25,hi8(8)
 744 00be 0E94 0000 		call fputc
 745 00c2 0150      		subi r16,lo8(-(-1))
 746               	.L12:
 300:../../freeRtos/Lib/cmdline.c ****   while (i--)
 748               	.LM20:
 749 00c4 0023      		tst r16
 750 00c6 01F4      		brne .L13
 751               	/* epilogue start */
 302:../../freeRtos/Lib/cmdline.c **** }
 753               	.LM21:
 754 00c8 DF91      		pop r29
 755 00ca CF91      		pop r28
 756 00cc 1F91      		pop r17
 757 00ce 0F91      		pop r16
 758 00d0 FF90      		pop r15
 759 00d2 0895      		ret
 761               	.Lscope2:
 763               		.stabd	78,0,0
 768               	cmdlineDoHistory:
 769               		.stabd	46,0,0
 336:../../freeRtos/Lib/cmdline.c **** {
 771               	.LM22:
 772               	.LFBB3:
 773 00d4 EF92      		push r14
 774 00d6 FF92      		push r15
 775 00d8 CF93      		push r28
 776 00da DF93      		push r29
 777               	/* prologue: function */
 778               	/* frame size = 0 */
 779               	/* stack size = 4 */
 780               	.L__stack_usage = 4
 781 00dc FB01      		movw r30,r22
 338:../../freeRtos/Lib/cmdline.c ****   switch(action)
 783               	.LM23:
 784 00de 8130      		cpi r24,lo8(1)
 785 00e0 01F0      		breq .L17
 786 00e2 8130      		cpi r24,lo8(1)
 787 00e4 00F0      		brlo .L16
 788 00e6 8230      		cpi r24,lo8(2)
 789 00e8 01F0      		breq .+2
 790 00ea 00C0      		rjmp .L14
 791 00ec 00C0      		rjmp .L20
 792               	.L16:
 342:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength  = 0;
 794               	.LM24:
 795 00ee 1586      		std Z+13,__zero_reg__
 343:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;     
 797               	.LM25:
 798 00f0 1686      		std Z+14,__zero_reg__
 344:../../freeRtos/Lib/cmdline.c ****     state->bufferHistoryState   = NOT_COPIED;
 800               	.LM26:
 801 00f2 118A      		std Z+17,__zero_reg__
 346:../../freeRtos/Lib/cmdline.c ****     if( strlen(state->CmdlineBuffer) )
 803               	.LM27:
 804 00f4 A081      		ld r26,Z
 805 00f6 B181      		ldd r27,Z+1
 806 00f8 8C91      		ld r24,X
 807 00fa 8823      		tst r24
 808 00fc 01F4      		brne .+2
 809 00fe 00C0      		rjmp .L14
 348:../../freeRtos/Lib/cmdline.c ****       state->historyWrIdx++;
 811               	.LM28:
 812 0100 A785      		ldd r26,Z+15
 813 0102 AF5F      		subi r26,lo8(-(1))
 349:../../freeRtos/Lib/cmdline.c ****       state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
 815               	.LM29:
 816 0104 A370      		andi r26,lo8(3)
 817 0106 A787      		std Z+15,r26
 351:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
 819               	.LM30:
 820 0108 B0E0      		ldi r27,lo8(0)
 821 010a 1296      		adiw r26,2
 822 010c AA0F      		lsl r26
 823 010e BB1F      		rol r27
 824 0110 A60F      		add r26,r22
 825 0112 B71F      		adc r27,r23
 826 0114 8D91      		ld r24,X+
 827 0116 9C91      		ld r25,X
 828 0118 1197      		sbiw r26,1
 829 011a 8083      		st Z,r24
 830 011c 9183      		std Z+1,r25
 831 011e 00C0      		rjmp .L14
 832               	.L17:
 355:../../freeRtos/Lib/cmdline.c ****     if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
 834               	.LM31:
 835 0120 8089      		ldd r24,Z+16
 836 0122 8330      		cpi r24,lo8(3)
 837 0124 01F0      		breq .L14
 358:../../freeRtos/Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
 839               	.LM32:
 840 0126 A785      		ldd r26,Z+15
 841 0128 A150      		subi r26,lo8(-(-1))
 842 012a A81B      		sub r26,r24
 843 012c A370      		andi r26,lo8(3)
 360:../../freeRtos/Lib/cmdline.c ****     if (state->CmdlineHistory[historyReadIdx][0] == 0)
 845               	.LM33:
 846 012e B0E0      		ldi r27,lo8(0)
 847 0130 1296      		adiw r26,2
 848 0132 AA0F      		lsl r26
 849 0134 BB1F      		rol r27
 850 0136 A60F      		add r26,r22
 851 0138 B71F      		adc r27,r23
 852 013a 6D91      		ld r22,X+
 853 013c 7C91      		ld r23,X
 854 013e DB01      		movw r26,r22
 855 0140 9C91      		ld r25,X
 856 0142 9923      		tst r25
 857 0144 01F0      		breq .L14
 363:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx++;
 859               	.LM34:
 860 0146 8F5F      		subi r24,lo8(-(1))
 364:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
 862               	.LM35:
 863 0148 8370      		andi r24,lo8(3)
 864 014a 808B      		std Z+16,r24
 367:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 866               	.LM36:
 867 014c E62E      		mov r14,r22
 868 014e E701      		movw r28,r14
 869 0150 00C0      		rjmp .L19
 870               	.L20:
 377:../../freeRtos/Lib/cmdline.c ****     if (state->historyDepthIdx == 0)
 872               	.LM37:
 873 0152 8089      		ldd r24,Z+16
 874 0154 8823      		tst r24
 875 0156 01F0      		breq .L14
 380:../../freeRtos/Lib/cmdline.c ****     state->historyDepthIdx --;
 877               	.LM38:
 878 0158 8150      		subi r24,lo8(-(-1))
 879 015a 808B      		std Z+16,r24
 381:../../freeRtos/Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
 881               	.LM39:
 882 015c A785      		ldd r26,Z+15
 883 015e A81B      		sub r26,r24
 884 0160 A370      		andi r26,lo8(3)
 384:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 886               	.LM40:
 887 0162 B0E0      		ldi r27,lo8(0)
 888 0164 1296      		adiw r26,2
 889 0166 AA0F      		lsl r26
 890 0168 BB1F      		rol r27
 891 016a A60F      		add r26,r22
 892 016c B71F      		adc r27,r23
 893 016e 6C91      		ld r22,X
 894 0170 1196      		adiw r26,1
 895 0172 7C91      		ld r23,X
 896 0174 A62F      		mov r26,r22
 897 0176 ED01      		movw r28,r26
 898               	.L19:
 899 0178 7E01      		movw r14,r28
 900 017a F72E      		mov r15,r23
 901 017c D701      		movw r26,r14
 902 017e 0D90      		ld __tmp_reg__,X+
 903 0180 0020      		tst __tmp_reg__
 904 0182 01F4      		brne .-6
 905 0184 1197      		sbiw r26,1
 906 0186 AE19      		sub r26,r14
 907 0188 BF09      		sbc r27,r15
 908 018a A587      		std Z+13,r26
 385:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 910               	.LM41:
 911 018c A687      		std Z+14,r26
 387:../../freeRtos/Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 913               	.LM42:
 914 018e 118A      		std Z+17,__zero_reg__
 390:../../freeRtos/Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 916               	.LM43:
 917 0190 CF01      		movw r24,r30
 918 0192 0E94 0000 		call cmdlineRepaint
 919               	.L14:
 920               	/* epilogue start */
 393:../../freeRtos/Lib/cmdline.c **** }
 922               	.LM44:
 923 0196 DF91      		pop r29
 924 0198 CF91      		pop r28
 925 019a FF90      		pop r15
 926 019c EF90      		pop r14
 927 019e 0895      		ret
 929               	.Lscope3:
 931               		.stabd	78,0,0
 935               	cmdHistoryCopy:
 936               		.stabd	46,0,0
 305:../../freeRtos/Lib/cmdline.c **** {
 938               	.LM45:
 939               	.LFBB4:
 940 01a0 1F93      		push r17
 941 01a2 CF93      		push r28
 942 01a4 DF93      		push r29
 943               	/* prologue: function */
 944               	/* frame size = 0 */
 945               	/* stack size = 3 */
 946               	.L__stack_usage = 3
 947 01a6 EC01      		movw r28,r24
 306:../../freeRtos/Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 949               	.LM46:
 950 01a8 8889      		ldd r24,Y+16
 951 01aa 8823      		tst r24
 952 01ac 01F0      		breq .L22
 953               	.LBB6:
 308:../../freeRtos/Lib/cmdline.c ****     uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MAS
 955               	.LM47:
 956 01ae 1F85      		ldd r17,Y+15
 957 01b0 181B      		sub r17,r24
 958 01b2 1370      		andi r17,lo8(3)
 309:../../freeRtos/Lib/cmdline.c ****     memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
 960               	.LM48:
 961 01b4 4C85      		ldd r20,Y+12
 962 01b6 8881      		ld r24,Y
 963 01b8 9981      		ldd r25,Y+1
 964 01ba 60E0      		ldi r22,lo8(0)
 965 01bc 70E0      		ldi r23,hi8(0)
 966 01be 50E0      		ldi r21,lo8(0)
 967 01c0 0E94 0000 		call memset
 310:../../freeRtos/Lib/cmdline.c ****     strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
 969               	.LM49:
 970 01c4 E12F      		mov r30,r17
 971 01c6 F0E0      		ldi r31,lo8(0)
 972 01c8 3296      		adiw r30,2
 973 01ca EE0F      		lsl r30
 974 01cc FF1F      		rol r31
 975 01ce EC0F      		add r30,r28
 976 01d0 FD1F      		adc r31,r29
 977 01d2 6081      		ld r22,Z
 978 01d4 7181      		ldd r23,Z+1
 979 01d6 8881      		ld r24,Y
 980 01d8 9981      		ldd r25,Y+1
 981 01da 0E94 0000 		call strcpy
 982               	.L22:
 983               	.LBE6:
 313:../../freeRtos/Lib/cmdline.c ****   state->historyDepthIdx = 0;
 985               	.LM50:
 986 01de 188A      		std Y+16,__zero_reg__
 314:../../freeRtos/Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 988               	.LM51:
 989 01e0 81E0      		ldi r24,lo8(1)
 990 01e2 898B      		std Y+17,r24
 991               	/* epilogue start */
 315:../../freeRtos/Lib/cmdline.c **** }
 993               	.LM52:
 994 01e4 DF91      		pop r29
 995 01e6 CF91      		pop r28
 996 01e8 1F91      		pop r17
 997 01ea 0895      		ret
 1002               	.Lscope4:
 1004               		.stabd	78,0,0
 1012               	.global	cmdStateConfigure
 1014               	cmdStateConfigure:
 1015               		.stabd	46,0,0
  59:../../freeRtos/Lib/cmdline.c **** {
 1017               	.LM53:
 1018               	.LFBB5:
 1019 01ec 6F92      		push r6
 1020 01ee 7F92      		push r7
 1021 01f0 8F92      		push r8
 1022 01f2 9F92      		push r9
 1023 01f4 AF92      		push r10
 1024 01f6 BF92      		push r11
 1025 01f8 CF92      		push r12
 1026 01fa DF92      		push r13
 1027 01fc EF92      		push r14
 1028 01fe 0F93      		push r16
 1029 0200 1F93      		push r17
 1030 0202 CF93      		push r28
 1031 0204 DF93      		push r29
 1032               	/* prologue: function */
 1033               	/* frame size = 0 */
 1034               	/* stack size = 13 */
 1035               	.L__stack_usage = 13
 1036 0206 EC01      		movw r28,r24
 1037 0208 6B01      		movw r12,r22
 1038 020a 5A01      		movw r10,r20
 1039 020c 4901      		movw r8,r18
  60:../../freeRtos/Lib/cmdline.c ****   memset(state, 0, sizeof(cmdState_t));
 1041               	.LM54:
 1042 020e 83E2      		ldi r24,lo8(35)
 1043 0210 DE01      		movw r26,r28
 1044 0212 1D92      		st X+,__zero_reg__
 1045 0214 8A95      	        dec r24
 1046 0216 01F4      		brne .-6
  61:../../freeRtos/Lib/cmdline.c ****   memset(buffPtr, 0, bufferTotalSize);
 1048               	.LM55:
 1049 0218 CB01      		movw r24,r22
 1050 021a 60E0      		ldi r22,lo8(0)
 1051 021c 70E0      		ldi r23,hi8(0)
 1052 021e 0E94 0000 		call memset
  63:../../freeRtos/Lib/cmdline.c ****   state->CmdlineBuffer = buffPtr;
 1054               	.LM56:
 1055 0222 C882      		st Y,r12
 1056 0224 D982      		std Y+1,r13
  64:../../freeRtos/Lib/cmdline.c ****   state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
 1058               	.LM57:
 1059 0226 B694      		lsr r11
 1060 0228 A794      		ror r10
 1061 022a B694      		lsr r11
 1062 022c A794      		ror r10
 1063 022e AC86      		std Y+12,r10
  66:../../freeRtos/Lib/cmdline.c ****   state->cliMode = mode;
 1065               	.LM58:
 1066 0230 E8A2      		std Y+32,r14
  67:../../freeRtos/Lib/cmdline.c ****   state->cmdList = commands;
 1068               	.LM59:
 1069 0232 09A3      		std Y+33,r16
 1070 0234 1AA3      		std Y+34,r17
  73:../../freeRtos/Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
 1072               	.LM60:
 1073 0236 CC82      		std Y+4,r12
 1074 0238 DD82      		std Y+5,r13
  74:../../freeRtos/Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
 1076               	.LM61:
 1077 023a BB24      		clr r11
 1078 023c CA0C      		add r12,r10
 1079 023e DB1C      		adc r13,r11
  73:../../freeRtos/Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
 1081               	.LM62:
 1082 0240 CE82      		std Y+6,r12
 1083 0242 DF82      		std Y+7,r13
  74:../../freeRtos/Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
 1085               	.LM63:
 1086 0244 CA0C      		add r12,r10
 1087 0246 DB1C      		adc r13,r11
  73:../../freeRtos/Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
 1089               	.LM64:
 1090 0248 C886      		std Y+8,r12
 1091 024a D986      		std Y+9,r13
  74:../../freeRtos/Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
 1093               	.LM65:
 1094 024c AC0C      		add r10,r12
 1095 024e BD1C      		adc r11,r13
  73:../../freeRtos/Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
 1097               	.LM66:
 1098 0250 AA86      		std Y+10,r10
 1099 0252 BB86      		std Y+11,r11
  76:../../freeRtos/Lib/cmdline.c ****   state->myStdInOut = stream;
 1101               	.LM67:
 1102 0254 8A8E      		std Y+26,r8
 1103 0256 9B8E      		std Y+27,r9
 1104               	/* epilogue start */
  77:../../freeRtos/Lib/cmdline.c **** }
 1106               	.LM68:
 1107 0258 DF91      		pop r29
 1108 025a CF91      		pop r28
 1109 025c 1F91      		pop r17
 1110 025e 0F91      		pop r16
 1111 0260 EF90      		pop r14
 1112 0262 DF90      		pop r13
 1113 0264 CF90      		pop r12
 1114 0266 BF90      		pop r11
 1115 0268 AF90      		pop r10
 1116 026a 9F90      		pop r9
 1117 026c 8F90      		pop r8
 1118 026e 7F90      		pop r7
 1119 0270 6F90      		pop r6
 1120 0272 0895      		ret
 1122               	.Lscope5:
 1124               		.stabd	78,0,0
 1128               	.global	cmdlineInputFunc
 1130               	cmdlineInputFunc:
 1131               		.stabd	46,0,0
  93:../../freeRtos/Lib/cmdline.c **** {
 1133               	.LM69:
 1134               	.LFBB6:
 1135 0274 8F92      		push r8
 1136 0276 9F92      		push r9
 1137 0278 AF92      		push r10
 1138 027a BF92      		push r11
 1139 027c CF92      		push r12
 1140 027e DF92      		push r13
 1141 0280 EF92      		push r14
 1142 0282 FF92      		push r15
 1143 0284 0F93      		push r16
 1144 0286 1F93      		push r17
 1145 0288 DF93      		push r29
 1146 028a CF93      		push r28
 1147 028c 00D0      		rcall .
 1148 028e 00D0      		rcall .
 1149 0290 CDB7      		in r28,__SP_L__
 1150 0292 DEB7      		in r29,__SP_H__
 1151               	/* prologue: function */
 1152               	/* frame size = 6 */
 1153               	/* stack size = 18 */
 1154               	.L__stack_usage = 18
 1155 0294 082F      		mov r16,r24
 1156 0296 7B01      		movw r14,r22
  99:../../freeRtos/Lib/cmdline.c ****   if(state->CmdlineInputVT100State == 2)
 1158               	.LM70:
 1159 0298 DB01      		movw r26,r22
 1160 029a 5296      		adiw r26,18
 1161 029c 8C91      		ld r24,X
 1162 029e 5297      		sbiw r26,18
 1163 02a0 8230      		cpi r24,lo8(2)
 1164 02a2 01F0      		breq .+2
 1165 02a4 00C0      		rjmp .L25
 103:../../freeRtos/Lib/cmdline.c ****     switch(c)
 1167               	.LM71:
 1168 02a6 0234      		cpi r16,lo8(66)
 1169 02a8 01F0      		breq .L28
 1170 02aa 0334      		cpi r16,lo8(67)
 1171 02ac 04F4      		brge .L31
 1172 02ae 0134      		cpi r16,lo8(65)
 1173 02b0 01F0      		breq .+2
 1174 02b2 00C0      		rjmp .L26
 1175 02b4 00C0      		rjmp .L81
 1176               	.L31:
 1177 02b6 0334      		cpi r16,lo8(67)
 1178 02b8 01F0      		breq .L29
 1179 02ba 0434      		cpi r16,lo8(68)
 1180 02bc 01F0      		breq .+2
 1181 02be 00C0      		rjmp .L26
 1182 02c0 00C0      		rjmp .L82
 1183               	.L81:
 106:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
 1185               	.LM72:
 1186 02c2 81E0      		ldi r24,lo8(1)
 1187 02c4 00C0      		rjmp .L77
 1188               	.L28:
 109:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
 1190               	.LM73:
 1191 02c6 82E0      		ldi r24,lo8(2)
 1192               	.L77:
 1193 02c8 B701      		movw r22,r14
 1194 02ca 0E94 0000 		call cmdlineDoHistory
 110:../../freeRtos/Lib/cmdline.c ****       break;
 1196               	.LM74:
 1197 02ce 00C0      		rjmp .L26
 1198               	.L29:
 112:../../freeRtos/Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 1200               	.LM75:
 1201 02d0 FB01      		movw r30,r22
 1202 02d2 8189      		ldd r24,Z+17
 1203 02d4 8823      		tst r24
 1204 02d6 01F4      		brne .L32
 113:../../freeRtos/Lib/cmdline.c ****         cmdHistoryCopy(state);
 1206               	.LM76:
 1207 02d8 CB01      		movw r24,r22
 1208 02da 0E94 0000 		call cmdHistoryCopy
 1209               	.L32:
 115:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
 1211               	.LM77:
 1212 02de D701      		movw r26,r14
 1213 02e0 1E96      		adiw r26,14
 1214 02e2 8C91      		ld r24,X
 1215 02e4 1E97      		sbiw r26,14
 1216 02e6 1D96      		adiw r26,13
 1217 02e8 9C91      		ld r25,X
 1218 02ea 1D97      		sbiw r26,13
 1219 02ec 5A96      		adiw r26,26
 1220 02ee 6D91      		ld r22,X+
 1221 02f0 7C91      		ld r23,X
 1222 02f2 5B97      		sbiw r26,26+1
 1223 02f4 8917      		cp r24,r25
 1224 02f6 00F4      		brsh .L35
 118:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos++;
 1226               	.LM78:
 1227 02f8 8F5F      		subi r24,lo8(-(1))
 1228 02fa 1E96      		adiw r26,14
 1229 02fc 8C93      		st X,r24
 120:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_ESC        , state->myStdInOut);
 1231               	.LM79:
 1232 02fe 8BE1      		ldi r24,lo8(27)
 1233 0300 90E0      		ldi r25,hi8(27)
 1234 0302 0E94 0000 		call fputc
 121:../../freeRtos/Lib/cmdline.c ****         fputc('['              , state->myStdInOut);
 1236               	.LM80:
 1237 0306 F701      		movw r30,r14
 1238 0308 628D      		ldd r22,Z+26
 1239 030a 738D      		ldd r23,Z+27
 1240 030c 8BE5      		ldi r24,lo8(91)
 1241 030e 90E0      		ldi r25,hi8(91)
 1242 0310 0E94 0000 		call fputc
 122:../../freeRtos/Lib/cmdline.c ****         fputc(VT100_ARROWRIGHT , state->myStdInOut);
 1244               	.LM81:
 1245 0314 D701      		movw r26,r14
 1246 0316 5A96      		adiw r26,26
 1247 0318 6D91      		ld r22,X+
 1248 031a 7C91      		ld r23,X
 1249 031c 5B97      		sbiw r26,26+1
 1250 031e 83E4      		ldi r24,lo8(67)
 1251 0320 90E0      		ldi r25,hi8(67)
 1252 0322 00C0      		rjmp .L78
 1253               	.L82:
 132:../../freeRtos/Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 1255               	.LM82:
 1256 0324 FB01      		movw r30,r22
 1257 0326 8189      		ldd r24,Z+17
 1258 0328 8823      		tst r24
 1259 032a 01F4      		brne .L34
 133:../../freeRtos/Lib/cmdline.c ****         cmdHistoryCopy(state);
 1261               	.LM83:
 1262 032c CB01      		movw r24,r22
 1263 032e 0E94 0000 		call cmdHistoryCopy
 1264               	.L34:
 135:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos)
 1266               	.LM84:
 1267 0332 D701      		movw r26,r14
 1268 0334 1E96      		adiw r26,14
 1269 0336 8C91      		ld r24,X
 1270 0338 1E97      		sbiw r26,14
 1271 033a 5A96      		adiw r26,26
 1272 033c 6D91      		ld r22,X+
 1273 033e 7C91      		ld r23,X
 1274 0340 5B97      		sbiw r26,26+1
 1275 0342 8823      		tst r24
 1276 0344 01F0      		breq .L35
 138:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 1278               	.LM85:
 1279 0346 8150      		subi r24,lo8(-(-1))
 1280 0348 1E96      		adiw r26,14
 1281 034a 8C93      		st X,r24
 1282 034c 1E97      		sbiw r26,14
 140:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1284               	.LM86:
 1285 034e 88E0      		ldi r24,lo8(8)
 1286 0350 90E0      		ldi r25,hi8(8)
 1287 0352 00C0      		rjmp .L78
 1288               	.L35:
 145:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 1290               	.LM87:
 1291 0354 87E0      		ldi r24,lo8(7)
 1292 0356 90E0      		ldi r25,hi8(7)
 1293               	.L78:
 1294 0358 0E94 0000 		call fputc
 1295               	.L26:
 152:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 1297               	.LM88:
 1298 035c F701      		movw r30,r14
 1299 035e 128A      		std Z+18,__zero_reg__
 153:../../freeRtos/Lib/cmdline.c ****     return;
 1301               	.LM89:
 1302 0360 00C0      		rjmp .L24
 1303               	.L25:
 155:../../freeRtos/Lib/cmdline.c ****   else if(state->CmdlineInputVT100State == 1)
 1305               	.LM90:
 1306 0362 8130      		cpi r24,lo8(1)
 1307 0364 01F4      		brne .L37
 158:../../freeRtos/Lib/cmdline.c ****     if(c == '[')
 1309               	.LM91:
 1310 0366 0B35      		cpi r16,lo8(91)
 1311 0368 01F4      		brne .L38
 160:../../freeRtos/Lib/cmdline.c ****       state->CmdlineInputVT100State = 2;
 1313               	.LM92:
 1314 036a 82E0      		ldi r24,lo8(2)
 1315 036c 00C0      		rjmp .L80
 1316               	.L38:
 164:../../freeRtos/Lib/cmdline.c ****       state->CmdlineInputVT100State = 0;
 1318               	.LM93:
 1319 036e FB01      		movw r30,r22
 1320 0370 128A      		std Z+18,__zero_reg__
 1321 0372 00C0      		rjmp .L39
 1322               	.L37:
 169:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 1324               	.LM94:
 1325 0374 DB01      		movw r26,r22
 1326 0376 5296      		adiw r26,18
 1327 0378 1C92      		st X,__zero_reg__
 1328 037a 5297      		sbiw r26,18
 1329               	.L39:
 174:../../freeRtos/Lib/cmdline.c ****   if (state->CmdlineBufferLength == state->bufferMaxSize)
 1331               	.LM95:
 1332 037c F701      		movw r30,r14
 1333 037e 8585      		ldd r24,Z+13
 1334 0380 9485      		ldd r25,Z+12
 1335 0382 8917      		cp r24,r25
 1336 0384 01F4      		brne .L40
 176:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength--;
 1338               	.LM96:
 1339 0386 8150      		subi r24,lo8(-(-1))
 1340 0388 8587      		std Z+13,r24
 177:../../freeRtos/Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1342               	.LM97:
 1343 038a 81E0      		ldi r24,lo8(1)
 1344 038c 00C0      		rjmp .L41
 1345               	.L42:
 179:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
 1347               	.LM98:
 1348 038e D701      		movw r26,r14
 1349 0390 ED91      		ld r30,X+
 1350 0392 FC91      		ld r31,X
 1351 0394 E80F      		add r30,r24
 1352 0396 F11D      		adc r31,__zero_reg__
 1353 0398 DF01      		movw r26,r30
 1354 039a 1197      		sbiw r26,1
 1355 039c 9081      		ld r25,Z
 1356 039e 9C93      		st X,r25
 177:../../freeRtos/Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1358               	.LM99:
 1359 03a0 8F5F      		subi r24,lo8(-(1))
 1360               	.L41:
 177:../../freeRtos/Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1362               	.LM100:
 1363 03a2 F701      		movw r30,r14
 1364 03a4 9485      		ldd r25,Z+12
 1365 03a6 8917      		cp r24,r25
 1366 03a8 00F0      		brlo .L42
 1367               	.L40:
 183:../../freeRtos/Lib/cmdline.c ****   if( (c >= 0x20) && (c < 0x7F) )
 1369               	.LM101:
 1370 03aa 802F      		mov r24,r16
 1371 03ac 8052      		subi r24,lo8(-(-32))
 1372 03ae 8F35      		cpi r24,lo8(95)
 1373 03b0 00F0      		brlo .+2
 1374 03b2 00C0      		rjmp .L43
 185:../../freeRtos/Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 1376               	.LM102:
 1377 03b4 D701      		movw r26,r14
 1378 03b6 5196      		adiw r26,17
 1379 03b8 8C91      		ld r24,X
 1380 03ba 5197      		sbiw r26,17
 1381 03bc 8823      		tst r24
 1382 03be 01F4      		brne .L44
 186:../../freeRtos/Lib/cmdline.c ****       cmdHistoryCopy(state);
 1384               	.LM103:
 1385 03c0 C701      		movw r24,r14
 1386 03c2 0E94 0000 		call cmdHistoryCopy
 1387               	.L44:
 189:../../freeRtos/Lib/cmdline.c ****     if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 1389               	.LM104:
 1390 03c6 F701      		movw r30,r14
 1391 03c8 8585      		ldd r24,Z+13
 1392 03ca 9685      		ldd r25,Z+14
 1393 03cc 9817      		cp r25,r24
 1394 03ce 01F4      		brne .L45
 192:../../freeRtos/Lib/cmdline.c ****       fputc(c                , state->myStdInOut);
 1396               	.LM105:
 1397 03d0 628D      		ldd r22,Z+26
 1398 03d2 738D      		ldd r23,Z+27
 1399 03d4 802F      		mov r24,r16
 1400 03d6 9927      		clr r25
 1401 03d8 87FD      		sbrc r24,7
 1402 03da 9095      		com r25
 1403 03dc 0E94 0000 		call fputc
 194:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 1405               	.LM106:
 1406 03e0 D701      		movw r26,r14
 1407 03e2 1E96      		adiw r26,14
 1408 03e4 8C91      		ld r24,X
 1409 03e6 1E97      		sbiw r26,14
 1410 03e8 ED91      		ld r30,X+
 1411 03ea FC91      		ld r31,X
 1412 03ec 1197      		sbiw r26,1
 1413 03ee E80F      		add r30,r24
 1414 03f0 F11D      		adc r31,__zero_reg__
 1415 03f2 0083      		st Z,r16
 1416 03f4 8F5F      		subi r24,lo8(-(1))
 1417 03f6 1E96      		adiw r26,14
 1418 03f8 8C93      		st X,r24
 1419 03fa 1E97      		sbiw r26,14
 196:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBufferLength++;
 1421               	.LM107:
 1422 03fc 1D96      		adiw r26,13
 1423 03fe 8C91      		ld r24,X
 1424 0400 1D97      		sbiw r26,13
 1425 0402 8F5F      		subi r24,lo8(-(1))
 1426 0404 1D96      		adiw r26,13
 1427 0406 8C93      		st X,r24
 1428 0408 1D97      		sbiw r26,13
 1429 040a 00C0      		rjmp .L24
 1430               	.L45:
 203:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBufferLength++;
 1432               	.LM108:
 1433 040c 8F5F      		subi r24,lo8(-(1))
 1434 040e F701      		movw r30,r14
 1435 0410 8587      		std Z+13,r24
 204:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 1437               	.LM109:
 1438 0412 00C0      		rjmp .L46
 1439               	.L47:
 205:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
 1441               	.LM110:
 1442 0414 680F      		add r22,r24
 1443 0416 711D      		adc r23,__zero_reg__
 1444 0418 FB01      		movw r30,r22
 1445 041a 3197      		sbiw r30,1
 1446 041c 9081      		ld r25,Z
 1447 041e DB01      		movw r26,r22
 1448 0420 9C93      		st X,r25
 204:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 1450               	.LM111:
 1451 0422 8150      		subi r24,lo8(-(-1))
 1452               	.L46:
 204:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 1454               	.LM112:
 1455 0424 F701      		movw r30,r14
 1456 0426 9685      		ldd r25,Z+14
 1457 0428 6081      		ld r22,Z
 1458 042a 7181      		ldd r23,Z+1
 1459 042c 9817      		cp r25,r24
 1460 042e 00F0      		brlo .L47
 207:../../freeRtos/Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 1462               	.LM113:
 1463 0430 690F      		add r22,r25
 1464 0432 711D      		adc r23,__zero_reg__
 1465 0434 DB01      		movw r26,r22
 1466 0436 0C93      		st X,r16
 1467 0438 9F5F      		subi r25,lo8(-(1))
 1468 043a 9687      		std Z+14,r25
 209:../../freeRtos/Lib/cmdline.c ****       cmdlineRepaint(state, state->CmdlineBuffer);
 1470               	.LM114:
 1471 043c 6081      		ld r22,Z
 1472 043e 7181      		ldd r23,Z+1
 1473 0440 C701      		movw r24,r14
 1474 0442 0E94 0000 		call cmdlineRepaint
 211:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1476               	.LM115:
 1477 0446 F701      		movw r30,r14
 1478 0448 0685      		ldd r16,Z+14
 1479 044a 00C0      		rjmp .L48
 1480               	.L49:
 212:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1482               	.LM116:
 1483 044c D701      		movw r26,r14
 1484 044e 5A96      		adiw r26,26
 1485 0450 6D91      		ld r22,X+
 1486 0452 7C91      		ld r23,X
 1487 0454 5B97      		sbiw r26,26+1
 1488 0456 88E0      		ldi r24,lo8(8)
 1489 0458 90E0      		ldi r25,hi8(8)
 1490 045a 0E94 0000 		call fputc
 211:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1492               	.LM117:
 1493 045e 0F5F      		subi r16,lo8(-(1))
 1494               	.L48:
 211:../../freeRtos/Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1496               	.LM118:
 1497 0460 F701      		movw r30,r14
 1498 0462 8585      		ldd r24,Z+13
 1499 0464 0817      		cp r16,r24
 1500 0466 00F0      		brlo .L49
 1501 0468 00C0      		rjmp .L24
 1502               	.L43:
 216:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_CR)
 1504               	.LM119:
 1505 046a 0D30      		cpi r16,lo8(13)
 1506 046c 01F0      		breq .+2
 1507 046e 00C0      		rjmp .L50
 218:../../freeRtos/Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 1509               	.LM120:
 1510 0470 D701      		movw r26,r14
 1511 0472 5196      		adiw r26,17
 1512 0474 8C91      		ld r24,X
 1513 0476 5197      		sbiw r26,17
 1514 0478 8823      		tst r24
 1515 047a 01F0      		breq .+2
 1516 047c 00C0      		rjmp .L51
 1517               	.LBB17:
 1518               	.LBB18:
 319:../../freeRtos/Lib/cmdline.c ****   uint8_t i=state->historyDepthIdx;
 1520               	.LM121:
 1521 047e 5096      		adiw r26,16
 1522 0480 4C91      		ld r20,X
 1523 0482 5097      		sbiw r26,16
 321:../../freeRtos/Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 1525               	.LM122:
 1526 0484 4423      		tst r20
 1527 0486 01F0      		breq .L52
 323:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
 1529               	.LM123:
 1530 0488 1F96      		adiw r26,15
 1531 048a 8C91      		ld r24,X
 1532 048c 1F97      		sbiw r26,15
 1533 048e 90E0      		ldi r25,lo8(0)
 1534 0490 FC01      		movw r30,r24
 1535 0492 E41B      		sub r30,r20
 1536 0494 F109      		sbc r31,__zero_reg__
 1537 0496 E370      		andi r30,lo8(3)
 1538 0498 F070      		andi r31,hi8(3)
 1539 049a 3296      		adiw r30,2
 1540 049c EE0F      		lsl r30
 1541 049e FF1F      		rol r31
 1542 04a0 EE0D      		add r30,r14
 1543 04a2 FF1D      		adc r31,r15
 1544 04a4 2081      		ld r18,Z
 1545 04a6 3181      		ldd r19,Z+1
 1546 04a8 2D93      		st X+,r18
 1547 04aa 3C93      		st X,r19
 1548 04ac 1197      		sbiw r26,1
 1549 04ae 00C0      		rjmp .L53
 1550               	.L54:
 326:../../freeRtos/Lib/cmdline.c ****       state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHisto
 1552               	.LM124:
 1553 04b0 FC01      		movw r30,r24
 1554 04b2 E41B      		sub r30,r20
 1555 04b4 F109      		sbc r31,__zero_reg__
 1556 04b6 DF01      		movw r26,r30
 1557 04b8 A370      		andi r26,lo8(3)
 1558 04ba B070      		andi r27,hi8(3)
 1559 04bc 1296      		adiw r26,2
 1560 04be AA0F      		lsl r26
 1561 04c0 BB1F      		rol r27
 1562 04c2 AE0D      		add r26,r14
 1563 04c4 BF1D      		adc r27,r15
 1564 04c6 3197      		sbiw r30,1
 1565 04c8 E370      		andi r30,lo8(3)
 1566 04ca F070      		andi r31,hi8(3)
 1567 04cc 3296      		adiw r30,2
 1568 04ce EE0F      		lsl r30
 1569 04d0 FF1F      		rol r31
 1570 04d2 EE0D      		add r30,r14
 1571 04d4 FF1D      		adc r31,r15
 1572 04d6 2081      		ld r18,Z
 1573 04d8 3181      		ldd r19,Z+1
 1574 04da 2D93      		st X+,r18
 1575 04dc 3C93      		st X,r19
 1576 04de 1197      		sbiw r26,1
 324:../../freeRtos/Lib/cmdline.c ****     for ( ; i<CMD_STATE_HISTORY; i++)
 1578               	.LM125:
 1579 04e0 4F5F      		subi r20,lo8(-(1))
 1580               	.L53:
 1581 04e2 4430      		cpi r20,lo8(4)
 1582 04e4 00F0      		brlo .L54
 1583               	.L52:
 329:../../freeRtos/Lib/cmdline.c ****   state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
 1585               	.LM126:
 1586 04e6 D701      		movw r26,r14
 1587 04e8 1F96      		adiw r26,15
 1588 04ea EC91      		ld r30,X
 1589 04ec 1F97      		sbiw r26,15
 1590 04ee F0E0      		ldi r31,lo8(0)
 1591 04f0 3296      		adiw r30,2
 1592 04f2 EE0F      		lsl r30
 1593 04f4 FF1F      		rol r31
 1594 04f6 EE0D      		add r30,r14
 1595 04f8 FF1D      		adc r31,r15
 1596 04fa 8D91      		ld r24,X+
 1597 04fc 9C91      		ld r25,X
 1598 04fe 1197      		sbiw r26,1
 1599 0500 8083      		st Z,r24
 1600 0502 9183      		std Z+1,r25
 331:../../freeRtos/Lib/cmdline.c ****   state->historyDepthIdx = 0;
 1602               	.LM127:
 1603 0504 5096      		adiw r26,16
 1604 0506 1C92      		st X,__zero_reg__
 1605 0508 5097      		sbiw r26,16
 332:../../freeRtos/Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 1607               	.LM128:
 1608 050a 81E0      		ldi r24,lo8(1)
 1609 050c 5196      		adiw r26,17
 1610 050e 8C93      		st X,r24
 1611               	.L51:
 1612               	.LBE18:
 1613               	.LBE17:
 223:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_CR         , state->myStdInOut);
 1615               	.LM129:
 1616 0510 F701      		movw r30,r14
 1617 0512 628D      		ldd r22,Z+26
 1618 0514 738D      		ldd r23,Z+27
 1619 0516 8DE0      		ldi r24,lo8(13)
 1620 0518 90E0      		ldi r25,hi8(13)
 1621 051a 0E94 0000 		call fputc
 224:../../freeRtos/Lib/cmdline.c ****     fputc(ASCII_LF         , state->myStdInOut);
 1623               	.LM130:
 1624 051e D701      		movw r26,r14
 1625 0520 5A96      		adiw r26,26
 1626 0522 6D91      		ld r22,X+
 1627 0524 7C91      		ld r23,X
 1628 0526 5B97      		sbiw r26,26+1
 1629 0528 8AE0      		ldi r24,lo8(10)
 1630 052a 90E0      		ldi r25,hi8(10)
 1631 052c 0E94 0000 		call fputc
 226:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
 1633               	.LM131:
 1634 0530 F701      		movw r30,r14
 1635 0532 8585      		ldd r24,Z+13
 1636 0534 0190      		ld __tmp_reg__,Z+
 1637 0536 F081      		ld r31,Z
 1638 0538 E02D      		mov r30,__tmp_reg__
 1639 053a E80F      		add r30,r24
 1640 053c F11D      		adc r31,__zero_reg__
 1641 053e 1082      		st Z,__zero_reg__
 1642 0540 8F5F      		subi r24,lo8(-(1))
 1643 0542 D701      		movw r26,r14
 1644 0544 1D96      		adiw r26,13
 1645 0546 8C93      		st X,r24
 1646 0548 1D97      		sbiw r26,13
 227:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos++;
 1648               	.LM132:
 1649 054a 1E96      		adiw r26,14
 1650 054c 8C91      		ld r24,X
 1651 054e 1E97      		sbiw r26,14
 1652 0550 8F5F      		subi r24,lo8(-(1))
 1653 0552 1E96      		adiw r26,14
 1654 0554 8C93      		st X,r24
 1655 0556 1E97      		sbiw r26,14
 1656               	.LBB19:
 1657               	.LBB20:
 398:../../freeRtos/Lib/cmdline.c ****   state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer la
 1659               	.LM133:
 1660 0558 8D91      		ld r24,X+
 1661 055a 9C91      		ld r25,X
 1662 055c 1197      		sbiw r26,1
 1663 055e 1296      		adiw r26,2
 1664 0560 8D93      		st X+,r24
 1665 0562 9C93      		st X,r25
 1666 0564 1397      		sbiw r26,2+1
 397:../../freeRtos/Lib/cmdline.c ****   uint8_t i=0;
 1668               	.LM134:
 1669 0566 20E0      		ldi r18,lo8(0)
 1670 0568 00C0      		rjmp .L55
 1671               	.L57:
 402:../../freeRtos/Lib/cmdline.c ****     i++;                                                              // i determines the cammand l
 1673               	.LM135:
 1674 056a 2F5F      		subi r18,lo8(-(1))
 1675               	.L55:
 400:../../freeRtos/Lib/cmdline.c ****   while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the comman
 1677               	.LM136:
 1678 056c A22E      		mov r10,r18
 1679 056e BB24      		clr r11
 1680 0570 FC01      		movw r30,r24
 1681 0572 EA0D      		add r30,r10
 1682 0574 FB1D      		adc r31,r11
 1683 0576 3081      		ld r19,Z
 1684 0578 3032      		cpi r19,lo8(32)
 1685 057a 01F0      		breq .L56
 1686 057c 3323      		tst r19
 1687 057e 01F4      		brne .L57
 1688               	.L56:
 404:../../freeRtos/Lib/cmdline.c ****   if(!i)                                                              // command was null or empty
 1690               	.LM137:
 1691 0580 2223      		tst r18
 1692 0582 01F4      		brne .+2
 1693 0584 00C0      		rjmp .L79
 1694               	.L58:
 410:../../freeRtos/Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The 
 1696               	.LM138:
 1697 0586 F701      		movw r30,r14
 1698 0588 C1A0      		ldd r12,Z+33
 1699 058a D2A0      		ldd r13,Z+34
 412:../../freeRtos/Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need t
 1701               	.LM139:
 1702 058c 8E01      		movw r16,r28
 1703 058e 0F5F      		subi r16,lo8(-(1))
 1704 0590 1F4F      		sbci r17,hi8(-(1))
 1705 0592 C801      		movw r24,r16
 1706 0594 B601      		movw r22,r12
 1707 0596 46E0      		ldi r20,lo8(6)
 1708 0598 50E0      		ldi r21,hi8(6)
 1709 059a 0E94 0000 		call memcpy_P
 425:../../freeRtos/Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from fla
 1711               	.LM140:
 1712 059e 902E      		mov r9,r16
 1713 05a0 812E      		mov r8,r17
 1714               	.L61:
 416:../../freeRtos/Lib/cmdline.c ****     if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command match
 1716               	.LM141:
 1717 05a2 0981      		ldd r16,Y+1
 1718 05a4 1A81      		ldd r17,Y+2
 1719 05a6 D701      		movw r26,r14
 1720 05a8 1296      		adiw r26,2
 1721 05aa 8D91      		ld r24,X+
 1722 05ac 9C91      		ld r25,X
 1723 05ae 1397      		sbiw r26,2+1
 1724 05b0 B801      		movw r22,r16
 1725 05b2 A501      		movw r20,r10
 1726 05b4 0E94 0000 		call strncmp_P
 1727 05b8 0097      		sbiw r24,0
 1728 05ba 01F4      		brne .L60
 418:../../freeRtos/Lib/cmdline.c ****       state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
 1730               	.LM142:
 1731 05bc 8D81      		ldd r24,Y+5
 1732 05be 9E81      		ldd r25,Y+6
 1733 05c0 F701      		movw r30,r14
 1734 05c2 878B      		std Z+23,r24
 1735 05c4 908F      		std Z+24,r25
 419:../../freeRtos/Lib/cmdline.c ****       state->command_str         = tmp.commandStr;
 1737               	.LM143:
 1738 05c6 038B      		std Z+19,r16
 1739 05c8 148B      		std Z+20,r17
 420:../../freeRtos/Lib/cmdline.c ****       state->command_help_str    = tmp.commandHelpStr;
 1741               	.LM144:
 1742 05ca 8B81      		ldd r24,Y+3
 1743 05cc 9C81      		ldd r25,Y+4
 1744 05ce 858B      		std Z+21,r24
 1745 05d0 968B      		std Z+22,r25
 421:../../freeRtos/Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
 1747               	.LM145:
 1748 05d2 80E0      		ldi r24,lo8(0)
 1749 05d4 B701      		movw r22,r14
 1750 05d6 0E94 0000 		call cmdlineDoHistory
 1751 05da 00C0      		rjmp .L59
 1752               	.L60:
 424:../../freeRtos/Lib/cmdline.c ****     tmpPtr++;                                                         // Next command
 1754               	.LM146:
 1755 05dc 86E0      		ldi r24,lo8(6)
 1756 05de 90E0      		ldi r25,hi8(6)
 1757 05e0 C80E      		add r12,r24
 1758 05e2 D91E      		adc r13,r25
 425:../../freeRtos/Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from fla
 1760               	.LM147:
 1761 05e4 892D      		mov r24,r9
 1762 05e6 982D      		mov r25,r8
 1763 05e8 B601      		movw r22,r12
 1764 05ea 46E0      		ldi r20,lo8(6)
 1765 05ec 50E0      		ldi r21,hi8(6)
 1766 05ee 0E94 0000 		call memcpy_P
 427:../../freeRtos/Lib/cmdline.c ****   while (tmp.commandStr != NULL);                                     // Last command on the list i
 1768               	.LM148:
 1769 05f2 8981      		ldd r24,Y+1
 1770 05f4 9A81      		ldd r25,Y+2
 1771 05f6 0097      		sbiw r24,0
 1772 05f8 01F4      		brne .L61
 1773 05fa 00E0      		ldi r16,lo8(CmdlineNotice)
 1774 05fc 10E0      		ldi r17,hi8(CmdlineNotice)
 1775 05fe 00C0      		rjmp .L62
 1776               	.L63:
 1777               	.LBB21:
 1778               	.LBB22:
 1779               	.LBB23:
 492:../../freeRtos/Lib/cmdline.c **** 
 493:../../freeRtos/Lib/cmdline.c **** void cmdlinePrintError(cmdState_t *state)
 494:../../freeRtos/Lib/cmdline.c **** {
 495:../../freeRtos/Lib/cmdline.c ****   char * ptr;
 496:../../freeRtos/Lib/cmdline.c **** 
 497:../../freeRtos/Lib/cmdline.c ****   // print a notice header
 498:../../freeRtos/Lib/cmdline.c ****   // (uint8_t*) cast used to avoid compiler warning
 499:../../freeRtos/Lib/cmdline.c ****   ptr = (char*)CmdlineNotice;
 500:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 501:../../freeRtos/Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 1781               	.LM149:
 1782 0600 0F5F      		subi r16,lo8(-(1))
 1783 0602 1F4F      		sbci r17,hi8(-(1))
 1784 0604 FC01      		movw r30,r24
 1785               	/* #APP */
 1786               	 ;  501 "../../freeRtos/Lib/cmdline.c" 1
 1787 0606 8491      		lpm r24, Z
 1788               		
 1789               	 ;  0 "" 2
 1790               	/* #NOAPP */
 1791               	.LBE23:
 1792 0608 D701      		movw r26,r14
 1793 060a 5A96      		adiw r26,26
 1794 060c 6D91      		ld r22,X+
 1795 060e 7C91      		ld r23,X
 1796 0610 5B97      		sbiw r26,26+1
 1797 0612 90E0      		ldi r25,lo8(0)
 1798 0614 0E94 0000 		call fputc
 1799               	.L62:
 1800 0618 C801      		movw r24,r16
 1801               	.LBB24:
 500:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 1803               	.LM150:
 1804 061a F801      		movw r30,r16
 1805               	/* #APP */
 1806               	 ;  500 "../../freeRtos/Lib/cmdline.c" 1
 1807 061c 2491      		lpm r18, Z
 1808               		
 1809               	 ;  0 "" 2
 1810               	/* #NOAPP */
 1811               	.LBE24:
 1812 061e 2223      		tst r18
 1813 0620 01F4      		brne .L63
 1814 0622 D701      		movw r26,r14
 1815 0624 0D91      		ld r16,X+
 1816 0626 1C91      		ld r17,X
 1817 0628 1197      		sbiw r26,1
 1818 062a 00C0      		rjmp .L64
 1819               	.L66:
 502:../../freeRtos/Lib/cmdline.c ****   
 503:../../freeRtos/Lib/cmdline.c ****   // print the offending command
 504:../../freeRtos/Lib/cmdline.c ****   ptr = state->CmdlineBuffer;
 505:../../freeRtos/Lib/cmdline.c ****   while((*ptr) && (*ptr != ' '))
 506:../../freeRtos/Lib/cmdline.c ****     fputc(*ptr++    , state->myStdInOut);
 1821               	.LM151:
 1822 062c F701      		movw r30,r14
 1823 062e 628D      		ldd r22,Z+26
 1824 0630 738D      		ldd r23,Z+27
 1825 0632 9927      		clr r25
 1826 0634 87FD      		sbrc r24,7
 1827 0636 9095      		com r25
 1828 0638 0E94 0000 		call fputc
 1829               	.L64:
 505:../../freeRtos/Lib/cmdline.c ****   while((*ptr) && (*ptr != ' '))
 1831               	.LM152:
 1832 063c D801      		movw r26,r16
 1833 063e 8D91      		ld r24,X+
 1834 0640 8D01      		movw r16,r26
 1835 0642 8823      		tst r24
 1836 0644 01F0      		breq .L65
 1837 0646 8032      		cpi r24,lo8(32)
 1838 0648 01F4      		brne .L66
 1839               	.L65:
 507:../../freeRtos/Lib/cmdline.c **** 
 508:../../freeRtos/Lib/cmdline.c ****   fputc(':'         , state->myStdInOut);
 1841               	.LM153:
 1842 064a F701      		movw r30,r14
 1843 064c 628D      		ldd r22,Z+26
 1844 064e 738D      		ldd r23,Z+27
 1845 0650 8AE3      		ldi r24,lo8(58)
 1846 0652 90E0      		ldi r25,hi8(58)
 1847 0654 0E94 0000 		call fputc
 509:../../freeRtos/Lib/cmdline.c ****   fputc(' '         , state->myStdInOut);
 1849               	.LM154:
 1850 0658 D701      		movw r26,r14
 1851 065a 5A96      		adiw r26,26
 1852 065c 6D91      		ld r22,X+
 1853 065e 7C91      		ld r23,X
 1854 0660 5B97      		sbiw r26,26+1
 1855 0662 80E2      		ldi r24,lo8(32)
 1856 0664 90E0      		ldi r25,hi8(32)
 1857 0666 0E94 0000 		call fputc
 510:../../freeRtos/Lib/cmdline.c **** 
 511:../../freeRtos/Lib/cmdline.c ****   // print the not-found message
 512:../../freeRtos/Lib/cmdline.c ****   // (uint8_t*) cast used to avoid compiler warning
 513:../../freeRtos/Lib/cmdline.c ****   ptr = (char*)CmdlineCmdNotFound;
 1859               	.LM155:
 1860 066a 00E0      		ldi r16,lo8(CmdlineCmdNotFound)
 1861 066c 10E0      		ldi r17,hi8(CmdlineCmdNotFound)
 1862 066e 00C0      		rjmp .L67
 1863               	.L68:
 1864               	.LBB25:
 514:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 515:../../freeRtos/Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 1866               	.LM156:
 1867 0670 0F5F      		subi r16,lo8(-(1))
 1868 0672 1F4F      		sbci r17,hi8(-(1))
 1869 0674 FC01      		movw r30,r24
 1870               	/* #APP */
 1871               	 ;  515 "../../freeRtos/Lib/cmdline.c" 1
 1872 0676 8491      		lpm r24, Z
 1873               		
 1874               	 ;  0 "" 2
 1875               	/* #NOAPP */
 1876               	.LBE25:
 1877 0678 90E0      		ldi r25,lo8(0)
 1878 067a 0E94 0000 		call fputc
 1879               	.L67:
 1880 067e C801      		movw r24,r16
 1881               	.LBB26:
 514:../../freeRtos/Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 1883               	.LM157:
 1884 0680 F801      		movw r30,r16
 1885               	/* #APP */
 1886               	 ;  514 "../../freeRtos/Lib/cmdline.c" 1
 1887 0682 2491      		lpm r18, Z
 1888               		
 1889               	 ;  0 "" 2
 1890               	/* #NOAPP */
 1891 0684 D701      		movw r26,r14
 1892 0686 5A96      		adiw r26,26
 1893 0688 6D91      		ld r22,X+
 1894 068a 7C91      		ld r23,X
 1895 068c 5B97      		sbiw r26,26+1
 1896               	.LBE26:
 1897 068e 2223      		tst r18
 1898 0690 01F4      		brne .L68
 516:../../freeRtos/Lib/cmdline.c **** 
 517:../../freeRtos/Lib/cmdline.c ****   fputc('\r'        , state->myStdInOut);
 1900               	.LM158:
 1901 0692 8DE0      		ldi r24,lo8(13)
 1902 0694 90E0      		ldi r25,hi8(13)
 1903 0696 0E94 0000 		call fputc
 518:../../freeRtos/Lib/cmdline.c ****   fputc('\n'        , state->myStdInOut);
 1905               	.LM159:
 1906 069a F701      		movw r30,r14
 1907 069c 628D      		ldd r22,Z+26
 1908 069e 738D      		ldd r23,Z+27
 1909 06a0 8AE0      		ldi r24,lo8(10)
 1910 06a2 90E0      		ldi r25,hi8(10)
 1911 06a4 0E94 0000 		call fputc
 1912               	.L79:
 1913               	.LBE22:
 1914               	.LBE21:
 431:../../freeRtos/Lib/cmdline.c ****   cmdlinePrintPrompt(state);                                          // output a new prompt
 1916               	.LM160:
 1917 06a8 C701      		movw r24,r14
 1918 06aa 0E94 0000 		call cmdlinePrintPrompt
 1919               	.L59:
 1920               	.LBE20:
 1921               	.LBE19:
 231:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferLength = 0;
 1923               	.LM161:
 1924 06ae D701      		movw r26,r14
 1925 06b0 1D96      		adiw r26,13
 1926 06b2 1C92      		st X,__zero_reg__
 1927 06b4 1D97      		sbiw r26,13
 232:../../freeRtos/Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;
 1929               	.LM162:
 1930 06b6 1E96      		adiw r26,14
 1931 06b8 1C92      		st X,__zero_reg__
 1932 06ba 1E97      		sbiw r26,14
 1933 06bc 00C0      		rjmp .L24
 1934               	.L50:
 234:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_BS)
 1936               	.LM163:
 1937 06be 0830      		cpi r16,lo8(8)
 1938 06c0 01F0      		breq .+2
 1939 06c2 00C0      		rjmp .L69
 236:../../freeRtos/Lib/cmdline.c ****     if(state->CmdlineBufferEditPos)
 1941               	.LM164:
 1942 06c4 F701      		movw r30,r14
 1943 06c6 8685      		ldd r24,Z+14
 1944 06c8 8823      		tst r24
 1945 06ca 01F4      		brne .+2
 1946 06cc 00C0      		rjmp .L70
 239:../../freeRtos/Lib/cmdline.c ****       if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 1948               	.LM165:
 1949 06ce 9585      		ldd r25,Z+13
 1950 06d0 8917      		cp r24,r25
 1951 06d2 01F4      		brne .L71
 243:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1953               	.LM166:
 1954 06d4 628D      		ldd r22,Z+26
 1955 06d6 738D      		ldd r23,Z+27
 1956 06d8 88E0      		ldi r24,lo8(8)
 1957 06da 90E0      		ldi r25,hi8(8)
 1958 06dc 0E94 0000 		call fputc
 244:../../freeRtos/Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 1960               	.LM167:
 1961 06e0 D701      		movw r26,r14
 1962 06e2 5A96      		adiw r26,26
 1963 06e4 6D91      		ld r22,X+
 1964 06e6 7C91      		ld r23,X
 1965 06e8 5B97      		sbiw r26,26+1
 1966 06ea 80E2      		ldi r24,lo8(32)
 1967 06ec 90E0      		ldi r25,hi8(32)
 1968 06ee 0E94 0000 		call fputc
 245:../../freeRtos/Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1970               	.LM168:
 1971 06f2 F701      		movw r30,r14
 1972 06f4 628D      		ldd r22,Z+26
 1973 06f6 738D      		ldd r23,Z+27
 1974 06f8 88E0      		ldi r24,lo8(8)
 1975 06fa 90E0      		ldi r25,hi8(8)
 1976 06fc 0E94 0000 		call fputc
 247:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferLength--;
 1978               	.LM169:
 1979 0700 D701      		movw r26,r14
 1980 0702 1D96      		adiw r26,13
 1981 0704 8C91      		ld r24,X
 1982 0706 1D97      		sbiw r26,13
 1983 0708 8150      		subi r24,lo8(-(-1))
 1984 070a 1D96      		adiw r26,13
 1985 070c 8C93      		st X,r24
 1986 070e 1D97      		sbiw r26,13
 248:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 1988               	.LM170:
 1989 0710 1E96      		adiw r26,14
 1990 0712 8C91      		ld r24,X
 1991 0714 1E97      		sbiw r26,14
 1992 0716 8150      		subi r24,lo8(-(-1))
 1993 0718 1E96      		adiw r26,14
 1994 071a 8C93      		st X,r24
 1995 071c 1E97      		sbiw r26,14
 1996 071e 00C0      		rjmp .L24
 1997               	.L71:
 255:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferLength--;
 1999               	.LM171:
 2000 0720 9150      		subi r25,lo8(-(-1))
 2001 0722 F701      		movw r30,r14
 2002 0724 9587      		std Z+13,r25
 256:../../freeRtos/Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 2004               	.LM172:
 2005 0726 8150      		subi r24,lo8(-(-1))
 2006 0728 8687      		std Z+14,r24
 257:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 2008               	.LM173:
 2009 072a 00C0      		rjmp .L72
 2010               	.L73:
 258:../../freeRtos/Lib/cmdline.c ****           state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
 2012               	.LM174:
 2013 072c FB01      		movw r30,r22
 2014 072e E80F      		add r30,r24
 2015 0730 F11D      		adc r31,__zero_reg__
 2016 0732 9181      		ldd r25,Z+1
 2017 0734 9083      		st Z,r25
 257:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 2019               	.LM175:
 2020 0736 8F5F      		subi r24,lo8(-(1))
 2021               	.L72:
 257:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 2023               	.LM176:
 2024 0738 D701      		movw r26,r14
 2025 073a 1D96      		adiw r26,13
 2026 073c 9C91      		ld r25,X
 2027 073e 1D97      		sbiw r26,13
 2028 0740 6D91      		ld r22,X+
 2029 0742 7C91      		ld r23,X
 2030 0744 1197      		sbiw r26,1
 2031 0746 8917      		cp r24,r25
 2032 0748 00F0      		brlo .L73
 260:../../freeRtos/Lib/cmdline.c ****         cmdlineRepaint(state, state->CmdlineBuffer);
 2034               	.LM177:
 2035 074a C701      		movw r24,r14
 2036 074c 0E94 0000 		call cmdlineRepaint
 262:../../freeRtos/Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 2038               	.LM178:
 2039 0750 F701      		movw r30,r14
 2040 0752 628D      		ldd r22,Z+26
 2041 0754 738D      		ldd r23,Z+27
 2042 0756 80E2      		ldi r24,lo8(32)
 2043 0758 90E0      		ldi r25,hi8(32)
 2044 075a 0E94 0000 		call fputc
 264:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2046               	.LM179:
 2047 075e D701      		movw r26,r14
 2048 0760 1E96      		adiw r26,14
 2049 0762 0C91      		ld r16,X
 2050 0764 1E97      		sbiw r26,14
 2051 0766 00C0      		rjmp .L74
 2052               	.L75:
 265:../../freeRtos/Lib/cmdline.c ****           fputc(ASCII_BS       , state->myStdInOut);
 2054               	.LM180:
 2055 0768 F701      		movw r30,r14
 2056 076a 628D      		ldd r22,Z+26
 2057 076c 738D      		ldd r23,Z+27
 2058 076e 88E0      		ldi r24,lo8(8)
 2059 0770 90E0      		ldi r25,hi8(8)
 2060 0772 0E94 0000 		call fputc
 264:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2062               	.LM181:
 2063 0776 0F5F      		subi r16,lo8(-(1))
 2064               	.L74:
 264:../../freeRtos/Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2066               	.LM182:
 2067 0778 D701      		movw r26,r14
 2068 077a 1D96      		adiw r26,13
 2069 077c 2C91      		ld r18,X
 2070 077e 1D97      		sbiw r26,13
 2071 0780 30E0      		ldi r19,lo8(0)
 2072 0782 802F      		mov r24,r16
 2073 0784 90E0      		ldi r25,lo8(0)
 2074 0786 2817      		cp r18,r24
 2075 0788 3907      		cpc r19,r25
 2076 078a 04F4      		brge .L75
 2077 078c 00C0      		rjmp .L24
 2078               	.L70:
 271:../../freeRtos/Lib/cmdline.c ****       fputc(ASCII_BEL          , state->myStdInOut);
 2080               	.LM183:
 2081 078e F701      		movw r30,r14
 2082 0790 628D      		ldd r22,Z+26
 2083 0792 738D      		ldd r23,Z+27
 2084 0794 87E0      		ldi r24,lo8(7)
 2085 0796 90E0      		ldi r25,hi8(7)
 2086 0798 0E94 0000 		call fputc
 2087 079c 00C0      		rjmp .L24
 2088               	.L69:
 274:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_DEL)
 2090               	.LM184:
 2091 079e 0F37      		cpi r16,lo8(127)
 2092 07a0 01F0      		breq .L24
 278:../../freeRtos/Lib/cmdline.c ****   else if(c == ASCII_ESC)
 2094               	.LM185:
 2095 07a2 0B31      		cpi r16,lo8(27)
 2096 07a4 01F4      		brne .L24
 280:../../freeRtos/Lib/cmdline.c ****     state->CmdlineInputVT100State = 1;
 2098               	.LM186:
 2099 07a6 81E0      		ldi r24,lo8(1)
 2100               	.L80:
 2101 07a8 D701      		movw r26,r14
 2102 07aa 5296      		adiw r26,18
 2103 07ac 8C93      		st X,r24
 2104 07ae 5297      		sbiw r26,18
 2105               	.L24:
 2106               	/* epilogue start */
 282:../../freeRtos/Lib/cmdline.c **** }
 2108               	.LM187:
 2109 07b0 2696      		adiw r28,6
 2110 07b2 CDBF      		out __SP_L__,r28
 2111 07b4 DEBF      		out __SP_H__,r29
 2112 07b6 CF91      		pop r28
 2113 07b8 DF91      		pop r29
 2114 07ba 1F91      		pop r17
 2115 07bc 0F91      		pop r16
 2116 07be FF90      		pop r15
 2117 07c0 EF90      		pop r14
 2118 07c2 DF90      		pop r13
 2119 07c4 CF90      		pop r12
 2120 07c6 BF90      		pop r11
 2121 07c8 AF90      		pop r10
 2122 07ca 9F90      		pop r9
 2123 07cc 8F90      		pop r8
 2124 07ce 0895      		ret
 2140               	.Lscope6:
 2142               		.stabd	78,0,0
 2145               	.global	cmdLineGetLastArgIdx
 2147               	cmdLineGetLastArgIdx:
 2148               		.stabd	46,0,0
 519:../../freeRtos/Lib/cmdline.c **** }
 520:../../freeRtos/Lib/cmdline.c **** 
 521:../../freeRtos/Lib/cmdline.c **** 
 522:../../freeRtos/Lib/cmdline.c **** uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
 523:../../freeRtos/Lib/cmdline.c **** {
 2150               	.LM188:
 2151               	.LFBB7:
 2152               	/* prologue: function */
 2153               	/* frame size = 0 */
 2154               	/* stack size = 0 */
 2155               	.L__stack_usage = 0
 524:../../freeRtos/Lib/cmdline.c ****   uint8_t result = 0;
 2157               	.LM189:
 2158 07d0 DC01      		movw r26,r24
 2159 07d2 1296      		adiw r26,2
 2160 07d4 ED91      		ld r30,X+
 2161 07d6 FC91      		ld r31,X
 2162 07d8 1397      		sbiw r26,2+1
 525:../../freeRtos/Lib/cmdline.c ****   uint8_t lastWhite = 1;
 2164               	.LM190:
 2165 07da 91E0      		ldi r25,lo8(1)
 524:../../freeRtos/Lib/cmdline.c ****   uint8_t result = 0;
 2167               	.LM191:
 2168 07dc 80E0      		ldi r24,lo8(0)
 526:../../freeRtos/Lib/cmdline.c ****   char *str = state->CmdlineExcBuffer;
 527:../../freeRtos/Lib/cmdline.c ****   while(*str != 0)
 2170               	.LM192:
 2171 07de 00C0      		rjmp .L89
 2172               	.L86:
 528:../../freeRtos/Lib/cmdline.c ****   {
 529:../../freeRtos/Lib/cmdline.c ****     if (*str == ' ')
 2174               	.LM193:
 2175 07e0 2032      		cpi r18,lo8(32)
 2176 07e2 01F4      		brne .L87
 530:../../freeRtos/Lib/cmdline.c ****     {
 531:../../freeRtos/Lib/cmdline.c ****       if (lastWhite == 0)
 2178               	.LM194:
 2179 07e4 9923      		tst r25
 2180 07e6 01F4      		brne .L88
 532:../../freeRtos/Lib/cmdline.c ****         result++;
 2182               	.LM195:
 2183 07e8 8F5F      		subi r24,lo8(-(1))
 2184 07ea 00C0      		rjmp .L88
 2185               	.L87:
 533:../../freeRtos/Lib/cmdline.c ****       lastWhite = 1;
 534:../../freeRtos/Lib/cmdline.c ****     }
 535:../../freeRtos/Lib/cmdline.c ****     else
 536:../../freeRtos/Lib/cmdline.c ****       lastWhite = 0;
 2187               	.LM196:
 2188 07ec 90E0      		ldi r25,lo8(0)
 2189 07ee 00C0      		rjmp .L89
 2190               	.L88:
 533:../../freeRtos/Lib/cmdline.c ****       lastWhite = 1;
 2192               	.LM197:
 2193 07f0 91E0      		ldi r25,lo8(1)
 2194               	.L89:
 527:../../freeRtos/Lib/cmdline.c ****   while(*str != 0)
 2196               	.LM198:
 2197 07f2 2191      		ld r18,Z+
 2198 07f4 2223      		tst r18
 2199 07f6 01F4      		brne .L86
 2200               	/* epilogue start */
 537:../../freeRtos/Lib/cmdline.c ****     str++;
 538:../../freeRtos/Lib/cmdline.c ****   }
 539:../../freeRtos/Lib/cmdline.c ****   return result;
 540:../../freeRtos/Lib/cmdline.c **** }
 2202               	.LM199:
 2203 07f8 0895      		ret
 2209               	.Lscope7:
 2211               		.stabd	78,0,0
 2214               	.global	cmdlineMainLoop
 2216               	cmdlineMainLoop:
 2217               		.stabd	46,0,0
 435:../../freeRtos/Lib/cmdline.c **** {
 2219               	.LM200:
 2220               	.LFBB8:
 2221 07fa 0F93      		push r16
 2222 07fc 1F93      		push r17
 2223 07fe CF93      		push r28
 2224 0800 DF93      		push r29
 2225               	/* prologue: function */
 2226               	/* frame size = 0 */
 2227               	/* stack size = 4 */
 2228               	.L__stack_usage = 4
 2229 0802 EC01      		movw r28,r24
 437:../../freeRtos/Lib/cmdline.c ****   if(state->CmdlineExecFunction)                // do we have a command/function to be executed
 2231               	.LM201:
 2232 0804 0F89      		ldd r16,Y+23
 2233 0806 188D      		ldd r17,Y+24
 2234 0808 0115      		cp r16,__zero_reg__
 2235 080a 1105      		cpc r17,__zero_reg__
 2236 080c 01F4      		brne .+2
 2237 080e 00C0      		rjmp .L90
 439:../../freeRtos/Lib/cmdline.c ****     state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
 2239               	.LM202:
 2240 0810 0E94 0000 		call cmdLineGetLastArgIdx
 2241 0814 898F      		std Y+25,r24
 440:../../freeRtos/Lib/cmdline.c ****     result = state->CmdlineExecFunction(state); // run it
 2243               	.LM203:
 2244 0816 CE01      		movw r24,r28
 2245 0818 F801      		movw r30,r16
 2246 081a 1995      		eicall
 442:../../freeRtos/Lib/cmdline.c ****     switch(result)
 2248               	.LM204:
 2249 081c 8230      		cpi r24,2
 2250 081e 9105      		cpc r25,__zero_reg__
 2251 0820 01F0      		breq .L94
 2252 0822 8330      		cpi r24,3
 2253 0824 9105      		cpc r25,__zero_reg__
 2254 0826 00F4      		brsh .L97
 2255 0828 8130      		cpi r24,1
 2256 082a 9105      		cpc r25,__zero_reg__
 2257 082c 01F0      		breq .+2
 2258 082e 00C0      		rjmp .L92
 2259 0830 00C0      		rjmp .L99
 2260               	.L97:
 2261 0832 8430      		cpi r24,4
 2262 0834 9105      		cpc r25,__zero_reg__
 2263 0836 01F4      		brne .+2
 2264 0838 00C0      		rjmp .L95
 2265 083a 8530      		cpi r24,5
 2266 083c 9105      		cpc r25,__zero_reg__
 2267 083e 01F0      		breq .+2
 2268 0840 00C0      		rjmp .L92
 2269 0842 00C0      		rjmp .L100
 2270               	.L99:
 445:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
 2272               	.LM205:
 2273 0844 00D0      		rcall .
 2274 0846 0F92      		push __tmp_reg__
 2275 0848 8A8D      		ldd r24,Y+26
 2276 084a 9B8D      		ldd r25,Y+27
 2277 084c EDB7      		in r30,__SP_L__
 2278 084e FEB7      		in r31,__SP_H__
 2279 0850 8183      		std Z+1,r24
 2280 0852 9283      		std Z+2,r25
 2281 0854 80E0      		ldi r24,lo8(__c.5199)
 2282 0856 90E0      		ldi r25,hi8(__c.5199)
 2283 0858 00C0      		rjmp .L98
 2284               	.L94:
 448:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
 2286               	.LM206:
 2287 085a 00D0      		rcall .
 2288 085c 0F92      		push __tmp_reg__
 2289 085e 8A8D      		ldd r24,Y+26
 2290 0860 9B8D      		ldd r25,Y+27
 2291 0862 EDB7      		in r30,__SP_L__
 2292 0864 FEB7      		in r31,__SP_H__
 2293 0866 8183      		std Z+1,r24
 2294 0868 9283      		std Z+2,r25
 2295 086a 80E0      		ldi r24,lo8(__c.5203)
 2296 086c 90E0      		ldi r25,hi8(__c.5203)
 2297 086e 8383      		std Z+3,r24
 2298 0870 9483      		std Z+4,r25
 2299 0872 0E94 0000 		call fprintf_P
 449:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_str);
 2301               	.LM207:
 2302 0876 8A8D      		ldd r24,Y+26
 2303 0878 9B8D      		ldd r25,Y+27
 2304 087a EDB7      		in r30,__SP_L__
 2305 087c FEB7      		in r31,__SP_H__
 2306 087e 8183      		std Z+1,r24
 2307 0880 9283      		std Z+2,r25
 2308 0882 8B89      		ldd r24,Y+19
 2309 0884 9C89      		ldd r25,Y+20
 2310 0886 8383      		std Z+3,r24
 2311 0888 9483      		std Z+4,r25
 2312 088a 0E94 0000 		call fprintf_P
 450:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR(" "));
 2314               	.LM208:
 2315 088e 8A8D      		ldd r24,Y+26
 2316 0890 9B8D      		ldd r25,Y+27
 2317 0892 EDB7      		in r30,__SP_L__
 2318 0894 FEB7      		in r31,__SP_H__
 2319 0896 8183      		std Z+1,r24
 2320 0898 9283      		std Z+2,r25
 2321 089a 80E0      		ldi r24,lo8(__c.5205)
 2322 089c 90E0      		ldi r25,hi8(__c.5205)
 2323 089e 8383      		std Z+3,r24
 2324 08a0 9483      		std Z+4,r25
 2325 08a2 0E94 0000 		call fprintf_P
 451:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_help_str);
 2327               	.LM209:
 2328 08a6 8A8D      		ldd r24,Y+26
 2329 08a8 9B8D      		ldd r25,Y+27
 2330 08aa EDB7      		in r30,__SP_L__
 2331 08ac FEB7      		in r31,__SP_H__
 2332 08ae 8183      		std Z+1,r24
 2333 08b0 9283      		std Z+2,r25
 2334 08b2 8D89      		ldd r24,Y+21
 2335 08b4 9E89      		ldd r25,Y+22
 2336 08b6 8383      		std Z+3,r24
 2337 08b8 9483      		std Z+4,r25
 2338 08ba 0E94 0000 		call fprintf_P
 452:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("\r\n"));
 2340               	.LM210:
 2341 08be 8A8D      		ldd r24,Y+26
 2342 08c0 9B8D      		ldd r25,Y+27
 2343 08c2 EDB7      		in r30,__SP_L__
 2344 08c4 FEB7      		in r31,__SP_H__
 2345 08c6 8183      		std Z+1,r24
 2346 08c8 9283      		std Z+2,r25
 2347 08ca 80E0      		ldi r24,lo8(__c.5207)
 2348 08cc 90E0      		ldi r25,hi8(__c.5207)
 2349 08ce 00C0      		rjmp .L98
 2350               	.L95:
 455:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
 2352               	.LM211:
 2353 08d0 00D0      		rcall .
 2354 08d2 0F92      		push __tmp_reg__
 2355 08d4 8A8D      		ldd r24,Y+26
 2356 08d6 9B8D      		ldd r25,Y+27
 2357 08d8 EDB7      		in r30,__SP_L__
 2358 08da FEB7      		in r31,__SP_H__
 2359 08dc 8183      		std Z+1,r24
 2360 08de 9283      		std Z+2,r25
 2361 08e0 80E0      		ldi r24,lo8(__c.5210)
 2362 08e2 90E0      		ldi r25,hi8(__c.5210)
 2363 08e4 00C0      		rjmp .L98
 2364               	.L100:
 458:../../freeRtos/Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
 2366               	.LM212:
 2367 08e6 00D0      		rcall .
 2368 08e8 0F92      		push __tmp_reg__
 2369 08ea 8A8D      		ldd r24,Y+26
 2370 08ec 9B8D      		ldd r25,Y+27
 2371 08ee EDB7      		in r30,__SP_L__
 2372 08f0 FEB7      		in r31,__SP_H__
 2373 08f2 8183      		std Z+1,r24
 2374 08f4 9283      		std Z+2,r25
 2375 08f6 80E0      		ldi r24,lo8(__c.5213)
 2376 08f8 90E0      		ldi r25,hi8(__c.5213)
 2377               	.L98:
 2378 08fa 8383      		std Z+3,r24
 2379 08fc 9483      		std Z+4,r25
 2380 08fe 0E94 0000 		call fprintf_P
 459:../../freeRtos/Lib/cmdline.c ****         break;
 2382               	.LM213:
 2383 0902 0F90      		pop __tmp_reg__
 2384 0904 0F90      		pop __tmp_reg__
 2385 0906 0F90      		pop __tmp_reg__
 2386 0908 0F90      		pop __tmp_reg__
 2387               	.L92:
 463:../../freeRtos/Lib/cmdline.c ****     state->CmdlineExecFunction = NULL;          // reset
 2389               	.LM214:
 2390 090a 1F8A      		std Y+23,__zero_reg__
 2391 090c 188E      		std Y+24,__zero_reg__
 464:../../freeRtos/Lib/cmdline.c ****     state->command_str         = NULL;
 2393               	.LM215:
 2394 090e 1B8A      		std Y+19,__zero_reg__
 2395 0910 1C8A      		std Y+20,__zero_reg__
 465:../../freeRtos/Lib/cmdline.c ****     state->command_help_str    = NULL;
 2397               	.LM216:
 2398 0912 1D8A      		std Y+21,__zero_reg__
 2399 0914 1E8A      		std Y+22,__zero_reg__
 466:../../freeRtos/Lib/cmdline.c ****     cmdlinePrintPrompt(state);                  // output new prompt
 2401               	.LM217:
 2402 0916 CE01      		movw r24,r28
 2403 0918 0E94 0000 		call cmdlinePrintPrompt
 2404               	.L90:
 2405               	/* epilogue start */
 468:../../freeRtos/Lib/cmdline.c **** }
 2407               	.LM218:
 2408 091c DF91      		pop r29
 2409 091e CF91      		pop r28
 2410 0920 1F91      		pop r17
 2411 0922 0F91      		pop r16
 2412 0924 0895      		ret
 2417               	.Lscope8:
 2419               		.stabd	78,0,0
 2423               	.global	cmdlineGetArgStr
 2425               	cmdlineGetArgStr:
 2426               		.stabd	46,0,0
 541:../../freeRtos/Lib/cmdline.c **** 
 542:../../freeRtos/Lib/cmdline.c **** char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
 543:../../freeRtos/Lib/cmdline.c **** {
 2428               	.LM219:
 2429               	.LFBB9:
 2430               	/* prologue: function */
 2431               	/* frame size = 0 */
 2432               	/* stack size = 0 */
 2433               	.L__stack_usage = 0
 544:../../freeRtos/Lib/cmdline.c ****   // find the offset of argument number [argnum]
 545:../../freeRtos/Lib/cmdline.c ****   uint8_t idx=0;
 546:../../freeRtos/Lib/cmdline.c ****   uint8_t arg;
 547:../../freeRtos/Lib/cmdline.c ****   
 548:../../freeRtos/Lib/cmdline.c ****   // find the first non-whitespace character
 549:../../freeRtos/Lib/cmdline.c ****   while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
 2435               	.LM220:
 2436 0926 FB01      		movw r30,r22
 2437 0928 2281      		ldd r18,Z+2
 2438 092a 3381      		ldd r19,Z+3
 545:../../freeRtos/Lib/cmdline.c ****   uint8_t idx=0;
 2440               	.LM221:
 2441 092c 90E0      		ldi r25,lo8(0)
 2443               	.LM222:
 2444 092e 00C0      		rjmp .L102
 2445               	.L103:
 2447               	.LM223:
 2448 0930 9F5F      		subi r25,lo8(-(1))
 2449               	.L102:
 2451               	.LM224:
 2452 0932 F901      		movw r30,r18
 2453 0934 E90F      		add r30,r25
 2454 0936 F11D      		adc r31,__zero_reg__
 2455 0938 4081      		ld r20,Z
 2456 093a 4032      		cpi r20,lo8(32)
 2457 093c 01F0      		breq .L103
 2458 093e 40E0      		ldi r20,lo8(0)
 2459 0940 00C0      		rjmp .L104
 2460               	.L107:
 550:../../freeRtos/Lib/cmdline.c ****   
 551:../../freeRtos/Lib/cmdline.c ****   // we are at the first argument
 552:../../freeRtos/Lib/cmdline.c ****   for(arg=0; arg<argnum; arg++)
 553:../../freeRtos/Lib/cmdline.c ****   {
 554:../../freeRtos/Lib/cmdline.c ****     // find the next whitespace character
 555:../../freeRtos/Lib/cmdline.c ****     while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
 2462               	.LM225:
 2463 0942 9F5F      		subi r25,lo8(-(1))
 2464               	.L113:
 2465 0944 F901      		movw r30,r18
 2466 0946 E90F      		add r30,r25
 2467 0948 F11D      		adc r31,__zero_reg__
 2468 094a 5081      		ld r21,Z
 2469 094c 5523      		tst r21
 2470 094e 01F0      		breq .L112
 2472               	.LM226:
 2473 0950 5032      		cpi r21,lo8(32)
 2474 0952 01F4      		brne .L107
 2475 0954 00C0      		rjmp .L112
 2476               	.L109:
 556:../../freeRtos/Lib/cmdline.c ****     // find the first non-whitespace character
 557:../../freeRtos/Lib/cmdline.c ****     while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
 2478               	.LM227:
 2479 0956 9F5F      		subi r25,lo8(-(1))
 2480               	.L112:
 2482               	.LM228:
 2483 0958 F901      		movw r30,r18
 2484 095a E90F      		add r30,r25
 2485 095c F11D      		adc r31,__zero_reg__
 2486 095e 5081      		ld r21,Z
 2487 0960 5032      		cpi r21,lo8(32)
 2488 0962 01F0      		breq .L109
 552:../../freeRtos/Lib/cmdline.c ****   for(arg=0; arg<argnum; arg++)
 2490               	.LM229:
 2491 0964 4F5F      		subi r20,lo8(-(1))
 2492               	.L104:
 552:../../freeRtos/Lib/cmdline.c ****   for(arg=0; arg<argnum; arg++)
 2494               	.LM230:
 2495 0966 4817      		cp r20,r24
 2496 0968 00F0      		brlo .L113
 558:../../freeRtos/Lib/cmdline.c ****   }
 559:../../freeRtos/Lib/cmdline.c ****   // we are at the requested argument or the end of the buffer
 560:../../freeRtos/Lib/cmdline.c ****   return &state->CmdlineExcBuffer[idx];
 2498               	.LM231:
 2499 096a 290F      		add r18,r25
 2500 096c 311D      		adc r19,__zero_reg__
 561:../../freeRtos/Lib/cmdline.c **** }
 2502               	.LM232:
 2503 096e C901      		movw r24,r18
 2504               	/* epilogue start */
 2505 0970 0895      		ret
 2511               	.Lscope9:
 2513               		.stabd	78,0,0
 2517               	.global	cmdlineGetArgInt
 2519               	cmdlineGetArgInt:
 2520               		.stabd	46,0,0
 562:../../freeRtos/Lib/cmdline.c **** 
 563:../../freeRtos/Lib/cmdline.c **** // return argument [argnum] interpreted as a decimal integer
 564:../../freeRtos/Lib/cmdline.c **** long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
 565:../../freeRtos/Lib/cmdline.c **** {
 2522               	.LM233:
 2523               	.LFBB10:
 2524 0972 DF93      		push r29
 2525 0974 CF93      		push r28
 2526 0976 0F92      		push __tmp_reg__
 2527 0978 0F92      		push __tmp_reg__
 2528 097a CDB7      		in r28,__SP_L__
 2529 097c DEB7      		in r29,__SP_H__
 2530               	/* prologue: function */
 2531               	/* frame size = 2 */
 2532               	/* stack size = 4 */
 2533               	.L__stack_usage = 4
 566:../../freeRtos/Lib/cmdline.c ****   char* endptr;
 567:../../freeRtos/Lib/cmdline.c ****   return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
 2535               	.LM234:
 2536 097e 0E94 0000 		call cmdlineGetArgStr
 2537 0982 BE01      		movw r22,r28
 2538 0984 6F5F      		subi r22,lo8(-(1))
 2539 0986 7F4F      		sbci r23,hi8(-(1))
 2540 0988 4AE0      		ldi r20,lo8(10)
 2541 098a 50E0      		ldi r21,hi8(10)
 2542 098c 0E94 0000 		call strtol
 2543               	/* epilogue start */
 568:../../freeRtos/Lib/cmdline.c **** }
 2545               	.LM235:
 2546 0990 0F90      		pop __tmp_reg__
 2547 0992 0F90      		pop __tmp_reg__
 2548 0994 CF91      		pop r28
 2549 0996 DF91      		pop r29
 2550 0998 0895      		ret
 2555               	.Lscope10:
 2557               		.stabd	78,0,0
 2561               	.global	cmdlineGetArgHex
 2563               	cmdlineGetArgHex:
 2564               		.stabd	46,0,0
 569:../../freeRtos/Lib/cmdline.c **** 
 570:../../freeRtos/Lib/cmdline.c **** // return argument [argnum] interpreted as a hex integer
 571:../../freeRtos/Lib/cmdline.c **** long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
 572:../../freeRtos/Lib/cmdline.c **** {
 2566               	.LM236:
 2567               	.LFBB11:
 2568 099a DF93      		push r29
 2569 099c CF93      		push r28
 2570 099e 0F92      		push __tmp_reg__
 2571 09a0 0F92      		push __tmp_reg__
 2572 09a2 CDB7      		in r28,__SP_L__
 2573 09a4 DEB7      		in r29,__SP_H__
 2574               	/* prologue: function */
 2575               	/* frame size = 2 */
 2576               	/* stack size = 4 */
 2577               	.L__stack_usage = 4
 573:../../freeRtos/Lib/cmdline.c ****   char* endptr;
 574:../../freeRtos/Lib/cmdline.c ****   return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
 2579               	.LM237:
 2580 09a6 0E94 0000 		call cmdlineGetArgStr
 2581 09aa BE01      		movw r22,r28
 2582 09ac 6F5F      		subi r22,lo8(-(1))
 2583 09ae 7F4F      		sbci r23,hi8(-(1))
 2584 09b0 40E1      		ldi r20,lo8(16)
 2585 09b2 50E0      		ldi r21,hi8(16)
 2586 09b4 0E94 0000 		call strtol
 2587               	/* epilogue start */
 575:../../freeRtos/Lib/cmdline.c **** }
 2589               	.LM238:
 2590 09b8 0F90      		pop __tmp_reg__
 2591 09ba 0F90      		pop __tmp_reg__
 2592 09bc CF91      		pop r28
 2593 09be DF91      		pop r29
 2594 09c0 0895      		ret
 2599               	.Lscope11:
 2601               		.stabd	78,0,0
 2604               	.global	cmdPrintHelp
 2606               	cmdPrintHelp:
 2607               		.stabd	46,0,0
 576:../../freeRtos/Lib/cmdline.c **** 
 577:../../freeRtos/Lib/cmdline.c **** void cmdPrintHelp(cmdState_t *state)
 578:../../freeRtos/Lib/cmdline.c **** {
 2609               	.LM239:
 2610               	.LFBB12:
 2611 09c2 8F92      		push r8
 2612 09c4 9F92      		push r9
 2613 09c6 AF92      		push r10
 2614 09c8 BF92      		push r11
 2615 09ca CF92      		push r12
 2616 09cc DF92      		push r13
 2617 09ce EF92      		push r14
 2618 09d0 FF92      		push r15
 2619 09d2 0F93      		push r16
 2620 09d4 1F93      		push r17
 2621 09d6 DF93      		push r29
 2622 09d8 CF93      		push r28
 2623 09da 00D0      		rcall .
 2624 09dc 00D0      		rcall .
 2625 09de CDB7      		in r28,__SP_L__
 2626 09e0 DEB7      		in r29,__SP_H__
 2627               	/* prologue: function */
 2628               	/* frame size = 6 */
 2629               	/* stack size = 18 */
 2630               	.L__stack_usage = 18
 2631 09e2 8C01      		movw r16,r24
 579:../../freeRtos/Lib/cmdline.c ****   command_t  tmp;
 580:../../freeRtos/Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;
 2633               	.LM240:
 2634 09e4 FC01      		movw r30,r24
 2635 09e6 E1A0      		ldd r14,Z+33
 2636 09e8 F2A0      		ldd r15,Z+34
 581:../../freeRtos/Lib/cmdline.c ****   
 582:../../freeRtos/Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));
 2638               	.LM241:
 2639 09ea 6E01      		movw r12,r28
 2640 09ec 0894      		sec
 2641 09ee C11C      		adc r12,__zero_reg__
 2642 09f0 D11C      		adc r13,__zero_reg__
 2643 09f2 C601      		movw r24,r12
 2644 09f4 B701      		movw r22,r14
 2645 09f6 46E0      		ldi r20,lo8(6)
 2646 09f8 50E0      		ldi r21,hi8(6)
 2647 09fa 0E94 0000 		call memcpy_P
 583:../../freeRtos/Lib/cmdline.c ****   do
 584:../../freeRtos/Lib/cmdline.c ****   {
 585:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandStr);
 586:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\t"));
 2649               	.LM242:
 2650 09fe 90E0      		ldi r25,lo8(__c.5301)
 2651 0a00 A92E      		mov r10,r25
 2652 0a02 90E0      		ldi r25,hi8(__c.5301)
 2653 0a04 B92E      		mov r11,r25
 587:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandHelpStr);
 588:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\r\n"));
 2655               	.LM243:
 2656 0a06 80E0      		ldi r24,lo8(__c.5303)
 2657 0a08 882E      		mov r8,r24
 2658 0a0a 80E0      		ldi r24,hi8(__c.5303)
 2659 0a0c 982E      		mov r9,r24
 589:../../freeRtos/Lib/cmdline.c **** 
 590:../../freeRtos/Lib/cmdline.c ****     tmpPtr++;
 591:../../freeRtos/Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));
 2661               	.LM244:
 2662 0a0e C601      		movw r24,r12
 2663 0a10 DC2C      		mov r13,r12
 2664 0a12 C92E      		mov r12,r25
 2665               	.L117:
 585:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandStr);
 2667               	.LM245:
 2668 0a14 00D0      		rcall .
 2669 0a16 0F92      		push __tmp_reg__
 2670 0a18 F801      		movw r30,r16
 2671 0a1a 828D      		ldd r24,Z+26
 2672 0a1c 938D      		ldd r25,Z+27
 2673 0a1e EDB7      		in r30,__SP_L__
 2674 0a20 FEB7      		in r31,__SP_H__
 2675 0a22 8183      		std Z+1,r24
 2676 0a24 9283      		std Z+2,r25
 2677 0a26 8981      		ldd r24,Y+1
 2678 0a28 9A81      		ldd r25,Y+2
 2679 0a2a 8383      		std Z+3,r24
 2680 0a2c 9483      		std Z+4,r25
 2681 0a2e 0E94 0000 		call fprintf_P
 586:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\t"));
 2683               	.LM246:
 2684 0a32 F801      		movw r30,r16
 2685 0a34 828D      		ldd r24,Z+26
 2686 0a36 938D      		ldd r25,Z+27
 2687 0a38 EDB7      		in r30,__SP_L__
 2688 0a3a FEB7      		in r31,__SP_H__
 2689 0a3c 8183      		std Z+1,r24
 2690 0a3e 9283      		std Z+2,r25
 2691 0a40 A382      		std Z+3,r10
 2692 0a42 B482      		std Z+4,r11
 2693 0a44 0E94 0000 		call fprintf_P
 587:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandHelpStr);
 2695               	.LM247:
 2696 0a48 F801      		movw r30,r16
 2697 0a4a 828D      		ldd r24,Z+26
 2698 0a4c 938D      		ldd r25,Z+27
 2699 0a4e EDB7      		in r30,__SP_L__
 2700 0a50 FEB7      		in r31,__SP_H__
 2701 0a52 8183      		std Z+1,r24
 2702 0a54 9283      		std Z+2,r25
 2703 0a56 8B81      		ldd r24,Y+3
 2704 0a58 9C81      		ldd r25,Y+4
 2705 0a5a 8383      		std Z+3,r24
 2706 0a5c 9483      		std Z+4,r25
 2707 0a5e 0E94 0000 		call fprintf_P
 588:../../freeRtos/Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\r\n"));
 2709               	.LM248:
 2710 0a62 F801      		movw r30,r16
 2711 0a64 828D      		ldd r24,Z+26
 2712 0a66 938D      		ldd r25,Z+27
 2713 0a68 EDB7      		in r30,__SP_L__
 2714 0a6a FEB7      		in r31,__SP_H__
 2715 0a6c 8183      		std Z+1,r24
 2716 0a6e 9283      		std Z+2,r25
 2717 0a70 8382      		std Z+3,r8
 2718 0a72 9482      		std Z+4,r9
 2719 0a74 0E94 0000 		call fprintf_P
 590:../../freeRtos/Lib/cmdline.c ****     tmpPtr++;
 2721               	.LM249:
 2722 0a78 86E0      		ldi r24,lo8(6)
 2723 0a7a 90E0      		ldi r25,hi8(6)
 2724 0a7c E80E      		add r14,r24
 2725 0a7e F91E      		adc r15,r25
 2727               	.LM250:
 2728 0a80 0F90      		pop __tmp_reg__
 2729 0a82 0F90      		pop __tmp_reg__
 2730 0a84 0F90      		pop __tmp_reg__
 2731 0a86 0F90      		pop __tmp_reg__
 2732 0a88 8D2D      		mov r24,r13
 2733 0a8a 9C2D      		mov r25,r12
 2734 0a8c B701      		movw r22,r14
 2735 0a8e 46E0      		ldi r20,lo8(6)
 2736 0a90 50E0      		ldi r21,hi8(6)
 2737 0a92 0E94 0000 		call memcpy_P
 592:../../freeRtos/Lib/cmdline.c ****   }
 593:../../freeRtos/Lib/cmdline.c ****   while (tmp.commandFun != NULL);
 2739               	.LM251:
 2740 0a96 8D81      		ldd r24,Y+5
 2741 0a98 9E81      		ldd r25,Y+6
 2742 0a9a 0097      		sbiw r24,0
 2743 0a9c 01F0      		breq .+2
 2744 0a9e 00C0      		rjmp .L117
 2745               	/* epilogue start */
 594:../../freeRtos/Lib/cmdline.c **** }
 2747               	.LM252:
 2748 0aa0 2696      		adiw r28,6
 2749 0aa2 CDBF      		out __SP_L__,r28
 2750 0aa4 DEBF      		out __SP_H__,r29
 2751 0aa6 CF91      		pop r28
 2752 0aa8 DF91      		pop r29
 2753 0aaa 1F91      		pop r17
 2754 0aac 0F91      		pop r16
 2755 0aae FF90      		pop r15
 2756 0ab0 EF90      		pop r14
 2757 0ab2 DF90      		pop r13
 2758 0ab4 CF90      		pop r12
 2759 0ab6 BF90      		pop r11
 2760 0ab8 AF90      		pop r10
 2761 0aba 9F90      		pop r9
 2762 0abc 8F90      		pop r8
 2763 0abe 0895      		ret
 2769               	.Lscope12:
 2771               		.stabd	78,0,0
 2772               	.global	CmdlinePromptNormal
 2773               		.section	.progmem.data,"a",@progbits
 2776               	CmdlinePromptNormal:
 2777 0000 446F 6D4F 		.string	"DomOs>"
 2777      733E 00
 2778               	.global	CmdlinePromptEnable
 2781               	CmdlinePromptEnable:
 2782 0007 446F 6D4F 		.string	"DomOs#"
 2782      7323 00
 2783               	.global	CmdlinePromptConfigure
 2786               	CmdlinePromptConfigure:
 2787 000e 446F 6D4F 		.string	"DomOs@"
 2787      7340 00
 2788               	.global	CmdlineNotice
 2791               	CmdlineNotice:
 2792 0015 636D 646C 		.string	"cmdline: "
 2792      696E 653A 
 2792      2000 
 2793               	.global	CmdlineCmdNotFound
 2796               	CmdlineCmdNotFound:
 2797 001f 2320 6E6B 		.string	"# nk"
 2797      00
 2798               		.comm klastry,128,1
 2799               		.comm wwwport,1,1
 2800               		.comm rollers,2,1
 2801               		.comm xSemaphoreSpiSS,2,1
 2802               		.comm portA,1,1
 2803               		.comm portB,1,1
 2804               		.comm lockSensors,2,1
 2805               		.comm xSemaphoreRs485,2,1
 2806               		.comm nicState,14,1
 2807               		.comm plen,2,1
 2808               		.comm IpMyConfig,15,1
 2809               		.comm arpDebug,2,1
 2810               		.comm arpDebugLevel,1,1
 2811               		.comm icmpDebug,2,1
 2812               		.comm icmpDebugLevel,1,1
 2813               		.comm udpSocket,2,1
 2814               		.comm udpDbgStream,2,1
 2815               		.comm udpDbgLevel,1,1
 2816               		.comm tcpDebugStream,2,1
 2817               		.comm tcpDebugLevel,1,1
 2818               		.comm sockets,2,1
 2819               		.comm czasRtc,7,1
 2822               	__c.5303:
 2823 0024 0D0A 00   		.string	"\r\n"
 2826               	__c.5301:
 2827 0027 0900      		.string	"\t"
 2830               	__c.5213:
 2831 0029 4F70 6572 		.string	"Operation not allowed\r\n"
 2831      6174 696F 
 2831      6E20 6E6F 
 2831      7420 616C 
 2831      6C6F 7765 
 2834               	__c.5210:
 2835 0041 4F70 6572 		.string	"Operation failed\r\n"
 2835      6174 696F 
 2835      6E20 6661 
 2835      696C 6564 
 2835      0D0A 00
 2838               	__c.5207:
 2839 0054 0D0A 00   		.string	"\r\n"
 2842               	__c.5205:
 2843 0057 2000      		.string	" "
 2846               	__c.5203:
 2847 0059 5379 6E74 		.string	"Syntax Error. Use: "
 2847      6178 2045 
 2847      7272 6F72 
 2847      2E20 5573 
 2847      653A 2000 
 2850               	__c.5199:
 2851 006d 4F4B 0D0A 		.string	"OK\r\n"
 2851      00
 2852               		.data
 2855               	CSWTCH.2:
 2856 0000 0000      		.word	CmdlinePromptNormal
 2857 0002 0000      		.word	CmdlinePromptEnable
 2858 0004 0000      		.word	CmdlinePromptConfigure
 2886               		.text
 2888               	.Letext0:
 2889               	.global __do_copy_data
 2890               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 cmdline.c
     /tmp/ccfIUZ3H.s:2      *ABS*:0000003f __SREG__
     /tmp/ccfIUZ3H.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccfIUZ3H.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccfIUZ3H.s:5      *ABS*:00000034 __CCP__
     /tmp/ccfIUZ3H.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccfIUZ3H.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccfIUZ3H.s:563    .text:00000000 cmdlinePrintPrompt
     /tmp/ccfIUZ3H.s:2855   .data:00000000 CSWTCH.2
     /tmp/ccfIUZ3H.s:2776   .progmem.data:00000000 CmdlinePromptNormal
     /tmp/ccfIUZ3H.s:656    .text:00000056 cmdlineRepaint
     /tmp/ccfIUZ3H.s:768    .text:000000d4 cmdlineDoHistory
     /tmp/ccfIUZ3H.s:935    .text:000001a0 cmdHistoryCopy
     /tmp/ccfIUZ3H.s:1014   .text:000001ec cmdStateConfigure
     /tmp/ccfIUZ3H.s:1130   .text:00000274 cmdlineInputFunc
     /tmp/ccfIUZ3H.s:2791   .progmem.data:00000015 CmdlineNotice
     /tmp/ccfIUZ3H.s:2796   .progmem.data:0000001f CmdlineCmdNotFound
     /tmp/ccfIUZ3H.s:2147   .text:000007d0 cmdLineGetLastArgIdx
     /tmp/ccfIUZ3H.s:2216   .text:000007fa cmdlineMainLoop
     /tmp/ccfIUZ3H.s:2850   .progmem.data:0000006d __c.5199
     /tmp/ccfIUZ3H.s:2846   .progmem.data:00000059 __c.5203
     /tmp/ccfIUZ3H.s:2842   .progmem.data:00000057 __c.5205
     /tmp/ccfIUZ3H.s:2838   .progmem.data:00000054 __c.5207
     /tmp/ccfIUZ3H.s:2834   .progmem.data:00000041 __c.5210
     /tmp/ccfIUZ3H.s:2830   .progmem.data:00000029 __c.5213
     /tmp/ccfIUZ3H.s:2425   .text:00000926 cmdlineGetArgStr
     /tmp/ccfIUZ3H.s:2519   .text:00000972 cmdlineGetArgInt
     /tmp/ccfIUZ3H.s:2563   .text:0000099a cmdlineGetArgHex
     /tmp/ccfIUZ3H.s:2606   .text:000009c2 cmdPrintHelp
     /tmp/ccfIUZ3H.s:2826   .progmem.data:00000027 __c.5301
     /tmp/ccfIUZ3H.s:2822   .progmem.data:00000024 __c.5303
     /tmp/ccfIUZ3H.s:2781   .progmem.data:00000007 CmdlinePromptEnable
     /tmp/ccfIUZ3H.s:2786   .progmem.data:0000000e CmdlinePromptConfigure
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:0000000e nicState
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000007 czasRtc

UNDEFINED SYMBOLS
fputc
memset
strcpy
memcpy_P
strncmp_P
fprintf_P
strtol
__do_copy_data
__do_clear_bss
